import { Accordion as Accordion$1, AccordionButton as AccordionButton$1, AccordionPanel as AccordionPanel$1, AccordionItem as AccordionItem$1, useInterval, useMediaQuery, useToken as useToken$1, Box, useMultiStyleConfig, chakra, Alert as Alert$2, AspectRatio as AspectRatio$1, forwardRef, useStyleConfig, Icon as Icon$2, Heading, Text, FormLabel as FormLabel$1, VisuallyHidden, HStack, Badge as Badge$2, Spinner as Spinner$2, Button as Button$2, Checkbox as Checkbox$2, FormControl, Stack, FormErrorMessage, Flex, IconButton as IconButton$1, Popover as Popover$2, useDisclosure, useBoolean, PopoverTrigger, PopoverContent, PopoverHeader, PopoverBody, SimpleGrid, SlideFade as SlideFade$1, keyframes, extendTheme, Table as Table$2, Thead, Tbody, Tr, Select as Select$2, PopoverAnchor, InputGroup, InputRightElement, Link as Link$1, Portal, Tooltip as Tooltip$2, VStack, Circle, Center, Fade as Fade$1, ScaleFade as ScaleFade$1, Slide as Slide$1, Collapse as Collapse$1, CloseButton as CloseButton$1, Radio as Radio$2, RadioGroup as RadioGroup$1, Tag as Tag$2, TagLabel, TagRightIcon, useEditableControls, useEditableState, Editable, InputLeftElement, Input as Input$1, EditablePreview, EditableInput, Modal as Modal$2, ModalOverlay, ModalContent, ModalCloseButton, ModalBody as ModalBody$1, ModalHeader, Slider, SliderTrack, SliderFilledTrack, SliderThumb, ModalFooter, Progress, Image as Image$1, ChakraProvider, Menu as Menu$2, NumberInputStepper as NumberInputStepper$1, Divider, NumberIncrementStepper, NumberDecrementStepper, NumberInput as NumberInput$2, NumberInputField as NumberInputField$1, PinInput as PinInput$2, Switch as Switch$2, TabPanel as TabPanel$1, Tabs as Tabs$2, Textarea as Textarea$2, useToast as useToast$1, TagLeftIcon, AlertTitle, AlertDescription, Tab, TabList, useClipboard, Grid, GridItem, useOutsideClick } from '@chakra-ui/react';
export { AbsoluteCenter, AccordionIcon, AlertDescription, AlertDialog, AlertDialogBody, AlertDialogCloseButton, AlertDialogContent, AlertDialogFooter, AlertDialogHeader, AlertDialogOverlay, AlertIcon, AlertTitle, Box, BreadcrumbItem as Breadcrumb, BreadcrumbLink, BreadcrumbSeparator, Breadcrumb as Breadcrumbs, ButtonGroup, Card, CardBody, CardFooter, CardHeader, Center, Modal as ChakraModal, CheckboxGroup, Circle, CircularProgress, CircularProgressLabel, CloseButton, Code, Container, Divider, Drawer, DrawerBody, DrawerCloseButton, DrawerContent, DrawerFooter, DrawerHeader, DrawerOverlay, Editable, EditableInput, EditablePreview, Flex, FormControl, FormErrorMessage, FormHelperText, Grid, GridItem, HStack, Heading, Hide, Highlight, Image, Input, InputAddon, InputGroup, InputLeftAddon, InputLeftElement, InputRightAddon, InputRightElement, Kbd, Link, LinkBox, LinkOverlay, List, ListIcon, ListItem, MenuButton, MenuCommand, MenuDivider, MenuGroup, MenuIcon, MenuItem, MenuItemOption, MenuList, MenuOptionGroup, ModalCloseButton, ModalContent, ModalFooter, ModalHeader, NumberDecrementStepper, NumberIncrementStepper, OrderedList, PinInputField, PopoverAnchor, PopoverArrow, PopoverBody, PopoverCloseButton, PopoverContent, PopoverFooter, PopoverHeader, PopoverTrigger, Portal, RangeSlider, RangeSliderFilledTrack, RangeSliderMark, RangeSliderThumb, RangeSliderTrack, Show, SimpleGrid, Skeleton, SkeletonCircle, SkeletonText, Slider, SliderFilledTrack, SliderMark, SliderThumb, SliderTrack, Spacer, Stack, StackDivider, Stat, StatArrow, StatGroup, StatHelpText, StatLabel, StatNumber, TabIndicator as StepIndicator, TabPanels as StepPanels, Tab, TabIndicator, TabList, TabPanels, TableCaption, TableContainer, TagCloseButton, TagLabel, TagLeftIcon, TagRightIcon, Tbody, Td, Text, Tfoot, Th, Thead, Tr, UnorderedList, VStack, VisuallyHidden, VisuallyHiddenInput, Wrap, WrapItem, keyframes, useBoolean, useBreakpoint, useBreakpointValue, useClipboard, useControllableProp, useControllableState, useDisclosure, useEditable, useEditableControls, useEditableState, useInterval, useMediaQuery, useMergeRefs, useNumberInput, useOutsideClick, usePrefersReducedMotion, useRadio, useRadioGroup, useTab, useTabs, useTheme, useToken } from '@chakra-ui/react';
import React, { useState, useEffect, useRef, isValidElement, cloneElement, Children, createContext, useContext, forwardRef as forwardRef$1, useImperativeHandle, memo, useMemo, useCallback } from 'react';
import { CreatableSelect, chakraComponents, AsyncSelect, Select as Select$3 } from 'chakra-react-select';
export { AsyncCreatableSelect, AsyncSelect, Select as ChakraReactSelect, CreatableSelect } from 'chakra-react-select';
import { isNil, last, map, prop, difference, replace, split, path, T, identity, any, isEmpty, init, append, ifElse, gt, always, defaultTo, take, inc, dec, forEach, is, trim, keys, values, equals, omit, mergeAll, merge, toLower, find, times, add, has, not, all, filter, test, indexOf, remove, insert, intersection, findIndex, concat, head, match, length, propEq } from 'ramda';
import { useFocusManager, FocusScope, useFocusRing } from '@react-aria/focus';
import { useForm, FormProvider, useFormContext, Controller } from 'react-hook-form';
export { useController, useFieldArray, useForm, useFormContext, useFormState, useWatch } from 'react-hook-form';
import { useToken, useMultiStyleConfig as useMultiStyleConfig$1, chakra as chakra$1 } from '@chakra-ui/system';
import { palette, WebappComponentsTokensSet, WebappSystemTokensSet, typography, TottComponentsTokensSet, TottSystemTokensSet, coreZIndex, coreSizing, coreSpacing, coreFontWeight, coreBoxShadow, coreFontSize, coreLineHeight, coreBorderRadius } from '@northlight/tokens';
import { UserSquareDuo, BusinessContactDuo, CheckDuo, ChevronUpDuo, ChevronDownDuo, ColorsDuo, CheckSolid, CalendarDuo, ChevronLeftSolid, ChevronRightSolid, XCloseSolid, CheckCircleSolid, AlertTriangleSolid, AlertCircleSolid, BellSolid, BrightnessSolid, HelpCircleSolid, TrashDuo, SearchDuo, DotsMatrixSolid, DragDuo, EditDuo, ZoomInDuo, Image03Solid, UploadCloudSolid, FileBlankDuo, EditBoxDuo, DownloadDuo, TrashFullDuo, Image03Duo, ChevronUpSolid, ChevronDownSolid, StatusWorkingSolid, HourglassSolid, CDeleteSolid, CopyDuo, PlusSolid } from '@northlight/icons';
import { joiResolver } from '@hookform/resolvers/joi';
import { useCheckboxGroup, useCheckboxGroupItem } from '@react-aria/checkbox';
import { useRadioGroup, useRadio } from '@react-aria/radio';
import { mergeProps } from '@react-aria/utils';
import { useRadioGroupState } from '@react-stately/radio';
import { useCheckboxGroupState } from '@react-stately/checkbox';
import { randomColor, cssVar } from '@chakra-ui/theme-tools';
import { useDateSegment, useDateField, useDatePicker, useDateRangePicker } from '@react-aria/datepicker';
import { useDateFieldState, useDatePickerState, useDateRangePickerState } from '@react-stately/datepicker';
import { createCalendar, today, isSameMonth, getWeeksInMonth, getDayOfWeek, GregorianCalendar, parseDate, startOfWeek, endOfWeek, startOfMonth, endOfMonth, startOfYear, endOfYear } from '@internationalized/date';
import { useButton } from '@react-aria/button';
import { useDateFormatter, useLocale } from '@react-aria/i18n';
import { useCalendarState } from '@react-stately/calendar';
import { useCalendarCell, useCalendarGrid, useCalendar } from '@react-aria/calendar';
import { Link as Link$2 } from 'react-router-dom';
import { useClickable } from '@chakra-ui/clickable';
import { motion, useMotionValue, animate } from 'framer-motion';
import { DndContext, useDraggable, useDroppable, useSensors, useSensor, PointerSensor, KeyboardSensor, rectIntersection, DragOverlay } from '@dnd-kit/core';
export * from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
export * from '@dnd-kit/utilities';
export { useInterval as dndUseInterval } from '@dnd-kit/utilities';
import { SortableContext, useSortable, sortableKeyboardCoordinates, arrayMove, rectSortingStrategy } from '@dnd-kit/sortable';
export * from '@dnd-kit/sortable';
export * from '@dnd-kit/modifiers';
import { VariableSizeList, VariableSizeGrid } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import AvatarEditor from 'react-avatar-editor';
import { NumericFormat } from 'react-number-format';
import InputMask from 'react-input-mask';

var __defProp$2q = Object.defineProperty;
var __getOwnPropSymbols$2q = Object.getOwnPropertySymbols;
var __hasOwnProp$2q = Object.prototype.hasOwnProperty;
var __propIsEnum$2q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2q = (obj, key, value) => key in obj ? __defProp$2q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2q.call(b, prop))
      __defNormalProp$2q(a, prop, b[prop]);
  if (__getOwnPropSymbols$2q)
    for (var prop of __getOwnPropSymbols$2q(b)) {
      if (__propIsEnum$2q.call(b, prop))
        __defNormalProp$2q(a, prop, b[prop]);
    }
  return a;
};
const Accordion = (props) => /* @__PURE__ */ React.createElement(Accordion$1, __spreadValues$2q({}, props));

var __defProp$2p = Object.defineProperty;
var __getOwnPropSymbols$2p = Object.getOwnPropertySymbols;
var __hasOwnProp$2p = Object.prototype.hasOwnProperty;
var __propIsEnum$2p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2p = (obj, key, value) => key in obj ? __defProp$2p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2p.call(b, prop))
      __defNormalProp$2p(a, prop, b[prop]);
  if (__getOwnPropSymbols$2p)
    for (var prop of __getOwnPropSymbols$2p(b)) {
      if (__propIsEnum$2p.call(b, prop))
        __defNormalProp$2p(a, prop, b[prop]);
    }
  return a;
};
const AccordionButton = (props) => /* @__PURE__ */ React.createElement(AccordionButton$1, __spreadValues$2p({}, props));

var __defProp$2o = Object.defineProperty;
var __getOwnPropSymbols$2o = Object.getOwnPropertySymbols;
var __hasOwnProp$2o = Object.prototype.hasOwnProperty;
var __propIsEnum$2o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2o = (obj, key, value) => key in obj ? __defProp$2o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2o.call(b, prop))
      __defNormalProp$2o(a, prop, b[prop]);
  if (__getOwnPropSymbols$2o)
    for (var prop of __getOwnPropSymbols$2o(b)) {
      if (__propIsEnum$2o.call(b, prop))
        __defNormalProp$2o(a, prop, b[prop]);
    }
  return a;
};
const AccordionPanel = (props) => /* @__PURE__ */ React.createElement(AccordionPanel$1, __spreadValues$2o({}, props));

var __defProp$2n = Object.defineProperty;
var __getOwnPropSymbols$2n = Object.getOwnPropertySymbols;
var __hasOwnProp$2n = Object.prototype.hasOwnProperty;
var __propIsEnum$2n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2n = (obj, key, value) => key in obj ? __defProp$2n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2n.call(b, prop))
      __defNormalProp$2n(a, prop, b[prop]);
  if (__getOwnPropSymbols$2n)
    for (var prop of __getOwnPropSymbols$2n(b)) {
      if (__propIsEnum$2n.call(b, prop))
        __defNormalProp$2n(a, prop, b[prop]);
    }
  return a;
};
const AccordionItem = (props) => /* @__PURE__ */ React.createElement(AccordionItem$1, __spreadValues$2n({}, props));

const useDebounce = (value, delay) => {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
};

const useLoadingMessage = (prefix = "", delay = 300) => {
  const [dots, setDots] = useState(".");
  useInterval(() => {
    if (dots.length === 3) {
      setDots(".");
    } else {
      setDots(`${dots}.`);
    }
  }, delay);
  return `${prefix}${dots}`;
};

const smoothScrollToBottom = (div) => {
  const totalSteps = 50;
  let currentStep = 0;
  const targetScrollTop = div.scrollHeight - div.clientHeight;
  const originalScrollTop = div.scrollTop;
  const scrollInterval = setInterval(() => {
    if (currentStep >= totalSteps) {
      clearInterval(scrollInterval);
    } else {
      currentStep += 1;
      const scrollProgress = currentStep / totalSteps;
      const easing = 1 - (1 - scrollProgress) * (1 - scrollProgress);
      div.scrollTop = originalScrollTop + (targetScrollTop - originalScrollTop) * easing;
    }
  }, 20);
};

const useScrollToBottom = (scrollView, messages) => {
  useEffect(() => {
    const div = scrollView.current;
    if (div) {
      smoothScrollToBottom(div);
    }
  }, [messages]);
};

const useArrowFocus = (columns) => {
  const {
    focusNext: next,
    focusPrevious: previous,
    focusFirst,
    focusLast
  } = useFocusManager();
  const defaultOpts = {
    ArrowRight: {
      wrap: true,
      repeat: 1
    },
    ArrowLeft: {
      wrap: true,
      repeat: 1
    },
    ArrowDown: {
      wrap: false,
      repeat: columns
    },
    ArrowUp: {
      wrap: false,
      repeat: columns
    }
  };
  const focusPrevious = ({
    repeat,
    wrap
  } = defaultOpts.ArrowLeft) => {
    for (let i = 0; i < repeat; i += 1) {
      previous({ wrap });
    }
  };
  const focusNext = ({
    repeat,
    wrap
  } = defaultOpts.ArrowRight) => {
    for (let i = 0; i < repeat; i += 1) {
      next({ wrap });
    }
  };
  const defaultArrows = (e) => {
    switch (e.key) {
      case "ArrowRight":
        focusNext(defaultOpts.ArrowRight);
        break;
      case "ArrowLeft":
        focusPrevious(defaultOpts.ArrowLeft);
        break;
      case "ArrowDown":
        e.preventDefault();
        focusNext(defaultOpts.ArrowDown);
        break;
      case "ArrowUp":
        e.preventDefault();
        focusPrevious(defaultOpts.ArrowUp);
        break;
    }
  };
  return {
    defaultArrows,
    focusPrevious,
    focusNext,
    focusFirst,
    focusLast
  };
};

const useSelectCallbacks = ({
  onChange,
  onAdd,
  onRemove,
  isMulti = false,
  value
}) => {
  const items = useRef(value);
  const handleChange = (val, event) => {
    var _a;
    onChange(val, event);
    if (!isMulti && !isNil(val)) {
      onAdd(val.value);
    } else if (!isNil(val) && val.length > items.current.length) {
      onAdd((_a = last(val)) == null ? void 0 : _a.value);
    } else {
      const removedItems = map(
        prop("value"),
        difference(
          isMulti ? items.current : [items.current],
          val
        )
      );
      onRemove(removedItems.length === 1 ? removedItems[0] : removedItems);
    }
    items.current = val;
  };
  return handleChange;
};

const isBetween = (point, min, max) => point >= min && point <= max;
const useOutsideRectClick = (ref, callback) => {
  const stateRef = useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state = stateRef.current;
  useEffect(() => {
    const handleMouseClick = (event) => {
      let clientX;
      let clientY;
      if (event instanceof MouseEvent) {
        clientX = event.clientX;
        clientY = event.clientY;
      } else if (event instanceof TouchEvent && event.changedTouches[0]) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
      }
      if (isNil(clientX) || isNil(clientY))
        return;
      if (isNil(ref == null ? void 0 : ref.current))
        return;
      const {
        top,
        right,
        left,
        bottom
      } = ref.current.getBoundingClientRect();
      const isInBound = isBetween(clientX, left, right) && isBetween(clientY, top, bottom);
      if (isInBound)
        return;
      callback(event);
    };
    const onPointerDown = () => {
      state.isPointerDown = true;
    };
    const onMouseUp = (event) => {
      if (state.ignoreEmulatedMouseEvents) {
        state.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state.isPointerDown) {
        state.isPointerDown = false;
        handleMouseClick(event);
      }
    };
    const onTouchEnd = (event) => {
      state.ignoreEmulatedMouseEvents = true;
      if (state.isPointerDown) {
        state.isPointerDown = false;
        handleMouseClick(event);
      }
    };
    document.addEventListener("mousedown", onPointerDown, true);
    document.addEventListener("mouseup", onMouseUp, true);
    document.addEventListener("touchstart", onPointerDown, true);
    document.addEventListener("touchend", onTouchEnd, true);
    return () => {
      document.removeEventListener("mousedown", onPointerDown, true);
      document.removeEventListener("mouseup", onMouseUp, true);
      document.removeEventListener("touchstart", onPointerDown, true);
      document.removeEventListener("touchend", onTouchEnd, true);
    };
  }, []);
};

const useScreenSize = () => {
  const screenSizes = useMediaQuery(["(min-width: 1280px)", "(min-width: 1024px)"]);
  if (screenSizes[0]) {
    return "lg";
  }
  if (screenSizes[1]) {
    return "md";
  }
  return "sm";
};

const useDidUpdateEffect = (effect, dependencies) => {
  const didMountRef = useRef(false);
  useEffect(() => {
    if (didMountRef.current) {
      effect();
    }
    didMountRef.current = true;
  }, dependencies);
};

const luminosity = (hexcolor) => {
  let color = hexcolor;
  if (color.slice(0, 1) === "#") {
    color = color.slice(1);
  }
  if (color.length === 3) {
    color = color.split("").map((hex) => hex + hex).join("");
  }
  const r = parseInt(color.substring(0, 2), 16);
  const g = parseInt(color.substring(2, 4), 16);
  const b = parseInt(color.substring(4, 6), 16);
  const brightness = (r * 299 + g * 587 + b * 114) / 1e3;
  return brightness;
};

const getContrastColor = (color) => {
  const colorTwo = useToken("colors", "text.default");
  const colorOne = useToken("colors", "text.inverted");
  const colorInHex = useToken("colors", color);
  const l1 = luminosity(colorOne);
  const l2 = luminosity(colorTwo);
  const threshold = (l1 + l2) / 2;
  const brightColor = l1 > l2 ? colorOne : colorTwo;
  const darkColor = l1 > l2 ? colorTwo : colorOne;
  return luminosity(colorInHex) >= threshold ? darkColor : brightColor;
};

const ring = {
  _focusVisible: {
    outline: "none",
    ring: "2px",
    ringColor: "border.wcag",
    ringOffset: "1px"
  }
};

const highlight = {
  px: "1",
  py: "0.5",
  rounded: "6",
  bg: "teal.100",
  fontWeight: "bold"
};

const getShades = (startShade, endShade) => {
  let start;
  let end;
  if (!endShade) {
    start = startShade;
    end = startShade;
  } else if (endShade > startShade) {
    start = startShade;
    end = endShade;
  } else {
    start = endShade;
    end = startShade;
  }
  return Object.keys(palette).reduce((colors, color) => {
    if (color === "mono")
      return colors;
    return colors.concat(
      Object.keys(palette[color]).filter(
        (value) => parseInt(value, 10) >= start && parseInt(value, 10) <= end
      ).map((shade) => palette[color][shade])
    );
  }, []);
};

const getInitials = (name) => {
  const [firstName, lastName] = name.toUpperCase().split(" ");
  return firstName && lastName ? `${firstName[0]}${lastName[0]}` : firstName[0];
};

function getFieldError(name, errors) {
  const nameWithoutRightBracket = replace(/]/g, "", name);
  const leftBracketAndDot = /[.[\]]/g;
  const fieldErrorPath = split(leftBracketAndDot, nameWithoutRightBracket);
  const fieldError = path(fieldErrorPath, errors);
  return fieldError;
}

var __defProp$2m = Object.defineProperty;
var __getOwnPropSymbols$2m = Object.getOwnPropertySymbols;
var __hasOwnProp$2m = Object.prototype.hasOwnProperty;
var __propIsEnum$2m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2m = (obj, key, value) => key in obj ? __defProp$2m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2m.call(b, prop))
      __defNormalProp$2m(a, prop, b[prop]);
  if (__getOwnPropSymbols$2m)
    for (var prop of __getOwnPropSymbols$2m(b)) {
      if (__propIsEnum$2m.call(b, prop))
        __defNormalProp$2m(a, prop, b[prop]);
    }
  return a;
};
const passPropsToChild = (child, styles) => isValidElement(child) ? cloneElement(child, __spreadValues$2m({}, styles)) : child;

var __defProp$2l = Object.defineProperty;
var __getOwnPropSymbols$2l = Object.getOwnPropertySymbols;
var __hasOwnProp$2l = Object.prototype.hasOwnProperty;
var __propIsEnum$2l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2l = (obj, key, value) => key in obj ? __defProp$2l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2l.call(b, prop))
      __defNormalProp$2l(a, prop, b[prop]);
  if (__getOwnPropSymbols$2l)
    for (var prop of __getOwnPropSymbols$2l(b)) {
      if (__propIsEnum$2l.call(b, prop))
        __defNormalProp$2l(a, prop, b[prop]);
    }
  return a;
};
const getChildrenWithProps = (children, styles, predicate = T) => {
  const childrenAsArr = Children.toArray(children);
  const childrenWithoutFocus = childrenAsArr.map((child, i) => predicate(child, i) ? passPropsToChild(child, __spreadValues$2l({}, styles)) : child);
  return childrenWithoutFocus;
};

const addAlpha = (color, alpha = 1) => {
  const colorInHex = useToken("colors", color);
  const limitAlpha = Math.min(Math.max(alpha, 0), 1);
  const opacity = Math.round(limitAlpha * 255);
  return `${colorInHex}${opacity.toString(16).toUpperCase()}`;
};

const createDebounceFunctionInstance = (delay) => {
  let timeout;
  return (fn) => (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn(...args);
    }, delay);
  };
};

const CustomTheme = createContext("webappTheme");
const useCurrentTheme = () => {
  const theme = useContext(CustomTheme);
  return theme;
};

const clamp = (minValue, maxValue, value) => Math.min(Math.max(value, minValue), maxValue);

const useResizeWidth = ({
  stationaryEdge = "left",
  minWidthPx = 0,
  maxWidthPx = Number.MAX_SAFE_INTEGER,
  defaultWidthPx
}) => {
  const [adjustableWidth, setAdjustableWidth] = useState(defaultWidthPx);
  const resizeProps = {
    onMouseDown: (e) => {
      e.preventDefault();
      const startX = e.clientX;
      const onMouseMove = (event) => {
        const newWidth = stationaryEdge === "left" ? adjustableWidth + (event.clientX - startX) : adjustableWidth - (event.clientX - startX);
        setAdjustableWidth(clamp(minWidthPx, maxWidthPx, newWidth));
      };
      const onMouseUp = () => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
  };
  return {
    adjustableWidth,
    setAdjustableWidth,
    resizeProps
  };
};

var __defProp$2k = Object.defineProperty;
var __defProps$w = Object.defineProperties;
var __getOwnPropDescs$w = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2k = Object.getOwnPropertySymbols;
var __hasOwnProp$2k = Object.prototype.hasOwnProperty;
var __propIsEnum$2k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2k = (obj, key, value) => key in obj ? __defProp$2k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2k.call(b, prop))
      __defNormalProp$2k(a, prop, b[prop]);
  if (__getOwnPropSymbols$2k)
    for (var prop of __getOwnPropSymbols$2k(b)) {
      if (__propIsEnum$2k.call(b, prop))
        __defNormalProp$2k(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$w = (a, b) => __defProps$w(a, __getOwnPropDescs$w(b));
const customSelectStyles = {
  container: (provided) => __spreadProps$w(__spreadValues$2k({}, provided), {
    width: "100%",
    color: "text.default"
  }),
  option: (provided, state) => __spreadProps$w(__spreadValues$2k({}, provided), {
    background: state.isFocused && "background.select.option-focus",
    _active: {
      background: "background.select.option-active"
    }
  }),
  valueContainer: (provided) => __spreadProps$w(__spreadValues$2k({}, provided), {
    paddingInlineStart: "padding-inline.select.default"
  }),
  downChevron: (provided) => __spreadProps$w(__spreadValues$2k({}, provided), {
    color: "icon.select.default"
  }),
  placeholder: (provided) => __spreadProps$w(__spreadValues$2k({}, provided), {
    color: "text.select.placeholder"
  }),
  multiValue: (provided, state) => {
    var _a;
    const background = state.data.isFixed ? "background.select.option-disabled" : (_a = state.data.color) != null ? _a : provided.bgColor;
    return __spreadProps$w(__spreadValues$2k({}, provided), {
      bgColor: background,
      color: getContrastColor(background)
    });
  },
  menuList: (provided) => __spreadProps$w(__spreadValues$2k({}, provided), {
    bgColor: "background.default"
  })
};

var __defProp$2j = Object.defineProperty;
var __defProps$v = Object.defineProperties;
var __getOwnPropDescs$v = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2j = Object.getOwnPropertySymbols;
var __hasOwnProp$2j = Object.prototype.hasOwnProperty;
var __propIsEnum$2j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2j = (obj, key, value) => key in obj ? __defProp$2j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2j.call(b, prop))
      __defNormalProp$2j(a, prop, b[prop]);
  if (__getOwnPropSymbols$2j)
    for (var prop of __getOwnPropSymbols$2j(b)) {
      if (__propIsEnum$2j.call(b, prop))
        __defNormalProp$2j(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$v = (a, b) => __defProps$v(a, __getOwnPropDescs$v(b));
const tagsInputStyles = (isFocused, borderColor) => __spreadProps$v(__spreadValues$2j({}, customSelectStyles), {
  container: (provided) => __spreadProps$v(__spreadValues$2j({}, provided), {
    w: "full",
    height: "100%",
    resize: "vertical",
    overflow: "auto",
    minHeight: "20",
    borderColor: "select.default",
    borderRadius: "select.default",
    transitionDuration: "normal",
    transitionProperty: "box-shadow",
    color: "text.default",
    boxShadow: isFocused ? `0 0 0 1px ${borderColor}` : "none"
  }),
  control: (provided) => __spreadProps$v(__spreadValues$2j({}, provided), {
    minHeight: "20",
    height: "100%",
    alignItems: "start"
  }),
  valueContainer: (provided) => __spreadProps$v(__spreadValues$2j({}, provided), {
    paddingInlineStart: "padding-inline.select.default",
    overflowY: "auto",
    maxH: "100%"
  })
});

var __defProp$2i = Object.defineProperty;
var __defProps$u = Object.defineProperties;
var __getOwnPropDescs$u = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2i = Object.getOwnPropertySymbols;
var __hasOwnProp$2i = Object.prototype.hasOwnProperty;
var __propIsEnum$2i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2i = (obj, key, value) => key in obj ? __defProp$2i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2i.call(b, prop))
      __defNormalProp$2i(a, prop, b[prop]);
  if (__getOwnPropSymbols$2i)
    for (var prop of __getOwnPropSymbols$2i(b)) {
      if (__propIsEnum$2i.call(b, prop))
        __defNormalProp$2i(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$u = (a, b) => __defProps$u(a, __getOwnPropDescs$u(b));
var __objRest$1N = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2i)
    for (var prop of __getOwnPropSymbols$2i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function TagsInput(_a) {
  var _b = _a, {
    options,
    onChange = identity,
    isLoading,
    loadingList = () => null,
    "data-testid": testId,
    value = []
  } = _b, rest = __objRest$1N(_b, [
    "options",
    "onChange",
    "isLoading",
    "loadingList",
    "data-testid",
    "value"
  ]);
  const [borderColor] = useToken$1("border.select", ["focus"]);
  const [menuIsOpen, setMenuIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [selectedOptions, setSelectedOptions] = useState(value);
  const [isFocused, setIsFocused] = useState(false);
  useEffect(() => {
    setSelectedOptions(value);
  }, [value.length]);
  const CustomSelect = CreatableSelect;
  const handleChange = (values, actionMeta) => {
    setSelectedOptions(values);
    onChange(values, actionMeta);
  };
  const isValidNewOption = (input, availableOptions) => {
    const optionAlreadyExists = any(
      (option) => option.value === input,
      availableOptions
    );
    return !isEmpty(input) && !optionAlreadyExists;
  };
  const addNewOption = (newOption) => {
    onChange(selectedOptions, { action: "select-option", option: newOption });
    setSelectedOptions(append(newOption));
  };
  const isInputChangeValid = (newInput, event) => isValidNewOption(newInput, selectedOptions) && newInput !== "" && newInput !== "," && newInput.endsWith(",") && event.action !== "input-blur";
  const clearInput = () => {
    setInputValue("");
  };
  const handleInputChange = (newInput, event) => {
    setInputValue(newInput);
    if (!isInputChangeValid(newInput, event))
      return;
    const newOption = {
      value: init(newInput),
      label: init(newInput).slice(0, -1)
    };
    addNewOption(newOption);
    clearInput();
  };
  const handleKeyDown = (event) => {
    if (!isValidNewOption(inputValue, selectedOptions) && !isEmpty(inputValue) && event.key !== " ") {
      clearInput();
      event.preventDefault();
      return;
    }
    if ((event.key === "Enter" || event.key === "Tab") && !isEmpty(inputValue)) {
      const newOption = { value: inputValue, label: inputValue };
      addNewOption(newOption);
      clearInput();
      event.preventDefault();
    }
  };
  const handleFocus = () => {
    setIsFocused(true);
    if (options && options.length > 0) {
      setMenuIsOpen(true);
    }
  };
  return /* @__PURE__ */ React.createElement(Box, { w: "full", "data-testid": testId }, /* @__PURE__ */ React.createElement(
    CustomSelect,
    __spreadValues$2i(__spreadProps$u(__spreadValues$2i({
      isMulti: true,
      menuPortalTarget: document.body,
      placeholder: "Type something and press Enter or comma...",
      options,
      useBasicStyles: true,
      closeMenuOnSelect: false,
      hideSelectedOptions: false,
      isClearable: false,
      onChange: handleChange,
      onInputChange: handleInputChange,
      onKeyDown: handleKeyDown,
      inputValue,
      selectedOptionStyle: "check",
      chakraStyles: tagsInputStyles(isFocused, borderColor),
      onFocus: handleFocus,
      isValidNewOption,
      onBlur: () => {
        setMenuIsOpen(false);
        setIsFocused(false);
      },
      menuIsOpen,
      isLoading
    }, isLoading && { components: { MenuList: loadingList } }), {
      value: selectedOptions,
      components: {
        DropdownIndicator: () => null
      },
      formatCreateLabel: (textInputValue) => `Add tag "${textInputValue}"`
    }), rest)
  ));
}

var __defProp$2h = Object.defineProperty;
var __getOwnPropSymbols$2h = Object.getOwnPropertySymbols;
var __hasOwnProp$2h = Object.prototype.hasOwnProperty;
var __propIsEnum$2h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2h = (obj, key, value) => key in obj ? __defProp$2h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2h.call(b, prop))
      __defNormalProp$2h(a, prop, b[prop]);
  if (__getOwnPropSymbols$2h)
    for (var prop of __getOwnPropSymbols$2h(b)) {
      if (__propIsEnum$2h.call(b, prop))
        __defNormalProp$2h(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1M = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2h)
    for (var prop of __getOwnPropSymbols$2h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const OrganizationLogo = (_a) => {
  var _b = _a, {
    name,
    image,
    variant = "square"
  } = _b, rest = __objRest$1M(_b, [
    "name",
    "image",
    "variant"
  ]);
  const getInitials = (orgName) => orgName[0].toUpperCase();
  const {
    container,
    text
  } = useMultiStyleConfig("Avatar", __spreadValues$2h({ variant, image }, rest));
  return /* @__PURE__ */ React.createElement(
    chakra.div,
    __spreadValues$2h({
      __css: container,
      "data-testid": "organization-logo-test-id"
    }, rest),
    image ? /* @__PURE__ */ React.createElement(
      chakra.img,
      {
        alt: name,
        src: image
      }
    ) : /* @__PURE__ */ React.createElement(chakra.span, { __css: text }, getInitials(name))
  );
};

var __defProp$2g = Object.defineProperty;
var __getOwnPropSymbols$2g = Object.getOwnPropertySymbols;
var __hasOwnProp$2g = Object.prototype.hasOwnProperty;
var __propIsEnum$2g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2g = (obj, key, value) => key in obj ? __defProp$2g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2g.call(b, prop))
      __defNormalProp$2g(a, prop, b[prop]);
  if (__getOwnPropSymbols$2g)
    for (var prop of __getOwnPropSymbols$2g(b)) {
      if (__propIsEnum$2g.call(b, prop))
        __defNormalProp$2g(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1L = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2g.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2g)
    for (var prop of __getOwnPropSymbols$2g(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2g.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Alert$1 = (_a) => {
  var _b = _a, {
    variant = "success",
    children
  } = _b, rest = __objRest$1L(_b, [
    "variant",
    "children"
  ]);
  return /* @__PURE__ */ React.createElement(Alert$2, __spreadValues$2g({ variant }, rest), children);
};

var __defProp$2f = Object.defineProperty;
var __getOwnPropSymbols$2f = Object.getOwnPropertySymbols;
var __hasOwnProp$2f = Object.prototype.hasOwnProperty;
var __propIsEnum$2f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2f = (obj, key, value) => key in obj ? __defProp$2f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2f.call(b, prop))
      __defNormalProp$2f(a, prop, b[prop]);
  if (__getOwnPropSymbols$2f)
    for (var prop of __getOwnPropSymbols$2f(b)) {
      if (__propIsEnum$2f.call(b, prop))
        __defNormalProp$2f(a, prop, b[prop]);
    }
  return a;
};
const AspectRatio = (props) => /* @__PURE__ */ React.createElement(AspectRatio$1, __spreadValues$2f({}, props));

var __defProp$2e = Object.defineProperty;
var __getOwnPropSymbols$2e = Object.getOwnPropertySymbols;
var __hasOwnProp$2e = Object.prototype.hasOwnProperty;
var __propIsEnum$2e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2e = (obj, key, value) => key in obj ? __defProp$2e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2e.call(b, prop))
      __defNormalProp$2e(a, prop, b[prop]);
  if (__getOwnPropSymbols$2e)
    for (var prop of __getOwnPropSymbols$2e(b)) {
      if (__propIsEnum$2e.call(b, prop))
        __defNormalProp$2e(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1K = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2e.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2e)
    for (var prop of __getOwnPropSymbols$2e(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2e.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Icon$1 = forwardRef((_a, ref) => {
  var _b = _a, {
    as: As,
    size,
    color,
    boxSize
  } = _b, rest = __objRest$1K(_b, [
    "as",
    "size",
    "color",
    "boxSize"
  ]);
  const CustomIcon = As != null ? As : () => /* @__PURE__ */ React.createElement(Icon$2, null);
  const styles = useStyleConfig("Icon", { size, color, boxSize });
  return /* @__PURE__ */ React.createElement(
    Icon$2,
    __spreadValues$2e({
      ref,
      sx: styles
    }, rest),
    /* @__PURE__ */ React.createElement(CustomIcon, null)
  );
});

const AvatarBadge = ({
  notificationCount = 0
}) => {
  const { badge } = useMultiStyleConfig("Avatar");
  return /* @__PURE__ */ React.createElement(chakra.span, { sx: badge }, notificationCount > 999 ? "999+" : notificationCount);
};

var __defProp$2d = Object.defineProperty;
var __getOwnPropSymbols$2d = Object.getOwnPropertySymbols;
var __hasOwnProp$2d = Object.prototype.hasOwnProperty;
var __propIsEnum$2d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2d = (obj, key, value) => key in obj ? __defProp$2d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2d.call(b, prop))
      __defNormalProp$2d(a, prop, b[prop]);
  if (__getOwnPropSymbols$2d)
    for (var prop of __getOwnPropSymbols$2d(b)) {
      if (__propIsEnum$2d.call(b, prop))
        __defNormalProp$2d(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1J = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2d)
    for (var prop of __getOwnPropSymbols$2d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Avatar$1 = (_a) => {
  var _b = _a, {
    variant = "square",
    notificationCount = 0,
    name,
    image,
    size
  } = _b, rest = __objRest$1J(_b, [
    "variant",
    "notificationCount",
    "name",
    "image",
    "size"
  ]);
  const { container, text, userImage, icon } = useMultiStyleConfig("Avatar", {
    variant,
    image,
    size,
    name
  });
  return /* @__PURE__ */ React.createElement(Box, __spreadValues$2d({ __css: container, "data-testid": "avatar-test-id" }, rest), image ? /* @__PURE__ */ React.createElement(
    chakra.img,
    {
      alt: name,
      src: image,
      sx: userImage
    }
  ) : name ? /* @__PURE__ */ React.createElement(chakra.span, { sx: text }, getInitials(name)) : /* @__PURE__ */ React.createElement(
    Icon$1,
    {
      as: variant === "square" ? UserSquareDuo : BusinessContactDuo,
      sx: icon,
      "aria-label": "user-avatar"
    }
  ), notificationCount > 0 && /* @__PURE__ */ React.createElement(AvatarBadge, { notificationCount }));
};

var __defProp$2c = Object.defineProperty;
var __getOwnPropSymbols$2c = Object.getOwnPropertySymbols;
var __hasOwnProp$2c = Object.prototype.hasOwnProperty;
var __propIsEnum$2c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2c = (obj, key, value) => key in obj ? __defProp$2c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2c.call(b, prop))
      __defNormalProp$2c(a, prop, b[prop]);
  if (__getOwnPropSymbols$2c)
    for (var prop of __getOwnPropSymbols$2c(b)) {
      if (__propIsEnum$2c.call(b, prop))
        __defNormalProp$2c(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1I = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2c)
    for (var prop of __getOwnPropSymbols$2c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H1$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1I(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H1", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$2c({
      as: "h1",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$2b = Object.defineProperty;
var __getOwnPropSymbols$2b = Object.getOwnPropertySymbols;
var __hasOwnProp$2b = Object.prototype.hasOwnProperty;
var __propIsEnum$2b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2b = (obj, key, value) => key in obj ? __defProp$2b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2b.call(b, prop))
      __defNormalProp$2b(a, prop, b[prop]);
  if (__getOwnPropSymbols$2b)
    for (var prop of __getOwnPropSymbols$2b(b)) {
      if (__propIsEnum$2b.call(b, prop))
        __defNormalProp$2b(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1H = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2b.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2b)
    for (var prop of __getOwnPropSymbols$2b(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2b.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H2$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1H(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H2", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$2b({
      as: "h2",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$2a = Object.defineProperty;
var __getOwnPropSymbols$2a = Object.getOwnPropertySymbols;
var __hasOwnProp$2a = Object.prototype.hasOwnProperty;
var __propIsEnum$2a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2a = (obj, key, value) => key in obj ? __defProp$2a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2a.call(b, prop))
      __defNormalProp$2a(a, prop, b[prop]);
  if (__getOwnPropSymbols$2a)
    for (var prop of __getOwnPropSymbols$2a(b)) {
      if (__propIsEnum$2a.call(b, prop))
        __defNormalProp$2a(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1G = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2a.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2a)
    for (var prop of __getOwnPropSymbols$2a(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2a.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H3$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1G(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H3", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$2a({
      as: "h3",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$29 = Object.defineProperty;
var __getOwnPropSymbols$29 = Object.getOwnPropertySymbols;
var __hasOwnProp$29 = Object.prototype.hasOwnProperty;
var __propIsEnum$29 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$29 = (obj, key, value) => key in obj ? __defProp$29(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$29 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$29.call(b, prop))
      __defNormalProp$29(a, prop, b[prop]);
  if (__getOwnPropSymbols$29)
    for (var prop of __getOwnPropSymbols$29(b)) {
      if (__propIsEnum$29.call(b, prop))
        __defNormalProp$29(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1F = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$29.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$29)
    for (var prop of __getOwnPropSymbols$29(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$29.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H4$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1F(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H4", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$29({
      as: "h4",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$28 = Object.defineProperty;
var __getOwnPropSymbols$28 = Object.getOwnPropertySymbols;
var __hasOwnProp$28 = Object.prototype.hasOwnProperty;
var __propIsEnum$28 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$28 = (obj, key, value) => key in obj ? __defProp$28(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$28 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$28.call(b, prop))
      __defNormalProp$28(a, prop, b[prop]);
  if (__getOwnPropSymbols$28)
    for (var prop of __getOwnPropSymbols$28(b)) {
      if (__propIsEnum$28.call(b, prop))
        __defNormalProp$28(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1E = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$28.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$28)
    for (var prop of __getOwnPropSymbols$28(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$28.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H5$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1E(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H5", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$28({
      as: "h5",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$27 = Object.defineProperty;
var __getOwnPropSymbols$27 = Object.getOwnPropertySymbols;
var __hasOwnProp$27 = Object.prototype.hasOwnProperty;
var __propIsEnum$27 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$27 = (obj, key, value) => key in obj ? __defProp$27(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$27 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$27.call(b, prop))
      __defNormalProp$27(a, prop, b[prop]);
  if (__getOwnPropSymbols$27)
    for (var prop of __getOwnPropSymbols$27(b)) {
      if (__propIsEnum$27.call(b, prop))
        __defNormalProp$27(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1D = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$27.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$27)
    for (var prop of __getOwnPropSymbols$27(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$27.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const H6$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1D(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("H6", { sx });
  return /* @__PURE__ */ React.createElement(
    Heading,
    __spreadValues$27({
      as: "h6",
      sx: styles,
      ref
    }, rest),
    children
  );
});

var __defProp$26 = Object.defineProperty;
var __getOwnPropSymbols$26 = Object.getOwnPropertySymbols;
var __hasOwnProp$26 = Object.prototype.hasOwnProperty;
var __propIsEnum$26 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$26 = (obj, key, value) => key in obj ? __defProp$26(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$26 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$26.call(b, prop))
      __defNormalProp$26(a, prop, b[prop]);
  if (__getOwnPropSymbols$26)
    for (var prop of __getOwnPropSymbols$26(b)) {
      if (__propIsEnum$26.call(b, prop))
        __defNormalProp$26(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1C = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$26.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$26)
    for (var prop of __getOwnPropSymbols$26(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$26.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const P$1 = (_a) => {
  var _b = _a, {
    children,
    variant = "16",
    sx = {}
  } = _b, rest = __objRest$1C(_b, [
    "children",
    "variant",
    "sx"
  ]);
  const styles = useStyleConfig("P", { variant, sx });
  return /* @__PURE__ */ React.createElement(
    Text,
    __spreadValues$26({
      variant,
      sx: styles
    }, rest),
    children
  );
};

var __defProp$25 = Object.defineProperty;
var __getOwnPropSymbols$25 = Object.getOwnPropertySymbols;
var __hasOwnProp$25 = Object.prototype.hasOwnProperty;
var __propIsEnum$25 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$25 = (obj, key, value) => key in obj ? __defProp$25(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$25 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$25.call(b, prop))
      __defNormalProp$25(a, prop, b[prop]);
  if (__getOwnPropSymbols$25)
    for (var prop of __getOwnPropSymbols$25(b)) {
      if (__propIsEnum$25.call(b, prop))
        __defNormalProp$25(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1B = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$25.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$25)
    for (var prop of __getOwnPropSymbols$25(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$25.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Blockquote$1 = (_a) => {
  var _b = _a, { children, sx = {} } = _b, rest = __objRest$1B(_b, ["children", "sx"]);
  const styles = useStyleConfig("Blockquote", { sx });
  return /* @__PURE__ */ React.createElement(Text, __spreadValues$25({ as: "span", sx: styles }, rest), children);
};

var __defProp$24 = Object.defineProperty;
var __getOwnPropSymbols$24 = Object.getOwnPropertySymbols;
var __hasOwnProp$24 = Object.prototype.hasOwnProperty;
var __propIsEnum$24 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$24 = (obj, key, value) => key in obj ? __defProp$24(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$24 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$24.call(b, prop))
      __defNormalProp$24(a, prop, b[prop]);
  if (__getOwnPropSymbols$24)
    for (var prop of __getOwnPropSymbols$24(b)) {
      if (__propIsEnum$24.call(b, prop))
        __defNormalProp$24(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1A = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$24.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$24)
    for (var prop of __getOwnPropSymbols$24(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$24.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Capitalized$1 = (_a) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1A(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("Capitalized", { sx });
  return /* @__PURE__ */ React.createElement(
    Text,
    __spreadValues$24({
      as: "span",
      sx: styles
    }, rest),
    children
  );
};

var __defProp$23 = Object.defineProperty;
var __getOwnPropSymbols$23 = Object.getOwnPropertySymbols;
var __hasOwnProp$23 = Object.prototype.hasOwnProperty;
var __propIsEnum$23 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$23 = (obj, key, value) => key in obj ? __defProp$23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$23 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$23.call(b, prop))
      __defNormalProp$23(a, prop, b[prop]);
  if (__getOwnPropSymbols$23)
    for (var prop of __getOwnPropSymbols$23(b)) {
      if (__propIsEnum$23.call(b, prop))
        __defNormalProp$23(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1z = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$23.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$23)
    for (var prop of __getOwnPropSymbols$23(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$23.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Lead$1 = (_a) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1z(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("Lead", { sx });
  return /* @__PURE__ */ React.createElement(
    Text,
    __spreadValues$23({
      as: "span",
      sx: styles
    }, rest),
    children
  );
};

var __defProp$22 = Object.defineProperty;
var __getOwnPropSymbols$22 = Object.getOwnPropertySymbols;
var __hasOwnProp$22 = Object.prototype.hasOwnProperty;
var __propIsEnum$22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$22 = (obj, key, value) => key in obj ? __defProp$22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$22 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$22.call(b, prop))
      __defNormalProp$22(a, prop, b[prop]);
  if (__getOwnPropSymbols$22)
    for (var prop of __getOwnPropSymbols$22(b)) {
      if (__propIsEnum$22.call(b, prop))
        __defNormalProp$22(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1y = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$22.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$22)
    for (var prop of __getOwnPropSymbols$22(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$22.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Small$1 = (_a) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1y(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("Small", { sx });
  return /* @__PURE__ */ React.createElement(
    Text,
    __spreadValues$22({
      as: "small",
      sx: styles
    }, rest),
    children
  );
};

var __defProp$21 = Object.defineProperty;
var __getOwnPropSymbols$21 = Object.getOwnPropertySymbols;
var __hasOwnProp$21 = Object.prototype.hasOwnProperty;
var __propIsEnum$21 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$21 = (obj, key, value) => key in obj ? __defProp$21(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$21 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$21.call(b, prop))
      __defNormalProp$21(a, prop, b[prop]);
  if (__getOwnPropSymbols$21)
    for (var prop of __getOwnPropSymbols$21(b)) {
      if (__propIsEnum$21.call(b, prop))
        __defNormalProp$21(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1x = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$21.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$21)
    for (var prop of __getOwnPropSymbols$21(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$21.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Tiny$1 = (_a) => {
  var _b = _a, {
    children,
    sx = {}
  } = _b, rest = __objRest$1x(_b, [
    "children",
    "sx"
  ]);
  const styles = useStyleConfig("Tiny", { sx });
  return /* @__PURE__ */ React.createElement(
    Text,
    __spreadValues$21({
      as: "span",
      sx: styles
    }, rest),
    children
  );
};

var __defProp$20 = Object.defineProperty;
var __getOwnPropSymbols$20 = Object.getOwnPropertySymbols;
var __hasOwnProp$20 = Object.prototype.hasOwnProperty;
var __propIsEnum$20 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$20 = (obj, key, value) => key in obj ? __defProp$20(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$20 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$20.call(b, prop))
      __defNormalProp$20(a, prop, b[prop]);
  if (__getOwnPropSymbols$20)
    for (var prop of __getOwnPropSymbols$20(b)) {
      if (__propIsEnum$20.call(b, prop))
        __defNormalProp$20(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1w = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$20.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$20)
    for (var prop of __getOwnPropSymbols$20(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$20.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Label$1 = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    size = "sm",
    sx = {}
  } = _b, rest = __objRest$1w(_b, [
    "children",
    "size",
    "sx"
  ]);
  const styles = useStyleConfig("Label", { sx, size });
  return /* @__PURE__ */ React.createElement(
    FormLabel$1,
    __spreadValues$20({
      sx: styles,
      requiredIndicator: /* @__PURE__ */ React.createElement(VisuallyHidden, null),
      ref
    }, rest),
    children
  );
});

var __defProp$1$ = Object.defineProperty;
var __getOwnPropSymbols$1$ = Object.getOwnPropertySymbols;
var __hasOwnProp$1$ = Object.prototype.hasOwnProperty;
var __propIsEnum$1$ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1$ = (obj, key, value) => key in obj ? __defProp$1$(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1$ = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1$.call(b, prop))
      __defNormalProp$1$(a, prop, b[prop]);
  if (__getOwnPropSymbols$1$)
    for (var prop of __getOwnPropSymbols$1$(b)) {
      if (__propIsEnum$1$.call(b, prop))
        __defNormalProp$1$(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1v = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1$.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1$)
    for (var prop of __getOwnPropSymbols$1$(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1$.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const NumVal$1 = forwardRef$1(
  (_a, ref) => {
    var _b = _a, { children, size = "sm", sx = {} } = _b, rest = __objRest$1v(_b, ["children", "size", "sx"]);
    const styles = useStyleConfig("NumVal", { sx, size });
    return /* @__PURE__ */ React.createElement(
      Text,
      __spreadValues$1$({
        as: "span",
        sx: styles,
        ref
      }, rest),
      children
    );
  }
);

const positiveOrZero = ifElse(gt(0), always(0), identity);
const EMPTY_RECT = {
  clientWidht: 0,
  clientHeight: 0
};
const EMPTY_WINDOW = {
  innerWidth: 0,
  innerHeight: 0
};
const OverflowGroup = ({
  children,
  max: initMax = 0,
  childrenProps,
  onChange = identity,
  rect
}) => {
  const [max, setMax] = useState(typeof rect === "undefined" ? initMax : 0);
  const [windowState, setWindowState] = useState(EMPTY_WINDOW);
  const isLocked = useRef(false);
  const nbrChildren = Children.count(children);
  const updateMax = () => {
    if (!rect)
      return;
    if (rect.scrollHeight <= rect.clientHeight && rect.scrollWidth <= rect.clientWidth && max < nbrChildren && !isLocked.current && max < initMax) {
      setMax(inc);
    }
    if (rect.scrollHeight > rect.clientHeight || rect.scrollWidth > rect.clientWidth) {
      setMax(dec);
      isLocked.current = true;
    }
  };
  const rectDependency = defaultTo(EMPTY_RECT, rect);
  useEffect(updateMax, [
    rectDependency.clientWidth,
    rectDependency.clientHeight,
    nbrChildren,
    max,
    windowState.innerHeight,
    windowState.innerHeight,
    initMax
  ]);
  useEffect(() => {
    isLocked.current = false;
  }, [rectDependency.clientHeight, rectDependency.clientWidth]);
  const handleResize = () => {
    setTimeout(() => {
      isLocked.current = false;
      setWindowState({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      });
    }, 200);
  };
  useEffect(() => {
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  useEffect(() => {
    const nbrRemainingChildren = positiveOrZero(nbrChildren - max);
    onChange(nbrRemainingChildren);
  }, [max, nbrChildren]);
  const shownChildren = take(
    max,
    getChildrenWithProps(children, defaultTo({}, childrenProps))
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, shownChildren);
};

const useOverflowGroup = () => {
  const [rect, setRect] = useState(null);
  const containerRef = (node) => {
    if (node) {
      setRect(node);
    }
  };
  return { rect, containerRef };
};

var __defProp$1_ = Object.defineProperty;
var __getOwnPropSymbols$1_ = Object.getOwnPropertySymbols;
var __hasOwnProp$1_ = Object.prototype.hasOwnProperty;
var __propIsEnum$1_ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1_ = (obj, key, value) => key in obj ? __defProp$1_(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1_ = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1_.call(b, prop))
      __defNormalProp$1_(a, prop, b[prop]);
  if (__getOwnPropSymbols$1_)
    for (var prop of __getOwnPropSymbols$1_(b)) {
      if (__propIsEnum$1_.call(b, prop))
        __defNormalProp$1_(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1u = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1_.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1_)
    for (var prop of __getOwnPropSymbols$1_(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1_.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const AvatarGroup = (_a) => {
  var _b = _a, {
    children,
    max = Infinity,
    spacing = "-4"
  } = _b, rest = __objRest$1u(_b, [
    "children",
    "max",
    "spacing"
  ]);
  const [nbrRemainingAvatars, setNbrRemainingAvatars] = useState(0);
  return /* @__PURE__ */ React.createElement(HStack, __spreadValues$1_({ bgColor: "background.default" }, rest), /* @__PURE__ */ React.createElement(HStack, { spacing }, /* @__PURE__ */ React.createElement(OverflowGroup, { max, onChange: setNbrRemainingAvatars }, children)), nbrRemainingAvatars > 0 && /* @__PURE__ */ React.createElement(Small$1, { sx: { color: "blue.500" } }, "+", nbrRemainingAvatars));
};

var __defProp$1Z = Object.defineProperty;
var __getOwnPropSymbols$1Z = Object.getOwnPropertySymbols;
var __hasOwnProp$1Z = Object.prototype.hasOwnProperty;
var __propIsEnum$1Z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1Z = (obj, key, value) => key in obj ? __defProp$1Z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1Z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1Z.call(b, prop))
      __defNormalProp$1Z(a, prop, b[prop]);
  if (__getOwnPropSymbols$1Z)
    for (var prop of __getOwnPropSymbols$1Z(b)) {
      if (__propIsEnum$1Z.call(b, prop))
        __defNormalProp$1Z(a, prop, b[prop]);
    }
  return a;
};
const Badge$1 = forwardRef$1((props, ref) => /* @__PURE__ */ React.createElement(Badge$2, __spreadValues$1Z({ ref }, props)));

var __defProp$1Y = Object.defineProperty;
var __getOwnPropSymbols$1Y = Object.getOwnPropertySymbols;
var __hasOwnProp$1Y = Object.prototype.hasOwnProperty;
var __propIsEnum$1Y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1Y = (obj, key, value) => key in obj ? __defProp$1Y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1Y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1Y.call(b, prop))
      __defNormalProp$1Y(a, prop, b[prop]);
  if (__getOwnPropSymbols$1Y)
    for (var prop of __getOwnPropSymbols$1Y(b)) {
      if (__propIsEnum$1Y.call(b, prop))
        __defNormalProp$1Y(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1t = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1Y.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1Y)
    for (var prop of __getOwnPropSymbols$1Y(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1Y.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Blinker$1 = (_a) => {
  var _b = _a, {
    color = "",
    size,
    isBlinking = true
  } = _b, rest = __objRest$1t(_b, [
    "color",
    "size",
    "isBlinking"
  ]);
  const styles = useStyleConfig("Blinker", { color, size, isBlinking });
  return /* @__PURE__ */ React.createElement(Box, __spreadValues$1Y({ sx: styles, "data-testid": "blinker-test-id" }, rest));
};

var __defProp$1X = Object.defineProperty;
var __getOwnPropSymbols$1X = Object.getOwnPropertySymbols;
var __hasOwnProp$1X = Object.prototype.hasOwnProperty;
var __propIsEnum$1X = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1X = (obj, key, value) => key in obj ? __defProp$1X(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1X = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1X.call(b, prop))
      __defNormalProp$1X(a, prop, b[prop]);
  if (__getOwnPropSymbols$1X)
    for (var prop of __getOwnPropSymbols$1X(b)) {
      if (__propIsEnum$1X.call(b, prop))
        __defNormalProp$1X(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1s = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1X.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1X)
    for (var prop of __getOwnPropSymbols$1X(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1X.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Spinner$1 = (_a) => {
  var rest = __objRest$1s(_a, []);
  return /* @__PURE__ */ React.createElement(Spinner$2, __spreadValues$1X({}, rest));
};

var __defProp$1W = Object.defineProperty;
var __getOwnPropSymbols$1W = Object.getOwnPropertySymbols;
var __hasOwnProp$1W = Object.prototype.hasOwnProperty;
var __propIsEnum$1W = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1W = (obj, key, value) => key in obj ? __defProp$1W(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1W = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1W.call(b, prop))
      __defNormalProp$1W(a, prop, b[prop]);
  if (__getOwnPropSymbols$1W)
    for (var prop of __getOwnPropSymbols$1W(b)) {
      if (__propIsEnum$1W.call(b, prop))
        __defNormalProp$1W(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1r = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1W.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1W)
    for (var prop of __getOwnPropSymbols$1W(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1W.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SpinnerSizeMap = {
  xs: "xs",
  sm: "sm",
  md: "sm",
  lg: "md"
};
const Button$1 = forwardRef$1(
  (_a, ref) => {
    var _b = _a, { variant = "default", children, size = "md" } = _b, rest = __objRest$1r(_b, ["variant", "children", "size"]);
    return /* @__PURE__ */ React.createElement(
      Button$2,
      __spreadValues$1W({
        variant,
        ref,
        size,
        spinner: /* @__PURE__ */ React.createElement(
          Spinner$1,
          {
            size: SpinnerSizeMap[size]
          }
        )
      }, rest),
      children
    );
  }
);

var __defProp$1V = Object.defineProperty;
var __getOwnPropSymbols$1V = Object.getOwnPropertySymbols;
var __hasOwnProp$1V = Object.prototype.hasOwnProperty;
var __propIsEnum$1V = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1V = (obj, key, value) => key in obj ? __defProp$1V(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1V = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1V.call(b, prop))
      __defNormalProp$1V(a, prop, b[prop]);
  if (__getOwnPropSymbols$1V)
    for (var prop of __getOwnPropSymbols$1V(b)) {
      if (__propIsEnum$1V.call(b, prop))
        __defNormalProp$1V(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1q = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1V.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1V)
    for (var prop of __getOwnPropSymbols$1V(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1V.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Checkbox$1 = (_a) => {
  var _b = _a, {
    value,
    onChange,
    name,
    size = "md",
    variant = "default"
  } = _b, rest = __objRest$1q(_b, [
    "value",
    "onChange",
    "name",
    "size",
    "variant"
  ]);
  return /* @__PURE__ */ React.createElement(
    Checkbox$2,
    __spreadValues$1V({
      size,
      id: name,
      onChange,
      isChecked: value,
      variant
    }, rest)
  );
};

const shouldTrim = (value) => is(Array, value) ? values : identity;
const trimFormValues = (obj) => {
  const newObj = obj;
  forEach((property) => {
    const value = obj[property];
    if (is(Object, value)) {
      const format = shouldTrim(value);
      newObj[property] = format(trimFormValues(value));
    }
    if (is(String, value)) {
      newObj[property] = trim(value);
    }
  }, keys(obj));
  return newObj;
};

var __defProp$1U = Object.defineProperty;
var __getOwnPropSymbols$1U = Object.getOwnPropertySymbols;
var __hasOwnProp$1U = Object.prototype.hasOwnProperty;
var __propIsEnum$1U = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1U = (obj, key, value) => key in obj ? __defProp$1U(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1U = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1U.call(b, prop))
      __defNormalProp$1U(a, prop, b[prop]);
  if (__getOwnPropSymbols$1U)
    for (var prop of __getOwnPropSymbols$1U(b)) {
      if (__propIsEnum$1U.call(b, prop))
        __defNormalProp$1U(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1p = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1U.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1U)
    for (var prop of __getOwnPropSymbols$1U(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1U.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Form = forwardRef$1((_a, ref) => {
  var _b = _a, {
    initialValues,
    onSubmit,
    children,
    validate,
    formSettings = { mode: "onChange" },
    methods = void 0,
    enableReinitialize = false,
    shouldTrim = true,
    innerFormStyle = {},
    joiSchema
  } = _b, rest = __objRest$1p(_b, [
    "initialValues",
    "onSubmit",
    "children",
    "validate",
    "formSettings",
    "methods",
    "enableReinitialize",
    "shouldTrim",
    "innerFormStyle",
    "joiSchema"
  ]);
  const customResolver = (values, _context, _options) => ({
    values,
    errors: validate(values)
  });
  const getResolver = () => {
    if (validate)
      return customResolver;
    if (joiSchema)
      return joiResolver(joiSchema);
    return void 0;
  };
  const newMethods = methods || useForm(__spreadValues$1U({
    defaultValues: initialValues,
    resolver: getResolver()
  }, formSettings));
  useImperativeHandle(ref, always(newMethods), []);
  if (enableReinitialize) {
    const initalValuesImage = useRef({});
    useEffect(() => {
      if (!equals(initalValuesImage.current, initialValues)) {
        newMethods == null ? void 0 : newMethods.reset(initialValues);
        initalValuesImage.current = initialValues;
      }
    }, [initialValues]);
  }
  const formatValues = (values) => {
    if (!shouldTrim) {
      return values;
    }
    return trimFormValues(values);
  };
  const handleSubmit = newMethods.formState.isValid ? newMethods.handleSubmit(
    (values) => onSubmit(formatValues(values), newMethods)
  ) : (e) => {
    newMethods.trigger();
    e.preventDefault();
  };
  return /* @__PURE__ */ React.createElement(FormProvider, __spreadValues$1U(__spreadValues$1U({}, newMethods), rest), /* @__PURE__ */ React.createElement("form", { style: __spreadValues$1U({ width: "100%" }, innerFormStyle), onSubmit: handleSubmit }, typeof children === "function" ? children(newMethods) : children));
});

var __defProp$1T = Object.defineProperty;
var __defProps$t = Object.defineProperties;
var __getOwnPropDescs$t = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1T = Object.getOwnPropertySymbols;
var __hasOwnProp$1T = Object.prototype.hasOwnProperty;
var __propIsEnum$1T = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1T = (obj, key, value) => key in obj ? __defProp$1T(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1T = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1T.call(b, prop))
      __defNormalProp$1T(a, prop, b[prop]);
  if (__getOwnPropSymbols$1T)
    for (var prop of __getOwnPropSymbols$1T(b)) {
      if (__propIsEnum$1T.call(b, prop))
        __defNormalProp$1T(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$t = (a, b) => __defProps$t(a, __getOwnPropDescs$t(b));
var __objRest$1o = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1T.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1T)
    for (var prop of __getOwnPropSymbols$1T(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1T.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FormLabel = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children: label
  } = _b, rest = __objRest$1o(_b, [
    "children"
  ]);
  return /* @__PURE__ */ React.createElement(
    Label$1,
    __spreadProps$t(__spreadValues$1T({
      size: "sm",
      sx: {
        width: "80%",
        maxWidth: "45ch",
        marginBottom: 1,
        marginInlineEnd: 3
      },
      requiredIndicator: void 0
    }, rest), {
      ref
    }),
    label
  );
});

var __defProp$1S = Object.defineProperty;
var __getOwnPropSymbols$1S = Object.getOwnPropertySymbols;
var __hasOwnProp$1S = Object.prototype.hasOwnProperty;
var __propIsEnum$1S = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1S = (obj, key, value) => key in obj ? __defProp$1S(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1S = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1S.call(b, prop))
      __defNormalProp$1S(a, prop, b[prop]);
  if (__getOwnPropSymbols$1S)
    for (var prop of __getOwnPropSymbols$1S(b)) {
      if (__propIsEnum$1S.call(b, prop))
        __defNormalProp$1S(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1n = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1S.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1S)
    for (var prop of __getOwnPropSymbols$1S(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1S.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const BaseField = (_a, ref) => {
  var _b = _a, {
    name,
    label,
    children,
    direction = "column",
    isRequired = false,
    noLabelConnection = false,
    validate,
    control: passedControl
  } = _b, rest = __objRest$1n(_b, [
    "name",
    "label",
    "children",
    "direction",
    "isRequired",
    "noLabelConnection",
    "validate",
    "control"
  ]);
  const methods = useFormContext();
  const { formState: { errors } } = methods;
  const control = passedControl != null ? passedControl : methods.control;
  const fieldError = getFieldError(name, errors);
  return /* @__PURE__ */ React.createElement(FormControl, { isInvalid: !!fieldError, isRequired, ref }, /* @__PURE__ */ React.createElement(
    Stack,
    __spreadValues$1S({
      spacing: "auto",
      direction,
      alignItems: direction === "column" ? "stretch" : "center"
    }, rest),
    label && /* @__PURE__ */ React.createElement(FormLabel, { htmlFor: noLabelConnection ? void 0 : name, mb: 1 }, label),
    /* @__PURE__ */ React.createElement(
      Controller,
      {
        name,
        control,
        rules: validate,
        render: ({ field }) => children(field, methods)
      }
    )
  ), /* @__PURE__ */ React.createElement(FormErrorMessage, null, fieldError && (fieldError == null ? void 0 : fieldError.message)));
};
const Field = forwardRef$1(BaseField);

const useSetValueRefreshed = () => {
  const { setValue, watch } = useFormContext();
  const setValueRefreshed = (name, value, options) => {
    watch(name);
    setValue(name, value, options);
  };
  return setValueRefreshed;
};

var __defProp$1R = Object.defineProperty;
var __getOwnPropSymbols$1R = Object.getOwnPropertySymbols;
var __hasOwnProp$1R = Object.prototype.hasOwnProperty;
var __propIsEnum$1R = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1R = (obj, key, value) => key in obj ? __defProp$1R(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1R = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1R.call(b, prop))
      __defNormalProp$1R(a, prop, b[prop]);
  if (__getOwnPropSymbols$1R)
    for (var prop of __getOwnPropSymbols$1R(b)) {
      if (__propIsEnum$1R.call(b, prop))
        __defNormalProp$1R(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1m = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1R.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1R)
    for (var prop of __getOwnPropSymbols$1R(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1R.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const CheckboxField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    variant,
    isRequired,
    validate,
    onChange: onChangeCallback = identity,
    direction = "row",
    labelPlacement = "left",
    labelSize = "md"
  } = _b, rest = __objRest$1m(_b, [
    "name",
    "label",
    "variant",
    "isRequired",
    "validate",
    "onChange",
    "direction",
    "labelPlacement",
    "labelSize"
  ]);
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      w: label ? "full" : "fit-content",
      display: "inline-flex"
    },
    /* @__PURE__ */ React.createElement(
      Field,
      {
        name,
        label: "",
        isRequired,
        direction,
        validate,
        ref
      },
      ({ onChange, value }) => /* @__PURE__ */ React.createElement(
        Flex,
        {
          gap: 2,
          direction: labelPlacement === "left" ? "row-reverse" : "row"
        },
        /* @__PURE__ */ React.createElement(
          Checkbox$1,
          __spreadValues$1R({
            name,
            onChange: (e) => {
              onChange(e);
              onChangeCallback(e);
            },
            value,
            variant,
            "data-testid": "checkbox-field-test-id"
          }, rest)
        ),
        /* @__PURE__ */ React.createElement(Label$1, { htmlFor: name, sx: { fontWeight: "normal" }, size: labelSize }, label)
      )
    )
  );
});

var __defProp$1Q = Object.defineProperty;
var __getOwnPropSymbols$1Q = Object.getOwnPropertySymbols;
var __hasOwnProp$1Q = Object.prototype.hasOwnProperty;
var __propIsEnum$1Q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1Q = (obj, key, value) => key in obj ? __defProp$1Q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1Q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1Q.call(b, prop))
      __defNormalProp$1Q(a, prop, b[prop]);
  if (__getOwnPropSymbols$1Q)
    for (var prop of __getOwnPropSymbols$1Q(b)) {
      if (__propIsEnum$1Q.call(b, prop))
        __defNormalProp$1Q(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1l = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1Q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1Q)
    for (var prop of __getOwnPropSymbols$1Q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1Q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const IconButton = forwardRef$1((_a, ref) => {
  var _b = _a, {
    variant = "default",
    icon,
    "aria-label": ariaLabel,
    children
  } = _b, rest = __objRest$1l(_b, [
    "variant",
    "icon",
    "aria-label",
    "children"
  ]);
  var _a2;
  const IconComponent = icon != null ? icon : children;
  const IconWithSize = cloneElement(IconComponent, { size: (_a2 = IconComponent.props.size) != null ? _a2 : rest.size });
  return /* @__PURE__ */ React.createElement(
    IconButton$1,
    __spreadValues$1Q({
      variant,
      icon: IconWithSize,
      "aria-label": ariaLabel,
      ref
    }, rest)
  );
});

const columns = 5;
const paletteColors = getShades(100, 500);
const defaultColors = getShades(500);

const ColorButton = forwardRef$1(({
  color,
  onClick,
  size,
  selected = false
}, ref) => {
  if (!color)
    return /* @__PURE__ */ React.createElement(Box, null);
  const { defaultArrows, focusPrevious, focusNext } = useArrowFocus(columns);
  const onKeyDown = (e) => {
    switch (e.key) {
      case "PageUp":
        e.preventDefault();
        focusPrevious({ wrap: false, repeat: columns * 5 });
        break;
      case "PageDown":
        e.preventDefault();
        focusNext({ wrap: false, repeat: columns * 5 });
        break;
      default:
        defaultArrows(e);
        break;
    }
  };
  const { colorButton } = useMultiStyleConfig("ColorPicker", { size });
  return /* @__PURE__ */ React.createElement(
    IconButton,
    {
      bg: color,
      ref,
      onKeyDown,
      "aria-label": `select-${color}`,
      onClick,
      sx: colorButton,
      icon: /* @__PURE__ */ React.createElement(Icon$1, { as: CheckDuo, boxSize: selected ? void 0 : "0" }),
      color: getContrastColor(color)
    }
  );
});

var __defProp$1P = Object.defineProperty;
var __getOwnPropSymbols$1P = Object.getOwnPropertySymbols;
var __hasOwnProp$1P = Object.prototype.hasOwnProperty;
var __propIsEnum$1P = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1P = (obj, key, value) => key in obj ? __defProp$1P(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1P = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1P.call(b, prop))
      __defNormalProp$1P(a, prop, b[prop]);
  if (__getOwnPropSymbols$1P)
    for (var prop of __getOwnPropSymbols$1P(b)) {
      if (__propIsEnum$1P.call(b, prop))
        __defNormalProp$1P(a, prop, b[prop]);
    }
  return a;
};
const Popover$1 = (props) => /* @__PURE__ */ React.createElement(Popover$2, __spreadValues$1P({ isLazy: true }, props));

const ColorsExpandButton = ({
  onClick,
  size,
  expanded
}) => {
  const { defaultArrows, focusPrevious, focusFirst } = useArrowFocus(columns);
  const { colorButton } = useMultiStyleConfig("ColorPicker", { size });
  const onKeyDown = (e) => {
    switch (e.key) {
      case "Tab":
        focusFirst();
        break;
      case "ArrowUp":
        e.preventDefault();
        focusPrevious({ wrap: true, repeat: 1 });
        break;
      case "PageUp":
        e.preventDefault();
        focusPrevious({ wrap: false, repeat: columns * 5 });
        break;
      default:
        defaultArrows(e);
        break;
    }
  };
  return /* @__PURE__ */ React.createElement(
    IconButton,
    {
      variant: "ghost",
      onKeyDown,
      "aria-label": "display more colors",
      onClick,
      sx: colorButton
    },
    /* @__PURE__ */ React.createElement(Icon$1, { as: expanded ? ChevronUpDuo : ChevronDownDuo })
  );
};

var __defProp$1O = Object.defineProperty;
var __getOwnPropSymbols$1O = Object.getOwnPropertySymbols;
var __hasOwnProp$1O = Object.prototype.hasOwnProperty;
var __propIsEnum$1O = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1O = (obj, key, value) => key in obj ? __defProp$1O(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1O = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1O.call(b, prop))
      __defNormalProp$1O(a, prop, b[prop]);
  if (__getOwnPropSymbols$1O)
    for (var prop of __getOwnPropSymbols$1O(b)) {
      if (__propIsEnum$1O.call(b, prop))
        __defNormalProp$1O(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1k = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1O.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1O)
    for (var prop of __getOwnPropSymbols$1O(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1O.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ColorPicker$1 = (_a) => {
  var _b = _a, {
    onChange = () => {
    },
    colors = defaultColors,
    expandedColors = paletteColors,
    value = null,
    name,
    size = "md",
    popoverProps
  } = _b, rest = __objRest$1k(_b, [
    "onChange",
    "colors",
    "expandedColors",
    "value",
    "name",
    "size",
    "popoverProps"
  ]);
  const { isOpen, onToggle, onClose } = useDisclosure();
  const [expanded, setExpanded] = useBoolean();
  const [selectedColor, setSelectedColor] = useState(value);
  const [visibleColors, setVisibleColors] = useState(colors);
  const initialFocusRef = useRef(null);
  const {
    trigger,
    heading
  } = useMultiStyleConfig("ColorPicker", { selectedColor, size });
  const parsedValue = value && useToken$1("colors", value);
  const baseColors = [...colors];
  for (let i = 0; i < baseColors.length % columns; i += 1) {
    baseColors.push("");
  }
  useEffect(() => {
    if (value === "") {
      setSelectedColor(null);
    } else {
      setSelectedColor(parsedValue);
    }
  }, [value]);
  useEffect(() => {
    if (expanded) {
      setVisibleColors((prev) => prev.concat(expandedColors));
    } else {
      setVisibleColors(baseColors);
    }
  }, [expanded]);
  const expandColors = () => {
    setExpanded.toggle();
  };
  const getNumberOfColumns = () => {
    if (expanded)
      return columns;
    if (colors.length < columns && colors.length > 2) {
      return colors.length;
    }
    if (colors.length < columns) {
      return 3;
    }
    return columns;
  };
  const shouldBeFocused = (index) => selectedColor ? index === visibleColors.findIndex((colorVal) => colorVal === selectedColor) : index === 0;
  const handleSelect = (color) => {
    onToggle();
    setSelectedColor(color);
    onChange(color);
  };
  return /* @__PURE__ */ React.createElement(Box, { "data-testid": "color-picker-test-id" }, /* @__PURE__ */ React.createElement(
    Popover$1,
    __spreadValues$1O({
      isOpen,
      onClose,
      initialFocusRef
    }, popoverProps),
    /* @__PURE__ */ React.createElement(PopoverTrigger, null, /* @__PURE__ */ React.createElement(
      IconButton,
      __spreadValues$1O({
        onClick: onToggle,
        "aria-label": name || "color picker",
        name,
        sx: trigger,
        size,
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: ColorsDuo })
      }, rest)
    )),
    /* @__PURE__ */ React.createElement(PopoverContent, { w: "auto", boxShadow: "md", p: 2, bgColor: "background.default" }, /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(
      PopoverHeader,
      {
        color: "text.default",
        sx: heading
      },
      "Pick a color"
    ), /* @__PURE__ */ React.createElement(PopoverBody, { p: 0 }, /* @__PURE__ */ React.createElement(Stack, { alignItems: "center", p: 0, spacing: 0 }, /* @__PURE__ */ React.createElement(FocusScope, null, /* @__PURE__ */ React.createElement(
      SimpleGrid,
      {
        columns: getNumberOfColumns(),
        spacing: 2,
        overflowY: "scroll",
        maxH: 72,
        pr: 2,
        pl: 4,
        py: 1
      },
      visibleColors.map((color, index) => /* @__PURE__ */ React.createElement(
        ColorButton,
        {
          color,
          key: `${color}-button-${index}`,
          selected: color === selectedColor,
          ref: shouldBeFocused(index) ? initialFocusRef : void 0,
          size,
          onClick: () => handleSelect(color)
        }
      ))
    ), expandedColors.length > 0 && /* @__PURE__ */ React.createElement(
      ColorsExpandButton,
      {
        onClick: expandColors,
        expanded,
        size
      }
    ))))))
  ));
};

var __defProp$1N = Object.defineProperty;
var __getOwnPropSymbols$1N = Object.getOwnPropertySymbols;
var __hasOwnProp$1N = Object.prototype.hasOwnProperty;
var __propIsEnum$1N = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1N = (obj, key, value) => key in obj ? __defProp$1N(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1N = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1N.call(b, prop))
      __defNormalProp$1N(a, prop, b[prop]);
  if (__getOwnPropSymbols$1N)
    for (var prop of __getOwnPropSymbols$1N(b)) {
      if (__propIsEnum$1N.call(b, prop))
        __defNormalProp$1N(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1j = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1N.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1N)
    for (var prop of __getOwnPropSymbols$1N(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1N.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ColorPickerField = (_a) => {
  var _b = _a, {
    name,
    label,
    direction,
    isRequired,
    validate
  } = _b, rest = __objRest$1j(_b, [
    "name",
    "label",
    "direction",
    "isRequired",
    "validate"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      ColorPicker$1,
      __spreadValues$1N({
        name,
        onChange,
        value
      }, rest)
    )
  );
};

var __defProp$1M = Object.defineProperty;
var __defProps$s = Object.defineProperties;
var __getOwnPropDescs$s = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1M = Object.getOwnPropertySymbols;
var __hasOwnProp$1M = Object.prototype.hasOwnProperty;
var __propIsEnum$1M = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1M = (obj, key, value) => key in obj ? __defProp$1M(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1M = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1M.call(b, prop))
      __defNormalProp$1M(a, prop, b[prop]);
  if (__getOwnPropSymbols$1M)
    for (var prop of __getOwnPropSymbols$1M(b)) {
      if (__propIsEnum$1M.call(b, prop))
        __defNormalProp$1M(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$s = (a, b) => __defProps$s(a, __getOwnPropDescs$s(b));
const FlipButtonContext = createContext(null);
const useFlipButtonState = (props, isMulti) => isMulti ? useCheckboxGroupState(props) : useRadioGroupState(props);
const useFlipButtonGroup = (props, state, isMulti) => {
  const propsWithLabel = __spreadProps$s(__spreadValues$1M({}, props), {
    "aria-label": `${isMulti ? "Checkbox" : "Radio"}-button-group`
  });
  return isMulti ? useCheckboxGroup(
    propsWithLabel,
    state
  ).groupProps : useRadioGroup(
    propsWithLabel,
    state
  ).radioGroupProps;
};
const useFlipButton = (props, isMulti) => {
  const state = useFlipButtonState(props, isMulti);
  const flipButtonGroupProps = useFlipButtonGroup(props, state, isMulti);
  return { state, flipButtonGroupProps };
};

var __defProp$1L = Object.defineProperty;
var __defProps$r = Object.defineProperties;
var __getOwnPropDescs$r = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1L = Object.getOwnPropertySymbols;
var __hasOwnProp$1L = Object.prototype.hasOwnProperty;
var __propIsEnum$1L = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1L = (obj, key, value) => key in obj ? __defProp$1L(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1L = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1L.call(b, prop))
      __defNormalProp$1L(a, prop, b[prop]);
  if (__getOwnPropSymbols$1L)
    for (var prop of __getOwnPropSymbols$1L(b)) {
      if (__propIsEnum$1L.call(b, prop))
        __defNormalProp$1L(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$r = (a, b) => __defProps$r(a, __getOwnPropDescs$r(b));
var __objRest$1i = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1L.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1L)
    for (var prop of __getOwnPropSymbols$1L(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1L.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FlipButton$1 = (props) => {
  const _a = props, {
    children,
    size,
    variant,
    isMulti,
    isDisabled = false,
    icon,
    value,
    iconPlacement = "left"
  } = _a, rest = __objRest$1i(_a, [
    "children",
    "size",
    "variant",
    "isMulti",
    "isDisabled",
    "icon",
    "value",
    "iconPlacement"
  ]);
  const state = useContext(FlipButtonContext);
  const ref = useRef(null);
  const propsWithoutChildren = omit(["children"], __spreadProps$r(__spreadValues$1L({}, props), { "aria-label": `${isMulti ? "Checkbox" : "Radio"}-input for ${value}` }));
  const { inputProps } = isMulti ? useCheckboxGroupItem(propsWithoutChildren, state, ref) : useRadio(propsWithoutChildren, state, ref);
  const { button, buttonIcon } = useMultiStyleConfig("FlipButton", { size, variant });
  const { focusProps, isFocusVisible: isFocused } = useFocusRing();
  const focusStyles = {
    outline: "none",
    ring: "2px",
    ringColor: "border.wcag",
    ringOffset: "1px"
  };
  const focusRing = isFocused ? focusStyles : {};
  const isSelected = isMulti ? state.isSelected(value) : state.selectedValue === value;
  const flipButtonProps = __spreadProps$r(__spreadValues$1L({}, mergeProps(inputProps, focusProps)), {
    ref,
    style: { opacity: "0", width: "0", height: "0" },
    "aria-label": isMulti ? "Checkbox-input" : "Radio-input"
  });
  const containerProps = {
    "aria-checked": isSelected,
    "aria-disabled": isDisabled,
    sx: focusRing,
    as: "label",
    cursor: "pointer"
  };
  return typeof children === "function" ? children(__spreadValues$1L({
    state,
    containerProps,
    flipButtonProps,
    isFocused,
    isSelected,
    isDisabled,
    isMulti: isMulti || false,
    focusRing,
    value
  }, rest)) : /* @__PURE__ */ React.createElement(
    HStack,
    {
      spacing: isSelected && iconPlacement !== "none" || icon ? 2 : 0,
      sx: mergeAll([button, isFocused ? focusStyles : {}, { flexDirection: iconPlacement === "left" ? "row" : "row-reverse" }]),
      "aria-checked": isSelected,
      "aria-disabled": isDisabled,
      as: "label"
    },
    /* @__PURE__ */ React.createElement("input", __spreadValues$1L({}, flipButtonProps)),
    icon && iconPlacement !== "none" ? /* @__PURE__ */ React.createElement(Icon$1, { as: icon || CheckSolid, sx: buttonIcon }) : isSelected && iconPlacement !== "none" && /* @__PURE__ */ React.createElement(SlideFade$1, { in: isSelected }, /* @__PURE__ */ React.createElement(Icon$1, { as: icon || CheckSolid, sx: buttonIcon })),
    /* @__PURE__ */ React.createElement(Text, { textAlign: "center" }, children)
  );
};

var __defProp$1K = Object.defineProperty;
var __defProps$q = Object.defineProperties;
var __getOwnPropDescs$q = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1K = Object.getOwnPropertySymbols;
var __hasOwnProp$1K = Object.prototype.hasOwnProperty;
var __propIsEnum$1K = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1K = (obj, key, value) => key in obj ? __defProp$1K(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1K = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1K.call(b, prop))
      __defNormalProp$1K(a, prop, b[prop]);
  if (__getOwnPropSymbols$1K)
    for (var prop of __getOwnPropSymbols$1K(b)) {
      if (__propIsEnum$1K.call(b, prop))
        __defNormalProp$1K(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$q = (a, b) => __defProps$q(a, __getOwnPropDescs$q(b));
var __objRest$1h = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1K.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1K)
    for (var prop of __getOwnPropSymbols$1K(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1K.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FlipButtonGroup = (props) => {
  const _a = props, {
    isMulti = false,
    name,
    children,
    direction = "row",
    isDisabled = false,
    iconPlacement = "left",
    size,
    variant,
    icon,
    sx = {}
  } = _a, rest = __objRest$1h(_a, [
    "isMulti",
    "name",
    "children",
    "direction",
    "isDisabled",
    "iconPlacement",
    "size",
    "variant",
    "icon",
    "sx"
  ]);
  const { state, flipButtonGroupProps } = useFlipButton(props, isMulti);
  const numberOfButtons = Children.count(children);
  const childrenWithProps = Children.toArray(children).map(
    (child) => isValidElement(child) ? cloneElement(child, __spreadValues$1K({
      key: child.props.value,
      isMulti,
      variant,
      isDisabled,
      iconPlacement,
      icon,
      size
    }, child.props)) : child
  );
  const { container } = useMultiStyleConfig("FlipButton", {
    size,
    variant,
    numberOfButtons,
    sx
  });
  const restWithoutOnChange = omit(["onChange"], rest);
  return /* @__PURE__ */ React.createElement(
    Stack,
    __spreadValues$1K(__spreadProps$q(__spreadValues$1K({}, flipButtonGroupProps), {
      direction,
      id: name,
      spacing: 0,
      sx: container
    }), restWithoutOnChange),
    /* @__PURE__ */ React.createElement(FlipButtonContext.Provider, { value: state }, childrenWithProps)
  );
};

var __defProp$1J = Object.defineProperty;
var __getOwnPropSymbols$1J = Object.getOwnPropertySymbols;
var __hasOwnProp$1J = Object.prototype.hasOwnProperty;
var __propIsEnum$1J = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1J = (obj, key, value) => key in obj ? __defProp$1J(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1J = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1J.call(b, prop))
      __defNormalProp$1J(a, prop, b[prop]);
  if (__getOwnPropSymbols$1J)
    for (var prop of __getOwnPropSymbols$1J(b)) {
      if (__propIsEnum$1J.call(b, prop))
        __defNormalProp$1J(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1g = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1J.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1J)
    for (var prop of __getOwnPropSymbols$1J(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1J.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FlipButtonGroupField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    children,
    direction,
    isRequired,
    iconPlacement = "left",
    onChange: onChangeCallback = identity,
    validate
  } = _b, rest = __objRest$1g(_b, [
    "name",
    "label",
    "children",
    "direction",
    "isRequired",
    "iconPlacement",
    "onChange",
    "validate"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      FlipButtonGroup,
      __spreadValues$1J({
        name,
        onChange: (e) => {
          onChange(e);
          onChangeCallback(e);
        },
        direction,
        value,
        iconPlacement
      }, rest),
      children
    )
  );
});

const scrollbarStyles = {
  "::-webkit-scrollbar": {
    width: "8px",
    height: "8px"
  },
  "::-webkit-scrollbar-track": {
    background: "background.scrollbar.track"
  },
  "::-webkit-scrollbar-thumb": {
    borderRadius: "scrollbar.thumb",
    border: "2px solid",
    borderColor: "border.scrollbar.thumb",
    backgroundClip: "padding-box !important",
    background: "background.scrollbar.thumb"
  },
  "::-webkit-scrollbar-thumb:hover": {
    borderRadius: "scrollbar.thumb",
    border: "1px solid ",
    borderColor: "border.scrollbar.thumb",
    backgroundClip: "padding-box !important",
    background: "background.scrollbar.thumb"
  }
};

const Breadcrumb = {
  parts: ["link", "separator"],
  baseStyle: {
    link: {
      padding: [0.5, 1],
      color: "primary",
      fontWeight: "600",
      fontSize: "semibold",
      _hover: {
        bg: "blue.50",
        borderRadius: "base",
        textDecor: "none"
      }
    },
    separator: {
      color: "gray.300",
      fontSize: "semibold"
    }
  }
};

const Button = {
  sizes: {
    xs: ({ theme: { sizes: sizing, space: spacing } }) => ({
      height: sizing.button.xs,
      minWidth: sizing.button.xs,
      paddingInlineStart: spacing["padding-inline"].button.xs,
      paddingInlineEnd: spacing["padding-inline"].button.xs
    }),
    sm: ({ theme: { sizes: sizing, space: spacing } }) => ({
      height: sizing.button.sm,
      minWidth: sizing.button.sm,
      paddingInlineStart: spacing["padding-inline"].button.md,
      paddingInlineEnd: spacing["padding-inline"].button.md
    }),
    md: ({ theme: { sizes: sizing, space: spacing } }) => ({
      height: sizing.button.md,
      minWidth: sizing.button.md,
      paddingInlineStart: spacing["padding-inline"].button.md,
      paddingInlineEnd: spacing["padding-inline"].button.md
    }),
    lg: ({ theme: { sizes: sizing, space: spacing } }) => ({
      height: sizing.button.lg,
      minWidth: sizing.button.lg,
      paddingInlineStart: spacing["padding-inline"].button.lg,
      paddingInlineEnd: spacing["padding-inline"].button.lg
    })
  },
  baseStyle: ({ theme: { colors: color, radii: borderRadius } }) => ({
    color: color.text.default,
    borderRadius: borderRadius.button.default,
    _focusVisible: {
      ring: "2px",
      ringColor: color.border.wcag,
      ringOffset: "1px"
    }
  }),
  variants: {
    default: ({ theme: { colors: color } }) => ({
      bgColor: color.background.button.default,
      _hover: {
        bgColor: color.background.button["default-hover"]
      },
      _active: {
        bgColor: color.background.button["default-active"]
      }
    }),
    danger: ({ theme: { colors: color } }) => ({
      bgColor: color.background.button.danger,
      color: color.text.button.danger,
      _hover: {
        bg: color.background.button["danger-hover"],
        _disabled: {
          bgColor: color.background.button.danger
        }
      },
      _active: {
        bgColor: color.background.button["danger-active"]
      }
    }),
    success: ({ theme: { colors: color } }) => ({
      bgColor: color.background.button.success,
      color: color.text.button.success,
      _hover: {
        bg: color.background.button["success-hover"],
        _disabled: {
          bgColor: color.background.button.success
        }
      },
      _active: {
        bgColor: color.background.button["success-active"]
      }
    }),
    brand: ({ theme: { colors: color } }) => ({
      color: color.text.inverted,
      bgColor: color.background.button.brand,
      _hover: {
        bg: color.background.button["brand-hover"],
        _disabled: {
          bgColor: color.background.button.brand
        }
      },
      _active: {
        bgColor: color.background.button["brand-active"]
      }
    }),
    brandSubdued: ({ theme: { colors: color } }) => ({
      color: color.text.button.link,
      bgColor: color.background.button.ghost,
      _hover: {
        bg: color.background.button.brand,
        color: color.text.inverted,
        _disabled: {
          bgColor: color.background.button.ghost,
          color: color.text.button.link
        }
      },
      _active: {
        bg: color.background.button["brand-hover"],
        color: color.text.inverted
      }
    }),
    link: ({ theme: { colors: color } }) => ({
      textDecoration: "underline",
      color: color.text.button.link,
      bgColor: color.background.button.link,
      _hover: {
        color: color.text.button["link-hover"],
        bgColor: color.background.button["link-hover"]
      },
      _active: {
        color: color.text.button["link-hover"],
        bgColor: color.background.button["link-active"]
      }
    }),
    outline: ({ theme: { colors: color } }) => ({
      color: color.text.default,
      _hover: {
        bg: color.background.button["ghost-hover"]
      },
      _active: {
        bg: color.background.button["ghost-active"]
      }
    }),
    ghost: ({ theme: { colors: color } }) => ({
      color: color.text.default,
      bgColor: color.background.button.ghost,
      _hover: {
        bg: color.background.button["ghost-hover"],
        _disabled: {
          bgColor: color.background.button.ghost
        }
      },
      _active: {
        bgColor: color.background.button["ghost-active"]
      }
    }),
    ai: ({ theme: { colors: color } }) => ({
      color: color.text.inverted,
      bgColor: color.bg.ai.default,
      _hover: {
        bgColor: color.bg.ai.hover,
        _disabled: {
          bgColor: color.bg.ai.default
        }
      },
      _active: {
        bgColor: color.bg.ai.active
      }
    }),
    aiSubdued: ({ theme: { colors: color } }) => ({
      color: color.ai,
      bgColor: color.background.button.ghost,
      _hover: {
        bg: color.bg.ai.default,
        color: color.text.inverted,
        _disabled: {
          bgColor: color.background.button.ghost,
          color: color.ai
        }
      },
      _active: {
        bg: color.bg.ai.hover,
        color: color.text.inverted
      }
    })
  },
  defaultProps: {
    size: "md"
  }
};

const pulseRing = keyframes`
0% {
  transform: scale(0.33);
}
30% {
  transform: scale(0.66);
},
40%,
50% {
  opacity: 0;
}
100% {
  opacity: 0;
}
`;
const Blinker = {
  baseStyle: ({ theme: { colors: palette }, color, isBlinking }) => ({
    position: "relative",
    borderRadius: "50%",
    bgColor: color === "" ? palette.blue["500"] : color,
    _before: isBlinking ? {
      content: "''",
      position: "absolute",
      display: "block",
      width: "300%",
      height: "300%",
      marginLeft: "-100%",
      marginTop: "-100%",
      borderRadius: "50%",
      bgColor: color === "" ? "blue.500" : color,
      animation: `2.25s ${pulseRing} cubic-bezier(0.455, 0.03, 0.515, 0.955) -0.4s infinite`,
      zIndex: "base"
    } : {}
  }),
  sizes: {
    "2xs": ({ theme: { sizes: sizing } }) => ({
      height: sizing.blinker["2xs"],
      width: sizing.blinker["2xs"]
    }),
    xs: ({ theme: { sizes: sizing } }) => ({
      height: sizing.blinker.xs,
      width: sizing.blinker.xs
    }),
    sm: ({ theme: { sizes: sizing } }) => ({
      height: sizing.blinker.sm,
      width: sizing.blinker.sm
    }),
    md: ({ theme: { sizes: sizing } }) => ({
      height: sizing.blinker.md,
      width: sizing.blinker.md
    }),
    lg: ({ theme: { sizes: sizing } }) => ({
      height: sizing.blinker.lg,
      width: sizing.blinker.lg
    })
  },
  defaultProps: {
    size: "md",
    color: "blue.500"
  }
};

const Checkbox = {
  parts: ["control", "label"],
  sizes: {
    sm: {
      control: {
        fontSize: 5
      }
    },
    md: {
      control: {
        fontSize: 7
      }
    },
    lg: {
      control: {
        fontSize: 8
      }
    }
  },
  baseStyle: ({ theme: { colors: color, opacity } }) => ({
    control: {
      borderColor: color.border.checkbox.default,
      bg: color.background.checkbox.default,
      borderWidth: 2,
      _checked: {
        borderColor: color.border.checkbox.checked,
        bg: color.background.checkbox.checked,
        _hover: {
          borderColor: color.border.checkbox.checked,
          bg: color.background.checkbox.checked
        }
      },
      _invalid: {
        borderColor: color.border.checkbox.error,
        bg: color.background.checkbox.default,
        _checked: {
          bg: color.background.checkbox.error
        },
        _hover: {
          borderColor: color.border.checkbox.error,
          bg: color.background.checkbox.default
        }
      },
      _focusVisible: {
        ring: "2px",
        ringColor: color.border.wcag,
        ringOffset: "1px"
      },
      _hover: {
        borderColor: color.border.checkbox["default-hover"],
        bg: color.background.checkbox.default
      },
      _disabled: {
        borderColor: color.border.checkbox.disabled,
        bg: color.background.checkbox.disabled,
        opacity: opacity.checkbox.disabled,
        _checked: {
          borderColor: color.border.checkbox.checked,
          bg: color.background.checkbox.checked,
          opacity: opacity.checkbox.disabled,
          color: "white",
          _hover: {
            borderColor: color.border.checkbox.checked,
            bg: color.background.checkbox.checked,
            opacity: opacity.checkbox.disabled
          }
        },
        _hover: {
          borderColor: color.border.checkbox.disabled,
          bg: color.background.checkbox.disabled,
          opacity: opacity.checkbox.disabled
        }
      }
    }
  }),
  variants: {
    default: ({ theme: { radii: borderRadius } }) => ({
      control: {
        borderRadius: borderRadius.checkbox.default
      }
    }),
    rounded: ({ theme: { radii: borderRadius } }) => ({
      control: {
        borderRadius: borderRadius.checkbox.full
      }
    })
  }
};

const Input = {
  parts: ["field", "addon"],
  baseStyle: ({ theme: { colors: color } }) => ({
    field: {
      color: color.text.default,
      _placeholder: {
        color: color.text.input.placeholder,
        opacity: 1
      }
    }
  }),
  variants: {
    outline: ({ theme: {
      colors: color,
      space: spacing,
      radii: borderRadius,
      borders: borderWidth,
      opacity
    } }) => ({
      field: {
        paddingInlineStart: spacing["padding-inline"].input.default,
        paddingInlineEnd: spacing["padding-inline"].input.default,
        bgColor: color.background.input["outline-default"],
        borderRadius: borderRadius.input.outline,
        borderWidth: borderWidth.input.default,
        borderColor: color.border.input.default,
        _readOnly: {
          _focusVisible: {
            borderColor: color.border.input.readonly
          },
          _hover: {
            borderColor: color.border.input.readonly
          }
        },
        _focusVisible: {
          bgColor: color.background.input["outline-focus"],
          borderColor: color.border.input.focus,
          _invalid: {
            boxShadow: `0 0 0 1px ${color.border.input.error}`,
            bgColor: color.background.input["outline-error"],
            borderColor: color.border.input.error
          }
        },
        _hover: {
          bgColor: color.background.input["outline-hover"],
          borderColor: color.border.input["default-hover"]
        },
        _invalid: {
          bgColor: color.background.input["outline-error"],
          borderColor: color.border.input.error
        },
        _disabled: {
          bgColor: color.background.input["outline-disabled"],
          borderColor: color.border.input.disabled,
          opacity: opacity.input.disabled
        }
      },
      addon: {
        border: "none",
        background: "none",
        color: color.text.default
      }
    }),
    filled: ({ theme: {
      colors: color,
      space: spacing,
      radii: borderRadius,
      borders: borderWidth,
      opacity
    } }) => ({
      field: {
        paddingInlineStart: spacing["padding-inline"].input.default,
        paddingInlineEnd: spacing["padding-inline"].input.default,
        borderRadius: borderRadius.input.filled,
        borderWidth: borderWidth.input.default,
        bgColor: color.background.input["filled-default"],
        _readOnly: {
          _focusVisible: {
            borderColor: color.border.input.readonly
          },
          _hover: {
            bgColor: color.background.input["filled-default"]
          }
        },
        _hover: {
          bgColor: color.background.input["filled-hover"]
        },
        _focusVisible: {
          boxShadow: `0 0 0 1px ${color.border.input.focus}`,
          borderColor: color.border.input.focus,
          bgColor: color.background.input["filled-focus"],
          _readOnly: {
            bgColor: color.background.input["filled-default"]
          },
          _invalid: {
            boxShadow: `0 0 0 1px ${color.border.input.error}`,
            bgColor: color.background.input["outline-error"],
            borderColor: color.border.input.error
          }
        },
        _invalid: {
          boxShadow: `0 0 0 1px ${color.border.input.error}`,
          bgColor: color.background.input["filled-error"],
          borderColor: color.border.input.error
        },
        _disabled: {
          bgColor: color.background.input["filled-disabled"],
          borderColor: color.border.input.disabled,
          opacity: opacity.input.disabled
        }
      }
    }),
    flushed: ({ theme: {
      colors: color,
      space: spacing,
      radii: borderRadius,
      borders: borderWidth,
      opacity
    } }) => ({
      field: {
        paddingInlineStart: spacing["padding-inline"].input.flushed,
        paddingInlineEnd: spacing["padding-inline"].input.flushed,
        bgColor: color.background.input["flushed-default"],
        borderRadius: borderRadius.input.flushed,
        borderBottomWidth: borderWidth.input.default,
        borderBottomColor: color.border.input.default,
        _readOnly: {
          _focusVisible: {
            borderColor: color.border.input.readonly
          },
          _hover: {
            borderColor: color.border.input.readonly
          }
        },
        _hover: {
          bgColor: color.background.input["flushed-hover"],
          borderColor: color.border.input["default-hover"]
        },
        _focusVisible: {
          _hover: {
            boxShadow: `0 1px 0 0 ${color.border.input.focus}`,
            borderColor: color.border.input.focus
          },
          _invalid: {
            boxShadow: `0 1px 0 0 ${color.border.input.error}`,
            borderColor: color.border.input.error,
            bgColor: color.background.input["flushed-error"]
          }
        },
        _invalid: {
          _hover: {
            boxShadow: `0 1px 0 0 ${color.border.input.error}`,
            borderColor: color.border.input.error
          },
          bgColor: color.background.input["flushed-error"]
        },
        _disabled: {
          bgColor: color.background.input["flushed-disabled"],
          borderColor: color.border.input.disabled,
          opacity: opacity.input.disabled
        }
      }
    }),
    ai: ({ theme: {
      colors: color,
      space: spacing,
      radii: borderRadius,
      borders: borderWidth,
      opacity
    } }) => ({
      field: {
        paddingInlineStart: spacing["padding-inline"].input.default,
        paddingInlineEnd: spacing["padding-inline"].input.default,
        bgColor: color.background.input["outline-default"],
        borderRadius: borderRadius.input.outline,
        borderWidth: borderWidth.input.default,
        borderColor: color.border.input.default,
        _readOnly: {
          _focusVisible: {
            borderColor: color.border.input.readonly
          },
          _hover: {
            borderColor: color.border.input.readonly
          }
        },
        _focusVisible: {
          bgColor: color.background.input["outline-focus"],
          _hover: {
            boxShadow: `0 0 0 1px ${color.border.ai}`,
            borderColor: color.border.ai
          },
          _invalid: {
            boxShadow: `0 0 0 1px ${color.border.input.error}`,
            bgColor: color.background.input["outline-error"],
            borderColor: color.border.input.error
          }
        },
        _hover: {
          bgColor: color.background.input["outline-hover"],
          borderColor: color.border.input["default-hover"]
        },
        _invalid: {
          bgColor: color.background.input["outline-error"],
          borderColor: color.border.input.error
        },
        _disabled: {
          bgColor: color.background.input["outline-disabled"],
          borderColor: color.border.input.disabled,
          opacity: opacity.input.disabled
        }
      },
      addon: {
        border: "none",
        background: "none",
        color: color.text.default
      }
    })
  }
};

const PinInput$1 = {
  variants: {
    outline: ({ theme: {
      radii: borderRadius,
      borders: borderWidth,
      colors: color,
      space: spacing,
      opacity
    } }) => ({
      borderColor: color.border.input.default,
      borderRadius: borderRadius.input.outline,
      borderWidth: borderWidth.input.default,
      bg: color.background.input["outline-default"],
      color: color.text.default,
      paddingInline: spacing["padding-inline"].input.default,
      _hover: {
        bg: color.background.input["outline-hover"],
        borderColor: color.border.input["default-hover"]
      },
      _focus: {
        borderColor: color.border.input.focus,
        bg: color.background.input["outline-focus"]
      },
      _invalid: {
        bg: color.background.input["outline-error"],
        borderColor: color.border.input.error,
        _placeholder: {
          color: "transparent"
        }
      },
      _disabled: {
        bg: color.background.input["outline-disabled"],
        borderColor: color.border.input.disabled,
        opacity: opacity.input.disabled,
        _hover: {
          bg: color.background.input["outline-disabled"],
          borderColor: color.border.input.disabled
        }
      },
      _placeholder: {
        color: color.text.input.placeholder
      },
      _readonly: {
        borderColor: color.border.input.readonly
      }
    })
  }
};

const Select$1 = {
  parts: ["field", "icon"],
  baseStyle: ({ theme: {
    radii: borderRadius,
    borders: borderWidth,
    colors: color,
    space: spacing
  } }) => ({
    field: {
      paddingInlineStart: spacing["padding-inline"].select.default,
      paddingInlineEnd: spacing["padding-inline"].select.default,
      borderWidth: borderWidth.select,
      color: color.text.default,
      borderColor: color.border.select.default,
      borderRadius: borderRadius.select.default,
      _hover: {
        borderColor: color.border.select["default-hover"]
      },
      _focusVisible: {
        borderColor: color.border.select.focus,
        boxShadow: `0 0 0 1px ${color.border.select.focus}`
      },
      _invalid: {
        borderColor: color.border.select.error,
        boxShadow: "none"
      },
      _readOnly: {
        borderWidth: borderWidth.select,
        borderColor: color.border.select.readonly,
        _focusVisible: {
          borderColor: color.border.select.readonly
        }
      },
      _disabled: {
        borderColor: color.border.select.disabled,
        bg: color.background.select.disabled,
        _hover: {
          borderColor: color.border.select.disabled
        }
      },
      _placeholder: {
        color: color.text.select.placeholder
      }
    },
    icon: {
      color: color.icon.select.default
    }
  }),
  variants: {
    outline: {},
    ai: ({ theme: { colors: color } }) => ({
      field: {
        _focusVisible: {
          borderColor: color.border.ai,
          boxShadow: `0 0 0 1px ${color.border.ai}`
        }
      }
    })
  }
};

const Radio$1 = {
  parts: ["control", "label", "container"],
  sizes: {
    sm: ({ theme: { borders: borderWidth } }) => ({
      control: {
        _checked: {
          borderWidth: borderWidth.radio["checked-sm"]
        }
      }
    }),
    md: ({ theme: { borders: borderWidth } }) => ({
      control: {
        _checked: {
          borderWidth: borderWidth.radio["checked-md"]
        }
      }
    }),
    lg: ({ theme: { borders: borderWidth } }) => ({
      control: {
        _checked: {
          borderWidth: borderWidth.radio["checked-lg"]
        }
      }
    })
  },
  baseStyle: ({ theme: { borders: borderWidth, colors: color } }) => ({
    control: {
      borderColor: color.border.radio.default,
      bg: color.background.radio.default,
      borderWidth: borderWidth.radio.default,
      _checked: {
        borderColor: color.border.radio.checked,
        bg: color.background.radio.checked,
        _hover: {
          borderColor: color.border.radio.checked,
          bg: color.background.radio.checked
        }
      },
      _hover: {
        borderColor: color.border.radio["default-hover"],
        bg: color.background.radio.default
      },
      _disabled: {
        borderColor: color.border.radio.disabled,
        bg: color.background.radio.disabled,
        _hover: {
          borderColor: color.border.radio.disabled,
          bg: color.background.radio.disabled
        }
      },
      _invalid: {
        borderColor: color.border.radio.error,
        bg: color.background.radio.error,
        borderWidth: borderWidth.radio.default,
        _hover: {
          borderColor: color.border.radio.error,
          bg: color.background.radio.error,
          borderWidth: borderWidth.radio.default
        }
      },
      _focusVisible: {
        ring: "2px",
        ringColor: color.border.wcag,
        ringOffset: "1px"
      }
    },
    defaultProps: {
      size: "md"
    }
  })
};

const Tabs$1 = {
  parts: ["tab"],
  variants: {
    "soft-rounded": ({ theme: { colors: color } }) => ({
      tab: {
        borderRadius: 999,
        color: color.text.subdued,
        _selected: {
          bg: color.background.tabs["soft-rounded-active"],
          color: color.text.tabs["soft-rounded-active"]
        },
        _focusVisible: {
          ring: "2px",
          ringColor: color.border.wcag,
          ringOffset: "1px"
        }
      }
    }),
    ai: ({ theme: { colors: color } }) => ({
      tab: {
        borderRadius: 999,
        _selected: {
          bgColor: color.bg.ai.default,
          color: color.text.inverted
        },
        _focusVisible: {
          ring: "2px",
          ringColor: color.border.wcag,
          ringOffset: "1px"
        }
      }
    })
  }
};

const Textarea$1 = {
  baseStyle: ({ theme: {
    space: spacing,
    colors: color,
    borders: borderWidth,
    radii: borderRadius
  } }) => ({
    paddingInlineStart: spacing["padding-inline"].textarea.default,
    paddingInlineEnd: spacing["padding-inline"].textarea.default,
    borderRadius: borderRadius.textarea.default,
    borderWidth: borderWidth.textarea.default,
    borderColor: color.border.textarea.default,
    color: color.text.default,
    bgColor: color.background.textarea.default,
    _hover: {
      borderColor: color.border.textarea["default-hover"],
      bgColor: color.background.textarea.hover
    },
    _focusVisible: {
      borderColor: color.border.textarea.focus,
      boxShadow: `0 0 0 1px ${color.border.textarea.focus}`,
      bgColor: color.background.textarea.active
    },
    _invalid: {
      boxShadow: "none",
      borderColor: color.border.textarea.error,
      bgColor: color.background.textarea.error
    },
    _readOnly: {
      _focusVisible: {
        borderColor: color.border.textarea.readonly,
        bgColor: color.background.textarea.default
      },
      _hover: {
        borderColor: color.border.textarea.readonly
      }
    },
    _disabled: {
      bgColor: color.background.textarea.disabled,
      _hover: {
        borderColor: color.border.textarea.default
      }
    },
    _placeholder: {
      color: color.text.textarea.placeholder
    }
  }),
  variants: {
    outline: {},
    ai: ({ theme: { colors: color } }) => ({
      _focusVisible: {
        _hover: {
          boxShadow: `0 0 0 1px ${color.border.ai}`,
          borderColor: color.border.ai
        }
      }
    })
  }
};

const Link = {
  baseStyle: ({ colorScheme }) => ({
    _focus: {
      ring: "2px",
      ringColor: `${colorScheme}.100`,
      ringOffset: "1px"
    }
  }),
  defaultProps: {
    colorScheme: "mediatoolBlue"
  }
};

const Switch$1 = {
  baseStyle: ({ theme: { colors: color, opacity } }) => ({
    _disabled: {
      opacity: opacity.switch.disabled
    },
    track: {
      bgColor: color.background.switch.default,
      _checked: {
        bgColor: color.background.switch["default-checked"]
      },
      _focusVisible: {
        ring: "2px",
        ringColor: color.border.wcag,
        ringOffset: "1px"
      }
    },
    thumb: {
      bgColor: color.background.switch.thumb
    }
  })
};

const Tag$1 = {
  parts: ["container"],
  baseStyle: {
    container: {
      fontWeight: "semibold"
    }
  },
  sizes: {
    sm: {
      container: {
        borderRadius: "tag.default"
      }
    },
    md: {
      container: {
        borderRadius: "tag.default"
      }
    },
    lg: {
      container: {
        borderRadius: "tag.default"
      }
    }
  },
  variants: {
    solid: ({ theme: { colors }, bgColor, colorScheme }) => {
      const tagBgColor = bgColor != null ? bgColor : colors[colorScheme] && colors[colorScheme][500] ? colors[colorScheme][500] : colorScheme;
      const tagColor = getContrastColor(useToken$1("colors", tagBgColor));
      return {
        container: {
          bgColor: tagBgColor,
          color: tagColor
        }
      };
    },
    subtle: ({ theme: { colors }, colorScheme, bgColor }) => {
      const tagBgColor = bgColor != null ? bgColor : colors[colorScheme] && colors[colorScheme][100] ? colors[colorScheme][100] : colorScheme;
      const tagColor = getContrastColor(useToken$1("colors", tagBgColor));
      return {
        container: {
          bgColor: tagBgColor,
          color: tagColor
        }
      };
    },
    ai: {
      container: {
        bgColor: "bg.ai.default",
        color: "text.inverted"
      }
    }
  },
  defaultProps: {
    size: "md",
    colorScheme: "background.tag.default"
  }
};

const Alert = {
  parts: ["container", "title", "description"],
  baseStyle: ({ theme: {
    radii: borderRadius,
    colors: color,
    space: coreSpacing
  } }) => ({
    container: {
      borderRadius: borderRadius.toast.default,
      color: color.text.default,
      paddingEnd: coreSpacing[8],
      width: "auto",
      display: "flex"
    }
  }),
  variants: {
    success: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.background.toast.success
      }
    }),
    warning: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.background.toast.warning
      }
    }),
    info: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.background.toast.info
      }
    }),
    error: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.background.toast.error,
        color: color.text.toast.error
      }
    }),
    ai: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.bg.ai.default,
        color: color.text.inverted
      }
    }),
    default: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.bg.layer,
        color: color.text.default
      }
    }),
    ghost: ({ theme: { colors: color } }) => ({
      container: {
        bgColor: color.bg.base,
        color: color.text.default,
        borderWidth: "xs",
        borderColor: color.border.default,
        borderStyle: "solid"
      }
    })
  }
};

const NumberInput$1 = {
  parts: ["root", "field", "stepper", "stepperGroup"],
  sizes: {
    sm: ({ theme: { radii: borderRadius, sizes: sizing } }) => ({
      field: {
        borderRadius: borderRadius.input.outline
      },
      stepperGroup: {
        height: sizing["8"]
      }
    }),
    md: ({ theme: { sizes: sizing } }) => ({
      stepperGroup: {
        height: sizing["10"]
      }
    }),
    lg: ({ theme: { sizes: sizing } }) => ({
      stepperGroup: {
        height: sizing["12"]
      }
    })
  },
  baseStyle: ({ theme: {
    sizes: sizing,
    space: spacing,
    colors: color,
    radii: borderRadius,
    borders: borderWidth,
    opacity
  }, isReadOnly }) => ({
    root: {
      borderRadius: borderRadius.input.outline
    },
    field: {
      minWidth: sizing["44"],
      paddingInlineStart: spacing["padding-inline"].input.default,
      paddingInlineEnd: spacing["padding-inline"].input.default,
      WebkitPaddingStart: spacing["padding-inline"].input.default,
      WebkitPaddingEnd: spacing["padding-inline"].input.default,
      color: color.text.default,
      bg: color.background.input["outline-default"],
      borderWidth: borderWidth.input.default,
      borderColor: color.border.input.default,
      paddingRight: spacing.paddingRight["number-input"].field,
      _hover: {
        bg: color.background.input["outline-hover"],
        borderColor: color.border.input["default-hover"]
      },
      _focusVisible: {
        bg: color.background.input["outline-focus"],
        borderColor: color.border.input.focus,
        boxShadow: `0 0 0 1px ${color.border.textarea.focus}`
      },
      _invalid: {
        bg: color.background.input["outline-error"],
        borderColor: color.border.input.error,
        boxShadow: `0 0 0 1px ${color.border.input.error}`
      },
      _disabled: {
        bg: color.background.input["outline-disabled"],
        opacity: opacity.input.disabled,
        borderColor: color.border.input.disabled
      },
      _readOnly: {
        _focusVisible: {
          borderColor: color.border.input.readonly,
          boxShadow: "none"
        },
        _hover: {
          borderColor: color.border.input.readonly
        }
      }
    },
    stepperGroup: {
      width: "auto",
      paddingRight: spacing.paddingRight["number-input"].stepper
    },
    stepper: {
      _first: {
        border: "none",
        borderTopRightRadius: borderRadius["input-stepper"].default,
        borderRadius: borderRadius["input-stepper"].default,
        bg: color.background["input-stepper"].default,
        opacity: isReadOnly ? opacity.input.disabled : "auto",
        _hover: {
          bg: isReadOnly ? "none" : color.background["input-stepper"].hover
        },
        _active: {
          bg: color.background["input-stepper"].active
        },
        _disabled: {
          bg: color.background["input-stepper"].disabled,
          color: color.icon["input-stepper"].disabled
        }
      },
      _last: {
        border: "none",
        bg: color.background["input-stepper"].default,
        borderBottomRightRadius: borderRadius["input-stepper"].default,
        borderRadius: borderRadius["input-stepper"].default,
        opacity: isReadOnly ? opacity.input.disabled : "auto",
        _hover: {
          bg: isReadOnly ? "none" : color.background["input-stepper"].hover
        },
        _active: {
          bg: color.background["input-stepper"].active
        },
        _disabled: {
          bg: color.background["input-stepper"].disabled,
          color: color.icon["input-stepper"].disabled
        }
      }
    }
  })
};

const NotificationIconButton$1 = {
  parts: ["container", "notifier"],
  sizes: {
    xs: {
      notifier: {
        top: "0.5",
        right: "0.5"
      }
    },
    sm: {
      notifier: {
        top: "0.5",
        right: "0.5"
      }
    },
    md: {
      notifier: {
        top: "1",
        right: "1"
      }
    },
    lg: {
      notifier: {
        top: "2",
        right: "2"
      }
    }
  },
  variants: {
    link: {
      notifier: {
        position: "absolute",
        top: "0",
        right: "0",
        zIndex: "base"
      }
    }
  },
  baseStyle: () => ({
    container: {
      position: "relative"
    },
    notifier: {
      position: "absolute",
      top: "1",
      right: "1",
      zIndex: "base"
    }
  })
};

var __defProp$1I = Object.defineProperty;
var __getOwnPropSymbols$1I = Object.getOwnPropertySymbols;
var __hasOwnProp$1I = Object.prototype.hasOwnProperty;
var __propIsEnum$1I = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1I = (obj, key, value) => key in obj ? __defProp$1I(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1I = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1I.call(b, prop))
      __defNormalProp$1I(a, prop, b[prop]);
  if (__getOwnPropSymbols$1I)
    for (var prop of __getOwnPropSymbols$1I(b)) {
      if (__propIsEnum$1I.call(b, prop))
        __defNormalProp$1I(a, prop, b[prop]);
    }
  return a;
};
const Calendar$1 = {
  parts: ["container", "dateSelect", "dayLabel", "rangeCalendarContainer"],
  baseStyle: ({ theme: {
    space: spacing,
    sizes: sizing,
    colors: color
  } }) => ({
    container: {
      p: spacing[2],
      w: sizing[64],
      bgColor: "background.default",
      border: "1px solid",
      borderColor: "border.input.default",
      borderRadius: "input.outline"
    },
    rangeCalendarContainer: {
      p: "3",
      w: "128",
      bgColor: "background.default",
      borderRadius: "input.outline"
    },
    dateSelect: __spreadValues$1I({
      fontWeight: "semibold",
      border: "none",
      padding: "1",
      borderRadius: "md",
      color: color.text.default,
      bgColor: color.background.button.ghost,
      _hover: {
        cursor: "pointer",
        bgColor: color.background.button["ghost-hover"]
      },
      _active: {
        bgColor: color.background.button["ghost-active"]
      }
    }, ring),
    dayLabel: {
      color: color.gray[600],
      fontSize: "xs",
      p: spacing[2]
    }
  })
};

const DragAndDrop$1 = {
  parts: ["dropZone"],
  baseStyle: ({ sx }) => ({
    dropZone: merge({
      borderWidth: "sm",
      borderStyle: "dashed",
      borderColor: "border.default",
      padding: "4",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: "4",
      justifyContent: "center",
      textAlign: "center",
      minH: "56",
      minW: "56",
      bgColor: "bg.filled"
    }, sx)
  })
};

const DatePicker$1 = {
  parts: ["group", "styledField", "dateField", "dateSegment"],
  baseStyle: ({ theme: { colors: color, opacity } }) => ({
    group: {
      position: "relative",
      alignItems: "center",
      flex: 1
    },
    styledField: {
      bgColor: "background.default",
      _focusWithin: {
        bgColor: color.background.input["outline-focus"],
        borderColor: color.border.textarea.focus,
        boxShadow: `0 0 0 1px ${color.border.textarea.focus}`
      },
      _invalid: {
        boxShadow: `0 0 0 1px ${color.border.input.error}`,
        borderColor: color.border.input.error
      },
      _disabled: {
        bgColor: color.background.input["outline-disabled"],
        borderColor: color.border.input.disabled,
        opacity: opacity.input.disabled
      }
    },
    dateField: {
      width: "100%",
      height: "100%",
      alignItems: "center"
    },
    dateSegment: {
      caretColor: "transparent",
      boxSizing: "content-box",
      textAlign: "center",
      outline: "none",
      rounded: "md",
      _focus: {
        bgColor: "blue.500",
        color: color.text.inverted
      },
      _placeholder: {
        color: "red.500"
      }
    }
  }),
  variants: {
    outline: ({
      theme: { colors: color, radii: borderRadius, borders: borderWidth }
    }) => ({
      styledField: {
        bgColor: color.background.input["outline-default"],
        borderRadius: borderRadius.input.outline,
        borderWidth: borderWidth.input.default,
        borderColor: color.border.input.default
      }
    }),
    filled: ({
      theme: { colors: color, radii: borderRadius, borders: borderWidth }
    }) => ({
      styledField: {
        bgColor: color.background.input["filled-default"],
        borderRadius: borderRadius.input.filled,
        borderWidth: borderWidth.input.default,
        borderColor: color.background.input["filled-default"]
      }
    })
  }
};

const FlipButton = {
  parts: ["container", "button", "buttonIcon"],
  sizes: {
    xs: ({ theme: { sizes: sizing, space: spacing } }) => ({
      button: {
        height: sizing["flip-button"].xs,
        minWidth: sizing["flip-button"].xs,
        paddingInlineStart: spacing["padding-inline"]["flip-button"].xs,
        paddingInlineEnd: spacing["padding-inline"]["flip-button"].xs,
        fontSize: "xs"
      },
      buttonIcon: {
        boxSize: sizing.icon.xs
      }
    }),
    sm: ({ theme: { sizes: sizing, space: spacing } }) => ({
      button: {
        height: sizing["flip-button"].sm,
        minWidth: sizing["flip-button"].sm,
        paddingInlineStart: spacing["padding-inline"]["flip-button"].md,
        paddingInlineEnd: spacing["padding-inline"]["flip-button"].md,
        fontSize: "sm",
        buttonIcon: {
          boxSize: sizing.icon.sm
        }
      }
    }),
    md: ({ theme: { sizes: sizing, space: spacing } }) => ({
      button: {
        height: sizing["flip-button"].md,
        minWidth: sizing["flip-button"].md,
        paddingInlineStart: spacing["padding-inline"]["flip-button"].md,
        paddingInlineEnd: spacing["padding-inline"]["flip-button"].md,
        fontSize: "md",
        buttonIcon: {
          boxSize: sizing.icon.md
        }
      }
    }),
    lg: ({ theme: { sizes: sizing, space: spacing } }) => ({
      button: {
        height: sizing["flip-button"].lg,
        minWidth: sizing["flip-button"].lg,
        paddingInlineStart: spacing["padding-inline"]["flip-button"].lg,
        paddingInlineEnd: spacing["padding-inline"]["flip-button"].lg,
        fontSize: "lg",
        buttonIcon: {
          boxSize: sizing.icon.lg
        }
      }
    })
  },
  baseStyle: ({ theme: {
    space: spacing,
    sizes: sizing,
    colors: color,
    opacity,
    radii: borderRadius,
    fontWeights: coreFontWeight
  }, numberOfButtons }) => ({
    container: {
      borderRadius: borderRadius["flip-button"].default,
      paddingInlineStart: spacing["padding-inline"]["flip-button-group"].default,
      paddingInlineEnd: spacing["padding-inline"]["flip-button-group"].default,
      paddingY: spacing.paddingY["flip-button-group"].default,
      disply: "grid",
      width: "100%",
      gap: spacing["padding-inline"]["flip-button"].gap,
      gridTemplateColumns: `repeat(${numberOfButtons}, minmax(${sizing[32]}, 1fr))`,
      gridTemplateRows: "1fr",
      overflowX: "auto"
    },
    button: {
      width: "100%",
      justifyContent: "center",
      alignItems: "center",
      color: color.text["flip-button"].default,
      cursor: "pointer",
      borderRadius: borderRadius["flip-button"].default,
      fontWeight: coreFontWeight.semiBold,
      _disabled: {
        opacity: opacity["flip-button"].disabled
      },
      _checked: {
        color: color.text["flip-button"].inverted
      }
    }
  }),
  variants: {
    default: ({ theme: { colors: color }, sx }) => ({
      container: merge({
        bgColor: color.background["flip-button"]["default-deselected-blue"]
      }, sx),
      button: {
        bgColor: color.background["flip-button"]["default-deselected-blue"],
        _hover: {
          bgColor: color.background["flip-button"]["hover-deselected-blue"]
        },
        _checked: {
          bgColor: color.background["flip-button"]["default-selected-blue"],
          _hover: {
            bgColor: color.background["flip-button"]["default-selected-blue"]
          }
        }
      }
    }),
    brand: ({ theme: { colors: color }, sx }) => ({
      container: merge({
        bgColor: color.background["flip-button"]["default-deselected-brand"]
      }, sx),
      button: {
        bgColor: color.background["flip-button"]["default-deselected-brand"],
        _hover: {
          bgColor: color.background["flip-button"]["hover-deselected-brand"]
        },
        _checked: {
          bgColor: color.background["flip-button"]["default-selected-brand"],
          _hover: {
            bgColor: color.background["flip-button"]["default-selected-brand"]
          }
        }
      }
    }),
    ai: ({ theme: { colors: color }, sx }) => ({
      container: merge({
        bgColor: color.background["flip-button"]["default-deselected-brand"]
      }, sx),
      button: {
        bgColor: "transparent",
        _hover: {
          bgColor: "transparent"
        },
        _checked: {
          bgColor: color.bg.ai.default,
          _hover: {
            bgColor: color.bg.ai.default
          }
        }
      }
    })
  },
  defaultProps: {
    size: "md",
    variant: "default"
  }
};

const Spinner = {
  baseStyle: ({ theme: { colors: color, borders: borderWidth } }) => ({
    borderWidth: borderWidth.spinner.default,
    color: color.background.spinner.thumb,
    borderBottomColor: color.background.spinner.track,
    borderLeftColor: color.background.spinner.track
  })
};

const possibleBgColors = getShades(400, 600);
const getAvatarBgColor = (image, name, color) => {
  if (image)
    return color.background.avatar.image;
  if (name)
    return randomColor({ string: name, colors: possibleBgColors });
  return color.background.avatar.default;
};

const Avatar = {
  parts: ["container", "text", "badge", "icon"],
  sizes: {
    "2xs": ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar["2xs"],
        height: sizing.avatar["2xs"]
      },
      text: {
        lineHeight: sizing.avatar["2xs"],
        fontSize: "3xs"
      }
    }),
    xs: ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar.xs,
        height: sizing.avatar.xs
      },
      text: {
        lineHeight: sizing.avatar.xs,
        fontSize: "xs"
      }
    }),
    sm: ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar.sm,
        height: sizing.avatar.sm
      },
      text: {
        lineHeight: sizing.avatar.sm,
        fontSize: "sm"
      },
      icon: {
        boxSize: sizing.avatar.sm
      }
    }),
    md: ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar.md,
        height: sizing.avatar.md
      },
      text: {
        lineHeight: sizing.avatar.md,
        fontSize: "md"
      },
      icon: {
        boxSize: sizing.avatar.md
      }
    }),
    lg: ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar.lg,
        height: sizing.avatar.lg
      },
      text: {
        lineHeight: sizing.avatar.lg,
        fontSize: "lg"
      },
      icon: {
        boxSize: sizing.avatar.lg
      }
    }),
    xl: ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar.xl,
        height: sizing.avatar.xl
      },
      text: {
        lineHeight: sizing.avatar.xl,
        fontSize: "2xl"
      }
    }),
    "2xl": ({ theme: { sizes: sizing } }) => ({
      container: {
        width: sizing.avatar["2xl"],
        height: sizing.avatar["2xl"]
      },
      text: {
        lineHeight: sizing.avatar["2xl"],
        fontSize: "4xl"
      }
    })
  },
  baseStyle: ({ theme: {
    colors: color,
    sizes: sizing,
    radii: borderRadius
  }, image, name }) => {
    const avatarBgColor = getAvatarBgColor(image, name, color);
    return {
      container: {
        bgColor: avatarBgColor,
        color: getContrastColor(avatarBgColor),
        display: "grid",
        placeItems: "center",
        objectFit: "cover",
        position: "relative"
      },
      userImage: {
        width: "100%",
        height: "100%",
        objectFit: "cover"
      },
      badge: {
        position: "absolute",
        bottom: `-${sizing["1"]}`,
        right: `-${sizing["1"]}`,
        minWidth: sizing["5"],
        height: sizing["5"],
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        fontSize: "xs",
        fontWeight: "semibold",
        padding: sizing["0a"],
        bgColor: color.red["500"],
        color: color.text.inverted,
        borderRadius: borderRadius.avatar.square,
        border: "none"
      }
    };
  },
  variants: {
    square: ({ theme: { radii: borderRadius } }) => ({
      container: {
        aspectRatio: "1 / 1",
        borderRadius: borderRadius.avatar.square,
        "> img": {
          borderRadius: borderRadius.avatar.square,
          aspectRatio: "1 / 1"
        }
      },
      badge: {
        borderRadius: borderRadius.avatar.square
      }
    }),
    rounded: ({ theme: { radii: borderRadius } }) => ({
      container: {
        aspectRatio: "1 / 1",
        borderRadius: borderRadius.avatar.rounded,
        "> img": {
          borderRadius: borderRadius.avatar.rounded,
          aspectRatio: "1 / 1"
        }
      },
      badge: {
        borderRadius: borderRadius.avatar.rounded
      }
    })
  }
};

const CloseButton = {
  baseStyle: ({ theme: { colors: color } }) => ({
    color: color.text.default,
    bgColor: color.background.button.ghost,
    _hover: {
      bg: color.background.button["ghost-hover"],
      _disabled: {
        bgColor: color.background.button.ghost
      }
    },
    _active: {
      bgColor: color.background.button["ghost-active"]
    },
    _focusVisible: {
      ring: "2px",
      ringColor: color.border.wcag,
      ringOffset: "1px"
    }
  }),
  defaultProps: {
    size: "md"
  }
};

const Modal$1 = {
  parts: ["overlay", "closeButton", "dialog"],
  sizes: {
    huge: {
      dialog: {
        width: "90%",
        maxW: "96rem",
        aspectRatio: "16/9"
      }
    }
  },
  baseStyle: ({ theme }) => {
    const {
      typography: { headings: { h4 } }
    } = theme;
    return {
      overlay: {
        bgColor: "background.modal.overlay",
        backdropFilter: "blur(8px)"
      },
      closeButton: {
        top: 4,
        right: 4
      },
      dialog: {
        bgColor: "background.default",
        borderRadius: "modal.dialog"
      },
      header: {
        fontSize: h4.fontSize,
        paddingTop: "paddingTop.modal.header",
        paddingBottom: "paddingBottom.modal.header",
        border: "modal.header",
        borderBottomColor: "border.modal.header",
        borderBottomStyle: "solid"
      },
      body: {
        paddingTop: "paddingTop.modal.body",
        paddingBottom: "paddingBottom.modal.body"
      },
      footer: {
        paddingTop: "paddingTop.modal.footer",
        paddingBottom: "paddingBottom.modal.footer"
      }
    };
  }
};

const $arrowBg = cssVar("popper-arrow-bg");
const $arrowBorder = cssVar("popper-arrow-shadow-color");
const Tooltip$1 = {
  baseStyle: ({
    theme: { colors: color, space: spacing, radii: borderRadius }
  }) => ({
    color: color.text.inverted,
    paddingInline: spacing["padding-inline"].tooltip.default,
    paddingY: spacing.paddingY.tooltip.default,
    borderRadius: borderRadius.tooltip.default,
    backgroundColor: color.background.tooltip.default,
    [$arrowBg.variable]: color.background.tooltip.default
  }),
  variants: {
    default: ({ theme: { colors: color } }) => ({
      bgColor: "bg.tertiary.default",
      color: color.text.inverted,
      [$arrowBg.variable]: color.bg.tertiary.default,
      [$arrowBorder.variable]: color.bg.tertiary.default
    }),
    success: ({ theme: { colors: color } }) => ({
      color: "text.over.success",
      bgColor: "success-alt",
      [$arrowBg.variable]: color["success-alt"]
    }),
    info: ({ theme: { colors: color } }) => ({
      color: "text.over.brand",
      bgColor: "brand-alt",
      [$arrowBg.variable]: color["brand-alt"]
    }),
    ghost: ({ theme: { colors: color } }) => ({
      color: "text.default",
      bgColor: color.bg.base,
      borderWidth: "xs",
      borderColor: color.border.default,
      [$arrowBorder.variable]: color.border.default,
      borderStyle: "solid",
      [$arrowBg.variable]: color.bg.base
    }),
    warning: ({ theme: { colors: color } }) => ({
      color: "text.over.warning",
      bgColor: color["info-alt"],
      [$arrowBg.variable]: color["info-alt"]
    }),
    danger: ({ theme: { colors: color } }) => ({
      color: "text.over.error",
      bgColor: color["destructive-alt"],
      [$arrowBg.variable]: color["destructive-alt"]
    }),
    ai: ({ theme: { colors: color } }) => ({
      bgColor: color.bg.ai.default,
      [$arrowBg.variable]: color.bg.ai.default
    })
  }
};

const Icon = {
  sizes: {
    xs: {
      boxSize: "icon.xs"
    },
    sm: {
      boxSize: "icon.sm"
    },
    md: {
      boxSize: "icon.md"
    },
    lg: {
      boxSize: "icon.lg"
    }
  },
  baseStyle: ({ boxSize, color }) => ({
    boxSize: boxSize || "icon.default",
    color: color || "inherit"
  })
};

const ClipboardInput$1 = {
  parts: ["button", "icon", "tooltip"],
  sizes: {
    sm: ({ theme: { sizes: sizing, space: spacing } }) => ({
      button: {
        height: sizing.button.xs,
        minWidth: sizing.button.xs
      },
      icon: {
        boxSize: sizing.icon.xs
      },
      tooltip: {
        paddingInline: spacing["padding-inline"].tooltip.sm,
        paddingY: spacing.paddingY.tooltip.sm
      }
    }),
    md: ({ theme: { sizes: sizing } }) => ({
      button: {
        height: sizing.button.sm,
        minWidth: sizing.button.sm
      },
      icon: {
        boxSize: sizing.icon.sm
      }
    }),
    lg: ({ theme: { sizes: sizing } }) => ({
      button: {
        height: sizing.button.md,
        minWidth: sizing.button.md
      },
      icon: {
        boxSize: sizing.icon.md
      }
    })
  }
};

const ColorPicker = {
  parts: ["colorButton", "trigger", "heading"],
  baseStyle: ({ theme, selectedColor }) => {
    const { sizes: sizing, colors: color } = theme;
    return {
      heading: {
        border: "none",
        paddingInlineStart: sizing["4"],
        paddingInlineEnd: sizing["2"],
        paddingBottom: sizing["0"],
        fontSize: "md",
        fontWeight: "semibold"
      },
      trigger: {
        bgColor: selectedColor != null ? selectedColor : color.background.button.default,
        color: selectedColor ? getContrastColor(selectedColor) : "unset",
        _hover: {
          bgColor: selectedColor != null ? selectedColor : color.background.button["default-hover"]
        },
        _active: {
          bgColor: selectedColor != null ? selectedColor : color.background.button["default-active"]
        }
      },
      colorButton: {
        height: sizing.button.sm,
        minWidth: sizing.button.sm,
        _hover: {
          ring: "2px",
          ringOffset: "1px",
          ringColor: `${color.border.input["default-hover"]}`
        }
      }
    };
  },
  sizes: {
    sm: ({ theme: { sizes: sizing } }) => ({
      trigger: {
        height: sizing.button.sm,
        minWidth: sizing.button.sm
      }
    }),
    md: ({ theme: { sizes: sizing } }) => ({
      trigger: {
        height: sizing.button.md,
        minWidth: sizing.button.md
      }
    }),
    lg: ({ theme: { sizes: sizing } }) => ({
      trigger: {
        height: sizing.button.lg,
        minWidth: sizing.button.lg
      }
    })
  }
};

const Step$1 = {
  parts: ["step", "label", "description"],
  baseStyle: ({ theme: {
    colors: color,
    fontWeights,
    space: spacing,
    borders: borderWidth
  } }) => ({
    step: {
      justifyContent: "start",
      alignItems: "start",
      bgColor: color.background.step.default,
      borderTopWidth: borderWidth.step.default,
      borderColor: color.border.step.default,
      borderBottom: "none",
      paddingInline: spacing["padding-inline"].step.default,
      color: color.text.subdued,
      _hover: {
        bgColor: color.background.step.hover,
        borderColor: color.border.step.hover
      },
      _disabled: {
        cursor: "not-allowed",
        _hover: { borderColor: color.border.step.default }
      },
      _active: {
        bgColor: color.background.step.active
      },
      _selected: {
        bgColor: color.background.step.selected,
        borderColor: color.border.step.selected,
        color: color.border.step.selected,
        _hover: {
          borderColor: color.border.step.selected,
          color: color.border.step.selected
        }
      }
    },
    label: {
      color: "inherit",
      pt: spacing.paddingTop.step.label,
      textAlign: "start",
      fontWeight: fontWeights.bold
    },
    description: {
      textAlign: "start",
      fontWeight: fontWeights.semiBold,
      color: color.text.default
    }
  })
};

const StepList$1 = {
  baseStyle: ({ theme: { sizes: sizing }, tabs }) => ({
    display: "grid",
    width: "100%",
    gridTemplateColumns: `repeat(${tabs}, minmax(${sizing[32]}, 1fr))`,
    gridTemplateRows: "1fr",
    overflowX: "auto",
    borderBottom: "none",
    paddingBottom: sizing[2]
  })
};

const H1 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h1 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h1.fontFamily,
      fontWeight: h1.fontWeight,
      lineHeight: h1.lineHeight,
      fontSize: h1.fontSize,
      letterSpacing: h1.letterSpacing,
      textTransform: h1.textCase
    }, sx);
  }
};

const H2 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h2 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h2.fontFamily,
      fontWeight: h2.fontWeight,
      lineHeight: h2.lineHeight,
      fontSize: h2.fontSize,
      letterSpacing: h2.letterSpacing,
      textTransform: h2.textCase
    }, sx);
  }
};

const H3 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h3 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h3.fontFamily,
      fontWeight: h3.fontWeight,
      lineHeight: h3.lineHeight,
      fontSize: h3.fontSize,
      letterSpacing: h3.letterSpacing,
      textTransform: h3.textCase
    }, sx);
  }
};

const H4 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h4 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h4.fontFamily,
      fontWeight: h4.fontWeight,
      lineHeight: h4.lineHeight,
      fontSize: h4.fontSize,
      letterSpacing: h4.letterSpacing,
      textTransform: h4.textCase
    }, sx);
  }
};

const H5 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h5 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h5.fontFamily,
      fontWeight: h5.fontWeight,
      lineHeight: h5.lineHeight,
      fontSize: h5.fontSize,
      letterSpacing: h5.letterSpacing,
      textTransform: h5.textCase
    }, sx);
  }
};

const H6 = {
  baseStyle: ({ theme, sx }) => {
    const {
      colors: color,
      typography: { headings: { h6 } }
    } = theme;
    return merge({
      color: color.text.default,
      fontFamily: h6.fontFamily,
      fontWeight: h6.fontWeight,
      lineHeight: h6.lineHeight,
      fontSize: h6.fontSize,
      letterSpacing: h6.letterSpacing,
      textTransform: h6.textCase
    }, sx);
  }
};

const Blockquote = {
  baseStyle: ({ theme, sx }) => {
    const { blockquote } = theme.typography.stylized;
    return merge({
      color: "text.default",
      fontFamily: blockquote.fontFamily,
      fontWeight: blockquote.fontWeight,
      lineHeight: blockquote.lineHeight,
      fontSize: blockquote.fontSize,
      letterSpacing: blockquote.letterSpacing,
      textTransform: blockquote.textCase
    }, sx);
  }
};

const Tiny = {
  baseStyle: ({ theme, sx }) => {
    const { tiny } = theme.typography.stylized;
    return merge({
      color: "text.default",
      fontFamily: tiny.fontFamily,
      fontWeight: tiny.fontWeight,
      lineHeight: tiny.lineHeight,
      fontSize: tiny.fontSize,
      letterSpacing: tiny.letterSpacing,
      textTransform: tiny.textCase
    }, sx);
  }
};

const Capitalized = {
  baseStyle: ({ theme, sx }) => {
    const { CAPITALIZED } = theme.typography.stylized;
    return merge({
      color: "text.default",
      fontFamily: CAPITALIZED.fontFamily,
      fontWeight: CAPITALIZED.fontWeight,
      lineHeight: CAPITALIZED.lineHeight,
      fontSize: CAPITALIZED.fontSize,
      letterSpacing: CAPITALIZED.letterSpacing,
      textTransform: CAPITALIZED.textCase
    }, sx);
  }
};

const Lead = {
  baseStyle: ({ theme, sx }) => {
    const { lead } = theme.typography.stylized;
    return merge({
      color: "text.default",
      fontFamily: lead.fontFamily,
      fontWeight: lead.fontWeight,
      lineHeight: lead.lineHeight,
      fontSize: lead.fontSize,
      letterSpacing: lead.letterSpacing,
      textTransform: lead.textCase
    }, sx);
  }
};

const Small = {
  baseStyle: ({ theme, sx }) => {
    const { small } = theme.typography.stylized;
    return merge({
      color: "text.default",
      fontFamily: small.fontFamily,
      fontWeight: small.fontWeight,
      lineHeight: small.lineHeight,
      fontSize: small.fontSize,
      letterSpacing: small.letterSpacing,
      textTransform: small.textCase
    }, sx);
  }
};

const P = {
  variants: {
    14: ({ theme, sx }) => {
      const { body14 } = theme.typography.body;
      return merge({
        fontFamily: body14.fontFamily,
        fontWeight: body14.fontWeight,
        lineHeight: body14.lineHeight,
        fontSize: body14.fontSize,
        letterSpacing: body14.letterSpacing,
        textTransform: body14.textCase
      }, sx);
    },
    16: ({ theme, sx }) => {
      const { body16 } = theme.typography.body;
      return merge({
        fontFamily: body16.fontFamily,
        fontWeight: body16.fontWeight,
        lineHeight: body16.lineHeight,
        fontSize: body16.fontSize,
        letterSpacing: body16.letterSpacing,
        textTransform: body16.textCase
      }, sx);
    }
  },
  baseStyle: {
    color: "text.default"
  }
};

const Label = {
  baseStyle: ({ theme: { sizes: sizing }, sx }) => merge({
    color: "inherit",
    width: "100%",
    maxWidth: "100%",
    marginBottom: sizing[0],
    marginInlineStart: sizing[0],
    marginEnd: sizing[0],
    marginInlineEnd: sizing[0]
  }, sx),
  sizes: {
    "2xs": ({ theme, sx }) => {
      const { tinyLabel } = theme.typography.labels;
      return merge({
        fontFamily: tinyLabel.fontFamily,
        fontWeight: tinyLabel.fontWeight,
        lineHeight: tinyLabel.lineHeight,
        fontSize: tinyLabel.fontSize,
        letterSpacing: tinyLabel.letterSpacing,
        textTransform: tinyLabel.textCase
      }, sx);
    },
    xs: ({ theme, sx }) => {
      const { xsLabel } = theme.typography.labels;
      return merge({
        fontFamily: xsLabel.fontFamily,
        fontWeight: xsLabel.fontWeight,
        lineHeight: xsLabel.lineHeight,
        fontSize: xsLabel.fontSize,
        letterSpacing: xsLabel.letterSpacing,
        textTransform: xsLabel.textCase
      }, sx);
    },
    sm: ({ theme, sx }) => {
      const { smLabel } = theme.typography.labels;
      return merge({
        fontFamily: smLabel.fontFamily,
        fontWeight: smLabel.fontWeight,
        lineHeight: smLabel.lineHeight,
        fontSize: smLabel.fontSize,
        letterSpacing: smLabel.letterSpacing,
        textTransform: smLabel.textCase
      }, sx);
    },
    md: ({ theme, sx }) => {
      const { mdLabel } = theme.typography.labels;
      return merge({
        fontFamily: mdLabel.fontFamily,
        fontWeight: mdLabel.fontWeight,
        lineHeight: mdLabel.lineHeight,
        fontSize: mdLabel.fontSize,
        letterSpacing: mdLabel.letterSpacing,
        textTransform: mdLabel.textCase
      }, sx);
    },
    lg: ({ theme, sx }) => {
      const { lgLabel } = theme.typography.labels;
      return merge({
        fontFamily: lgLabel.fontFamily,
        fontWeight: lgLabel.fontWeight,
        lineHeight: lgLabel.lineHeight,
        fontSize: lgLabel.fontSize,
        letterSpacing: lgLabel.letterSpacing,
        textTransform: lgLabel.textCase
      }, sx);
    }
  }
};

const NumVal = {
  baseStyle: ({ theme: { sizes: sizing }, sx }) => merge(
    {
      color: "inherit",
      width: "100%",
      maxWidth: "100%",
      marginBottom: sizing[0],
      marginInlineStart: sizing[0],
      marginEnd: sizing[0],
      marginInlineEnd: sizing[0]
    },
    sx
  ),
  sizes: {
    "2xs": ({ theme, sx }) => {
      const { tinyMono } = theme.typography.numVal;
      return merge(
        {
          fontFamily: tinyMono.fontFamily,
          fontWeight: tinyMono.fontWeight,
          lineHeight: tinyMono.lineHeight,
          fontSize: tinyMono.fontSize,
          letterSpacing: tinyMono.letterSpacing,
          textTransform: tinyMono.textCase,
          textDecoration: tinyMono.textDecoration
        },
        sx
      );
    },
    xs: ({ theme, sx }) => {
      const { xsMono } = theme.typography.numVal;
      return merge(
        {
          fontFamily: xsMono.fontFamily,
          fontWeight: xsMono.fontWeight,
          lineHeight: xsMono.lineHeight,
          fontSize: xsMono.fontSize,
          letterSpacing: xsMono.letterSpacing,
          textTransform: xsMono.textCase,
          textDecoration: xsMono.textDecoration
        },
        sx
      );
    },
    sm: ({ theme, sx }) => {
      const { smMono } = theme.typography.numVal;
      return merge(
        {
          fontFamily: smMono.fontFamily,
          fontWeight: smMono.fontWeight,
          lineHeight: smMono.lineHeight,
          fontSize: smMono.fontSize,
          letterSpacing: smMono.letterSpacing,
          textTransform: smMono.textCase,
          textDecoration: smMono.textDecoration
        },
        sx
      );
    },
    md: ({ theme, sx }) => {
      const { mdMono } = theme.typography.numVal;
      return merge(
        {
          fontFamily: mdMono.fontFamily,
          fontWeight: mdMono.fontWeight,
          lineHeight: mdMono.lineHeight,
          fontSize: mdMono.fontSize,
          letterSpacing: mdMono.letterSpacing,
          textTransform: mdMono.textCase,
          textDecoration: mdMono.textDecoration
        },
        sx
      );
    },
    lg: ({ theme, sx }) => {
      const { lgMono } = theme.typography.numVal;
      return merge(
        {
          fontFamily: lgMono.fontFamily,
          fontWeight: lgMono.fontWeight,
          lineHeight: lgMono.lineHeight,
          fontSize: lgMono.fontSize,
          letterSpacing: lgMono.letterSpacing,
          textTransform: lgMono.textCase,
          textDecoration: lgMono.textDecoration
        },
        sx
      );
    }
  }
};

const SplitPane$1 = {
  baseStyle: ({ minLeftWidth, minRightWidth, initialSplit, isOpen }) => ({
    display: "grid",
    overflow: "hidden",
    gridTemplateColumns: !isOpen ? "1fr" : `minmax(${minLeftWidth}%, var(--split-pos, ${initialSplit}%)) auto minmax(${minRightWidth}%, 1fr)`,
    alignItems: "stretch",
    justifyItems: "stretch",
    height: "100%",
    width: "100%"
  })
};
const PaneDivider$1 = {
  baseStyle: ({ theme: { colors: color, sizes: sizing } }) => ({
    bgColor: color.background["pane-divider"].default,
    zIndex: 300,
    cursor: "col-resize",
    height: "100%",
    width: sizing[1],
    _hover: {
      outlineColor: color.border["pane-divider"].hover,
      outlineWidth: sizing["0a"],
      outlineStyle: "solid"
    },
    _active: {
      outlineColor: color.border["pane-divider"].hover,
      outlineWidth: sizing["0a"],
      outlineStyle: "solid"
    }
  })
};

const Carousel$1 = {
  parts: ["container", "arrow", "radio"],
  baseStyle: {
    container: {
      display: "grid",
      placeItems: "center",
      position: "relative",
      overflow: "hidden",
      width: "full",
      height: "full"
    },
    radio: {
      position: "absolute",
      bottom: "1",
      left: "50%",
      transform: "translateX(-50%)",
      overflowX: "scroll",
      maxWidth: "90%",
      padding: "2"
    },
    arrow: {
      position: "absolute",
      bottom: "0",
      height: "100%",
      cursor: "pointer"
    }
  }
};

const EditableText$1 = {
  parts: ["button", "icon", "controls", "preview", "input"],
  sizes: {
    sm: ({ isEditing, theme: { sizes: sizing } }) => ({
      button: {
        height: sizing.button.xs,
        minWidth: sizing.button.xs
      },
      icon: {
        boxSize: sizing.icon.xs
      },
      controls: {
        width: !isEditing ? 6 : "3.25rem"
      },
      preview: {
        pt: 1
      },
      input: {
        paddingInlineEnd: 16,
        paddingRight: 16
      }
    }),
    md: ({ isEditing, theme: { sizes: sizing } }) => ({
      button: {
        height: sizing.button.sm,
        minWidth: sizing.button.sm
      },
      icon: {
        boxSize: sizing.icon.sm
      },
      controls: {
        width: !isEditing ? 8 : "4.25rem"
      },
      preview: {
        pt: "7px"
      },
      input: {
        paddingInlineEnd: 20,
        paddingRight: 20
      }
    }),
    lg: ({ isEditing, theme: { sizes: sizing } }) => ({
      button: {
        height: sizing.button.md,
        minWidth: sizing.button.md
      },
      icon: {
        boxSize: sizing.icon.md
      },
      controls: {
        width: !isEditing ? 10 : "5.25rem"
      },
      preview: {
        pt: "8px"
      },
      input: {
        paddingInlineEnd: 24,
        paddingRight: 24
      }
    })
  },
  baseStyle: ({ value }) => ({
    controls: {
      mr: 1
    },
    preview: {
      fontWeight: "semibold",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
      paddingTop: 0,
      paddingBottom: 0,
      color: isNil(value) || isEmpty(value) ? "text.subdued" : "text.default"
    },
    input: {
      fontWeight: "semibold"
    }
  })
};

const Toolbox$1 = {
  parts: ["container", "header", "body", "footer"],
  baseStyle: ({ theme: { sizes: sizing } }) => ({
    container: {
      position: "relative",
      bg: "text.inverted",
      h: "100vh",
      borderLeftWidth: "1px",
      borderLeftStyle: "solid",
      borderLeftColor: "gray.100"
    },
    header: {
      alignItems: "center",
      height: "16",
      borderBottomWidth: "1px",
      borderBottomStyle: "solid",
      borderBottomColor: "gray.100",
      pl: "4",
      pr: "16"
    },
    footer: {
      position: "absolute",
      bottom: "0",
      w: "full",
      p: "4",
      alignItems: "center",
      height: "16",
      borderTopWidth: "1px",
      borderTopStyle: "solid",
      borderTopColor: "gray.100"
    },
    body: {
      p: sizing["4"],
      flexDirection: "column",
      w: "100%",
      h: "100%",
      maxH: `calc(100vh - ${sizing["16"]} * 2)`,
      overflowY: "scroll"
    }
  }),
  sizes: {
    sm: {
      container: {
        w: "xs"
      }
    },
    md: {
      container: {
        w: "md"
      }
    },
    lg: {
      container: {
        w: "xl"
      }
    }
  }
};

var __defProp$1H = Object.defineProperty;
var __getOwnPropSymbols$1H = Object.getOwnPropertySymbols;
var __hasOwnProp$1H = Object.prototype.hasOwnProperty;
var __propIsEnum$1H = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1H = (obj, key, value) => key in obj ? __defProp$1H(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1H = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1H.call(b, prop))
      __defNormalProp$1H(a, prop, b[prop]);
  if (__getOwnPropSymbols$1H)
    for (var prop of __getOwnPropSymbols$1H(b)) {
      if (__propIsEnum$1H.call(b, prop))
        __defNormalProp$1H(a, prop, b[prop]);
    }
  return a;
};
const shakeAnimation = keyframes`
  0% { transform: translate(1px, 1px) rotate(0deg); }
  10% { transform: translate(-1px, -2px) rotate(-1deg); }
  20% { transform: translate(-3px, 0px) rotate(1deg); }
  30% { transform: translate(3px, 2px) rotate(0deg); }
  40% { transform: translate(1px, -1px) rotate(1deg); }
  50% { transform: translate(-1px, 2px) rotate(-1deg); }
  60% { transform: translate(-3px, 1px) rotate(0deg); }
  70% { transform: translate(3px, 1px) rotate(-1deg); }
  80% { transform: translate(-1px, -1px) rotate(1deg); }
  90% { transform: translate(1px, 2px) rotate(0deg); }
  100% { transform: translate(1px, -2px) rotate(-1deg); }
`;
const thickRing = {
  _focusVisible: {
    outline: "none",
    ring: "3px",
    ringColor: "border.wcag",
    ringOffset: "1px"
  }
};
const getBgColor = (currentTheme) => {
  switch (currentTheme) {
    case "webappTheme":
      return "blue.50";
    case "tottTheme":
      return "blue.900";
    default:
      return "bg.filled";
  }
};
const getInvalidColorStyles = (isInvalid, isImage = true, currentTheme = "webappTheme") => ({
  borderColor: isInvalid ? "red.500" : "gray.300",
  bgColor: isInvalid && "red.50",
  animation: isInvalid && `500ms ${shakeAnimation} ease`,
  _hover: isImage && {
    bgColor: isInvalid ? "red.50" : getBgColor(currentTheme),
    borderColor: isInvalid ? "red.500" : "blue.500"
  }
});
const getAiColorStyles = (isInvalid, isImage = true) => ({
  borderColor: isInvalid ? "red.500" : "gray.300",
  bgColor: isInvalid && "red.50",
  animation: isInvalid && `500ms ${shakeAnimation} ease`,
  _hover: isImage && {
    bgColor: isInvalid ? "red.50" : "bg.filled",
    borderColor: isInvalid ? "red.500" : "border.ai"
  }
});
const FilePicker$1 = {
  parts: ["filePicker", "fileItem", "multiFilePicker"],
  baseStyle: ({ theme: { sizes, colors }, hasLoaded, isImage, isInvalid, currentTheme }) => ({
    filePicker: __spreadValues$1H(__spreadValues$1H({
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      width: "full",
      height: "40",
      textAlign: "center",
      position: "relative",
      borderWidth: hasLoaded && isImage ? "0" : sizes["0a"],
      borderStyle: "dashed",
      borderRadius: "lg"
    }, getInvalidColorStyles(isInvalid, isImage, currentTheme)), thickRing),
    multiFilePicker: __spreadValues$1H(__spreadValues$1H({
      width: "full",
      maxWidth: "inherit",
      height: "32",
      position: "relative",
      borderWidth: sizes["0a"],
      borderStyle: "dashed",
      borderRadius: "lg"
    }, getInvalidColorStyles(isInvalid, void 0, currentTheme)), thickRing),
    fileItem: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      paddingX: "2",
      paddingY: "1",
      borderRadius: sizes["2"],
      textAlign: "center",
      position: "relative",
      border: `2px solid ${colors.gray["100"]}`,
      minHeight: "20"
    }
  }),
  variants: {
    ai: ({ isInvalid }) => ({
      filePicker: __spreadValues$1H({}, getAiColorStyles(isInvalid)),
      multiFilePicker: __spreadValues$1H({}, getAiColorStyles(isInvalid))
    })
  }
};

const Table$1 = {
  parts: ["table", "th", "td"],
  variants: {
    rounded: () => ({
      table: {
        borderSpacing: "0",
        borderCollapse: "separate",
        borderRadius: "md",
        borderColor: "border.default",
        borderWidth: "xs",
        px: "3"
      },
      th: {
        color: "text.subdued",
        fontWeight: "bold",
        textTransform: "none",
        fontSize: "sm"
      },
      td: {
        borderColor: "border.default",
        borderTopWidth: "xs"
      }
    })
  }
};

const Menu$1 = {
  parts: ["list", "item"],
  baseStyle: ({ theme: {
    colors: color,
    radii: borderRadius
  } }) => ({
    menu: {
      borderColor: color.border.default
    },
    list: {
      px: "2",
      bgColor: color.bg.base
    },
    item: {
      py: "2",
      color: color.text.default,
      borderRadius: borderRadius.select.default,
      bgColor: color.bg.base,
      _hover: {
        bgColor: color.background.button.default
      },
      _active: {
        bgColor: color.background.button.default
      },
      _focus: {
        bgColor: color.background.button.default
      },
      _checked: {
        fontWeight: "bold"
      }
    }
  }),
  variants: {
    compact: ({ theme: { colors: color } }) => ({
      item: {
        fontSize: "sm",
        color: color.text.default
      }
    }),
    relaxed: ({ theme: { colors: color } }) => ({
      item: {
        py: "2",
        fontSize: "md",
        color: color.text.default
      }
    })
  }
};

const Badge = {
  baseStyle: ({ colorScheme, theme: { colors } }) => {
    const bgColor = colorScheme === "mediatoolBlue" ? colors[colorScheme][100] : colors[colorScheme] && colors[colorScheme][100];
    const textColor = colorScheme === "mediatoolBlue" ? colors[colorScheme][800] : colors[colorScheme] && colors[colorScheme][800];
    return {
      bgColor,
      color: textColor
    };
  },
  variants: {
    solid: ({ colorScheme, theme: { colors } }) => {
      const bgColor = colorScheme === "mediatoolBlue" ? colors[colorScheme][500] : colors[colorScheme] && colors[colorScheme][500];
      return {
        bgColor,
        color: getContrastColor(bgColor != null ? bgColor : useToken$1("colors", colorScheme))
      };
    },
    outline: ({ colorScheme, theme: { colors } }) => {
      const textColor = colorScheme === "mediatoolBlue" ? colors[colorScheme][500] : colors[colorScheme] && colors[colorScheme][700];
      return {
        bgColor: "mono.transparent",
        color: textColor
      };
    }
  }
};

const Popover = {
  parts: ["popper"],
  baseStyle: {
    popper: {
      zIndex: "popover"
    }
  }
};

var components = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Alert: Alert,
  Avatar: Avatar,
  Badge: Badge,
  Blinker: Blinker,
  Blockquote: Blockquote,
  Breadcrumb: Breadcrumb,
  Button: Button,
  Calendar: Calendar$1,
  Capitalized: Capitalized,
  Carousel: Carousel$1,
  Checkbox: Checkbox,
  ClipboardInput: ClipboardInput$1,
  CloseButton: CloseButton,
  ColorPicker: ColorPicker,
  DatePicker: DatePicker$1,
  DragAndDrop: DragAndDrop$1,
  EditableText: EditableText$1,
  FilePicker: FilePicker$1,
  FlipButton: FlipButton,
  H1: H1,
  H2: H2,
  H3: H3,
  H4: H4,
  H5: H5,
  H6: H6,
  Icon: Icon,
  Input: Input,
  Label: Label,
  Lead: Lead,
  Link: Link,
  Menu: Menu$1,
  Modal: Modal$1,
  NotificationIconButton: NotificationIconButton$1,
  NumVal: NumVal,
  NumberInput: NumberInput$1,
  P: P,
  PaneDivider: PaneDivider$1,
  PinInput: PinInput$1,
  Popover: Popover,
  Radio: Radio$1,
  Select: Select$1,
  Small: Small,
  Spinner: Spinner,
  SplitPane: SplitPane$1,
  Step: Step$1,
  StepList: StepList$1,
  Switch: Switch$1,
  Table: Table$1,
  Tabs: Tabs$1,
  Tag: Tag$1,
  Textarea: Textarea$1,
  Tiny: Tiny,
  Toolbox: Toolbox$1,
  Tooltip: Tooltip$1
});

var __defProp$1G = Object.defineProperty;
var __defProps$p = Object.defineProperties;
var __getOwnPropDescs$p = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1G = Object.getOwnPropertySymbols;
var __hasOwnProp$1G = Object.prototype.hasOwnProperty;
var __propIsEnum$1G = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1G = (obj, key, value) => key in obj ? __defProp$1G(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1G = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1G.call(b, prop))
      __defNormalProp$1G(a, prop, b[prop]);
  if (__getOwnPropSymbols$1G)
    for (var prop of __getOwnPropSymbols$1G(b)) {
      if (__propIsEnum$1G.call(b, prop))
        __defNormalProp$1G(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$p = (a, b) => __defProps$p(a, __getOwnPropDescs$p(b));
const WebappSkin = {
  colors: __spreadProps$p(__spreadValues$1G(__spreadValues$1G({}, WebappSystemTokensSet.st.color), WebappComponentsTokensSet.color), {
    text: __spreadValues$1G(__spreadValues$1G({}, WebappSystemTokensSet.st.color.text), WebappComponentsTokensSet.color.text),
    border: __spreadValues$1G(__spreadValues$1G({}, WebappSystemTokensSet.st.color.border), WebappComponentsTokensSet.color.border)
  }),
  sizes: WebappComponentsTokensSet.sizing,
  space: WebappComponentsTokensSet.spacing,
  radii: __spreadValues$1G(__spreadValues$1G({}, WebappSystemTokensSet.st.borderRadius), WebappComponentsTokensSet.borderRadius),
  borders: __spreadValues$1G(__spreadValues$1G({}, WebappSystemTokensSet.st.borderWidth), WebappComponentsTokensSet.borderWidth),
  opacity: WebappComponentsTokensSet.opacity,
  typography,
  shadows: __spreadValues$1G({}, WebappSystemTokensSet.st.boxShadow)
};

var __defProp$1F = Object.defineProperty;
var __defProps$o = Object.defineProperties;
var __getOwnPropDescs$o = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1F = Object.getOwnPropertySymbols;
var __hasOwnProp$1F = Object.prototype.hasOwnProperty;
var __propIsEnum$1F = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1F = (obj, key, value) => key in obj ? __defProp$1F(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1F = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1F.call(b, prop))
      __defNormalProp$1F(a, prop, b[prop]);
  if (__getOwnPropSymbols$1F)
    for (var prop of __getOwnPropSymbols$1F(b)) {
      if (__propIsEnum$1F.call(b, prop))
        __defNormalProp$1F(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$o = (a, b) => __defProps$o(a, __getOwnPropDescs$o(b));
const TottSkin = {
  colors: __spreadProps$o(__spreadValues$1F(__spreadValues$1F({}, TottSystemTokensSet.st.color), TottComponentsTokensSet.color), {
    border: __spreadValues$1F(__spreadValues$1F({}, TottSystemTokensSet.st.color.border), TottComponentsTokensSet.color.border)
  }),
  sizes: TottComponentsTokensSet.sizing,
  space: TottComponentsTokensSet.spacing,
  radii: __spreadValues$1F(__spreadValues$1F({}, TottSystemTokensSet.st.borderRadius), TottComponentsTokensSet.borderRadius),
  borders: __spreadValues$1F(__spreadValues$1F({}, TottSystemTokensSet.st.borderWidth), TottComponentsTokensSet.borderWidth),
  opacity: TottComponentsTokensSet.opacity,
  typography,
  shadows: __spreadValues$1F({}, TottSystemTokensSet.st.boxShadow)
};

var __defProp$1E = Object.defineProperty;
var __getOwnPropSymbols$1E = Object.getOwnPropertySymbols;
var __hasOwnProp$1E = Object.prototype.hasOwnProperty;
var __propIsEnum$1E = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1E = (obj, key, value) => key in obj ? __defProp$1E(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1E = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1E.call(b, prop))
      __defNormalProp$1E(a, prop, b[prop]);
  if (__getOwnPropSymbols$1E)
    for (var prop of __getOwnPropSymbols$1E(b)) {
      if (__propIsEnum$1E.call(b, prop))
        __defNormalProp$1E(a, prop, b[prop]);
    }
  return a;
};
const overrides = {
  config: {
    cssVarPrefix: ""
  },
  semanticTokens: {
    colors: {
      "chakra-body-text": {
        _light: "text.default",
        _dark: "text.inverted"
      }
    }
  },
  styles: {
    global: __spreadValues$1E({
      html: {
        scrollBehavior: "smooth"
      },
      body: {
        height: "100%"
      },
      "#app": {
        height: "100%"
      }
    }, scrollbarStyles)
  },
  fonts: {
    heading: "Inter, sans-serif",
    body: "Inter, sans-serif"
  },
  components: __spreadValues$1E({}, components),
  colors: palette,
  zIndices: coreZIndex,
  sizes: coreSizing,
  space: coreSpacing,
  fontWeights: coreFontWeight,
  shadows: coreBoxShadow,
  fontSizes: coreFontSize,
  lineHeights: coreLineHeight,
  radii: coreBorderRadius,
  borderWidths: WebappSkin.borders
};
const theme = extendTheme(overrides, WebappSkin);
const tottTheme = extendTheme(overrides, TottSkin);

var __defProp$1D = Object.defineProperty;
var __getOwnPropSymbols$1D = Object.getOwnPropertySymbols;
var __hasOwnProp$1D = Object.prototype.hasOwnProperty;
var __propIsEnum$1D = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1D = (obj, key, value) => key in obj ? __defProp$1D(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1D = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1D.call(b, prop))
      __defNormalProp$1D(a, prop, b[prop]);
  if (__getOwnPropSymbols$1D)
    for (var prop of __getOwnPropSymbols$1D(b)) {
      if (__propIsEnum$1D.call(b, prop))
        __defNormalProp$1D(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1f = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1D.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1D)
    for (var prop of __getOwnPropSymbols$1D(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1D.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const hoverAndActiveStyles = {
  borderLeftColor: theme.colors.border["pane-divider"].hover
};
const ResizeHandle = forwardRef$1(
  (_a, ref) => {
    var _b = _a, { color } = _b, rest = __objRest$1f(_b, ["color"]);
    return /* @__PURE__ */ React.createElement(
      Box,
      __spreadValues$1D({
        ref,
        cursor: "col-resize",
        _hover: hoverAndActiveStyles,
        _active: hoverAndActiveStyles,
        transition: "border 250ms linear",
        h: "inherit",
        w: "1",
        borderLeftWidth: "lg",
        borderLeftStyle: "solid",
        borderColor: color != null ? color : "transparent",
        zIndex: "docked"
      }, rest)
    );
  }
);

var __defProp$1C = Object.defineProperty;
var __defProps$n = Object.defineProperties;
var __getOwnPropDescs$n = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1C = Object.getOwnPropertySymbols;
var __hasOwnProp$1C = Object.prototype.hasOwnProperty;
var __propIsEnum$1C = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1C = (obj, key, value) => key in obj ? __defProp$1C(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1C = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1C.call(b, prop))
      __defNormalProp$1C(a, prop, b[prop]);
  if (__getOwnPropSymbols$1C)
    for (var prop of __getOwnPropSymbols$1C(b)) {
      if (__propIsEnum$1C.call(b, prop))
        __defNormalProp$1C(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$n = (a, b) => __defProps$n(a, __getOwnPropDescs$n(b));
const Trigger = (props) => {
  const { isDisabled, handleClick } = props;
  const ref = useRef(null);
  const { buttonProps } = useButton(props, ref);
  return /* @__PURE__ */ React.createElement(
    Button$1,
    __spreadProps$n(__spreadValues$1C({}, buttonProps), {
      ref,
      size: "sm",
      boxSize: 8,
      variant: "ghost",
      isDisabled,
      onPointerDown: handleClick,
      pointerEvents: isDisabled ? "none" : "auto"
    }),
    /* @__PURE__ */ React.createElement(Icon$1, { as: CalendarDuo })
  );
};

var __defProp$1B = Object.defineProperty;
var __defProps$m = Object.defineProperties;
var __getOwnPropDescs$m = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1B = Object.getOwnPropertySymbols;
var __hasOwnProp$1B = Object.prototype.hasOwnProperty;
var __propIsEnum$1B = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1B = (obj, key, value) => key in obj ? __defProp$1B(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1B = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1B.call(b, prop))
      __defNormalProp$1B(a, prop, b[prop]);
  if (__getOwnPropSymbols$1B)
    for (var prop of __getOwnPropSymbols$1B(b)) {
      if (__propIsEnum$1B.call(b, prop))
        __defNormalProp$1B(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$m = (a, b) => __defProps$m(a, __getOwnPropDescs$m(b));
const DateSegment = ({ segment, state }) => {
  const ref = useRef(null);
  const { segmentProps } = useDateSegment(segment, state, ref);
  const isDivider = segment.type === "literal";
  const { dateSegment } = useMultiStyleConfig("DatePicker");
  const minWidth = `${String(segment.maxValue).length}ch`;
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadProps$m(__spreadValues$1B({}, segmentProps), {
      ref,
      __css: dateSegment,
      minWidth: isDivider ? 0 : minWidth,
      paddingInline: isDivider ? 0 : "0.25rem",
      color: segment.isPlaceholder ? "gray.500" : isDivider ? "text.subduded" : "text.default",
      fontSize: "md"
    }),
    segment.text
  );
};

const mapFormat = {
  y: "yyyy",
  m: "mm",
  d: "dd"
};
const formatQuery = (query) => mapFormat[toLower(query)[0]];
const delimeterIncluded = /([.,:;|\-/\\])/;

var __defProp$1A = Object.defineProperty;
var __defProps$l = Object.defineProperties;
var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1A = Object.getOwnPropertySymbols;
var __hasOwnProp$1A = Object.prototype.hasOwnProperty;
var __propIsEnum$1A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1A = (obj, key, value) => key in obj ? __defProp$1A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1A = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1A.call(b, prop))
      __defNormalProp$1A(a, prop, b[prop]);
  if (__getOwnPropSymbols$1A)
    for (var prop of __getOwnPropSymbols$1A(b)) {
      if (__propIsEnum$1A.call(b, prop))
        __defNormalProp$1A(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$l = (a, b) => __defProps$l(a, __getOwnPropDescs$l(b));
const DateField = (props) => {
  const ref = useRef(null);
  const state = useDateFieldState(__spreadProps$l(__spreadValues$1A({}, props), {
    /* Hard coding the United Kingdom locale,
     this enforces using english characters e.g.
      yyyy and not other such as åååå or chinese, which prevents hard to predict bugs */
    locale: "en-GB",
    createCalendar
  }));
  const { dateField } = useMultiStyleConfig("DatePicker");
  const { fieldProps } = useDateField(props, state, ref);
  const { segments } = state;
  const { dateFormat = "dd/mm/yyyy" } = props;
  const getMatchingSegment = (query, index) => find(
    (segment) => segment.placeholder === formatQuery(query)
  )(segments) || __spreadProps$l(__spreadValues$1A({}, segments[index]), { text: query });
  const sortedSegments = split(delimeterIncluded, dateFormat).map(
    (query, index) => getMatchingSegment(query, index)
  );
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadProps$l(__spreadValues$1A({}, fieldProps), {
      ref,
      display: "flex",
      __css: dateField,
      "data-testid": "date-field-test-id"
    }),
    sortedSegments.map((segment, i) => {
      const id = `${segment.type}-${i}`;
      return /* @__PURE__ */ React.createElement(DateSegment, { segment, state, key: id });
    })
  );
};

var __defProp$1z = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1z = Object.getOwnPropertySymbols;
var __hasOwnProp$1z = Object.prototype.hasOwnProperty;
var __propIsEnum$1z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1z = (obj, key, value) => key in obj ? __defProp$1z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1z.call(b, prop))
      __defNormalProp$1z(a, prop, b[prop]);
  if (__getOwnPropSymbols$1z)
    for (var prop of __getOwnPropSymbols$1z(b)) {
      if (__propIsEnum$1z.call(b, prop))
        __defNormalProp$1z(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$k = (a, b) => __defProps$k(a, __getOwnPropDescs$k(b));
var __objRest$1e = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1z.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1z)
    for (var prop of __getOwnPropSymbols$1z(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1z.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StyledField = forwardRef$1(
  (_a, ref) => {
    var _b = _a, { isInvalid, isDisabled, children, variant } = _b, rest = __objRest$1e(_b, ["isInvalid", "isDisabled", "children", "variant"]);
    const { styledField } = useMultiStyleConfig("DatePicker", { variant });
    return /* @__PURE__ */ React.createElement(
      Box,
      __spreadProps$k(__spreadValues$1z({}, rest), {
        ref,
        "aria-invalid": isInvalid,
        "aria-disabled": isDisabled,
        display: "flex",
        alignItems: "center",
        h: 10,
        __css: styledField
      }),
      children
    );
  }
);

var __defProp$1y = Object.defineProperty;
var __getOwnPropSymbols$1y = Object.getOwnPropertySymbols;
var __hasOwnProp$1y = Object.prototype.hasOwnProperty;
var __propIsEnum$1y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1y = (obj, key, value) => key in obj ? __defProp$1y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1y.call(b, prop))
      __defNormalProp$1y(a, prop, b[prop]);
  if (__getOwnPropSymbols$1y)
    for (var prop of __getOwnPropSymbols$1y(b)) {
      if (__propIsEnum$1y.call(b, prop))
        __defNormalProp$1y(a, prop, b[prop]);
    }
  return a;
};
const Table = (props) => /* @__PURE__ */ React.createElement(Table$2, __spreadValues$1y({}, props));

var __defProp$1x = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1x = Object.getOwnPropertySymbols;
var __hasOwnProp$1x = Object.prototype.hasOwnProperty;
var __propIsEnum$1x = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1x = (obj, key, value) => key in obj ? __defProp$1x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1x = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1x.call(b, prop))
      __defNormalProp$1x(a, prop, b[prop]);
  if (__getOwnPropSymbols$1x)
    for (var prop of __getOwnPropSymbols$1x(b)) {
      if (__propIsEnum$1x.call(b, prop))
        __defNormalProp$1x(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$j = (a, b) => __defProps$j(a, __getOwnPropDescs$j(b));
const CalendarCell = ({
  state,
  date,
  currentMonth
}) => {
  const ref = useRef(null);
  const { cellProps, buttonProps, isSelected, formattedDate } = useCalendarCell(
    { date },
    state,
    ref
  );
  const isToday = date.compare(today(state.timeZone)) === 0;
  const isOutsideMonth = !isSameMonth(currentMonth, date);
  return /* @__PURE__ */ React.createElement(chakra.td, __spreadValues$1x({}, cellProps), /* @__PURE__ */ React.createElement(
    Button$1,
    __spreadProps$j(__spreadValues$1x({}, buttonProps), {
      ref,
      borderRadius: "xs",
      boxSize: 8,
      hidden: isOutsideMonth,
      size: "sm",
      fontWeight: "medium",
      variant: isSelected ? "brand" : "ghost",
      ring: isToday && !isSelected ? "1px" : "0px",
      ringColor: "blue.500"
    }),
    formattedDate
  ));
};

const DayLabels = memo(({
  weekDays
}) => {
  const { dayLabel } = useMultiStyleConfig$1("Calendar");
  const weekDaysWithIds = weekDays.map((day, i) => ({ label: day, _id: i }));
  return /* @__PURE__ */ React.createElement(chakra$1.tr, null, /* @__PURE__ */ React.createElement(chakra$1.th, null), weekDaysWithIds.map(({ label, _id }) => /* @__PURE__ */ React.createElement(chakra$1.th, { key: _id, __css: dayLabel }, label)));
});

var __defProp$1w = Object.defineProperty;
var __getOwnPropSymbols$1w = Object.getOwnPropertySymbols;
var __hasOwnProp$1w = Object.prototype.hasOwnProperty;
var __propIsEnum$1w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1w = (obj, key, value) => key in obj ? __defProp$1w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1w = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1w.call(b, prop))
      __defNormalProp$1w(a, prop, b[prop]);
  if (__getOwnPropSymbols$1w)
    for (var prop of __getOwnPropSymbols$1w(b)) {
      if (__propIsEnum$1w.call(b, prop))
        __defNormalProp$1w(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1d = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1w.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1w)
    for (var prop of __getOwnPropSymbols$1w(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1w.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const CalendarGrid = memo(
  (_a) => {
    var _b = _a, { state, locale } = _b, rest = __objRest$1d(_b, ["state", "locale"]);
    const startDate = state.visibleRange.start;
    const { gridProps, headerProps, weekDays } = useCalendarGrid(rest, state);
    const weeksInMonth = getWeeksInMonth(startDate, locale);
    return /* @__PURE__ */ React.createElement(Table, __spreadValues$1w({ variant: "unstyled" }, gridProps), /* @__PURE__ */ React.createElement(Thead, __spreadValues$1w({}, headerProps), /* @__PURE__ */ React.createElement(DayLabels, { weekDays })), /* @__PURE__ */ React.createElement(Tbody, null, times((weekIndex) => /* @__PURE__ */ React.createElement(Tr, { key: weekIndex }, state.getDatesInWeek(weekIndex, startDate).map(
      (date) => date ? /* @__PURE__ */ React.createElement(
        CalendarCell,
        {
          key: date.day,
          state,
          date,
          currentMonth: startDate
        }
      ) : /* @__PURE__ */ React.createElement(chakra.td, null)
    )), weeksInMonth)));
  }
);

var __defProp$1v = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1v = Object.getOwnPropertySymbols;
var __hasOwnProp$1v = Object.prototype.hasOwnProperty;
var __propIsEnum$1v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1v = (obj, key, value) => key in obj ? __defProp$1v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1v = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1v.call(b, prop))
      __defNormalProp$1v(a, prop, b[prop]);
  if (__getOwnPropSymbols$1v)
    for (var prop of __getOwnPropSymbols$1v(b)) {
      if (__propIsEnum$1v.call(b, prop))
        __defNormalProp$1v(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$i = (a, b) => __defProps$i(a, __getOwnPropDescs$i(b));
var __objRest$1c = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1v.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1v)
    for (var prop of __getOwnPropSymbols$1v(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1v.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const MonthButton = (_a) => {
  var _b = _a, { children } = _b, rest = __objRest$1c(_b, ["children"]);
  const ref = useRef(null);
  const { buttonProps } = useButton(rest, ref);
  return /* @__PURE__ */ React.createElement(
    Button$1,
    __spreadProps$i(__spreadValues$1v({}, buttonProps), {
      boxSize: 8,
      size: "xs",
      variant: "ghost",
      ref
    }),
    children
  );
};

const months = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December",
  "January"
];

const MonthSelect = ({ state }) => {
  const { dateSelect } = useMultiStyleConfig("Calendar");
  const selectedMonth = state.visibleRange.start.month - 1;
  const onChange = (e) => {
    const index = Number(e.target.value);
    const diff = index - selectedMonth;
    state.setFocusedDate(state.visibleRange.start.add({ months: diff }));
  };
  return /* @__PURE__ */ React.createElement(
    Select$2,
    {
      id: "month",
      "aria-label": "Select Month",
      onChange,
      value: selectedMonth,
      iconSize: "0px",
      size: "sm",
      variant: "unstyled",
      sx: dateSelect,
      w: "max-content",
      textAlign: "center"
    },
    months.map((month, i) => /* @__PURE__ */ React.createElement("option", { value: i }, month))
  );
};

const YearSelect = ({
  onChange,
  years
}) => {
  const { dateSelect } = useMultiStyleConfig("Calendar");
  return /* @__PURE__ */ React.createElement(
    Select$2,
    {
      id: "year",
      "aria-label": "Year",
      onChange,
      value: 10,
      size: "sm",
      iconSize: "0px",
      variant: "unstyled",
      sx: dateSelect,
      w: "max-content"
    },
    years.map((year, i) => /* @__PURE__ */ React.createElement("option", { key: year.formatted, value: i }, year.formatted))
  );
};

const useYearsCalendar = ({
  state
}) => {
  const years = [];
  const formatter = useDateFormatter({ year: "numeric", month: "long" });
  for (let i = -10; i < 10; i += 1) {
    const date = state.focusedDate.add({ years: i });
    years.push({
      value: date,
      formatted: formatter.format(date.toDate(state.timeZone))
    });
  }
  return { years };
};
const useYearsRangeCalendar = ({
  state
}) => {
  const years = [];
  for (let i = -10; i < 10; i += 1) {
    const date = state.visibleRange.start.add({ years: i });
    years.push({
      value: date,
      formatted: `${date.year}`
    });
  }
  return { years };
};

const YearSelectCalendar = ({ state }) => {
  const { years } = useYearsCalendar({ state });
  const onChange = (e) => {
    const index = Number(e.target.value);
    const date = years[index].value;
    state.setFocusedDate(date);
  };
  return /* @__PURE__ */ React.createElement(YearSelect, { onChange, years });
};

const YearSelectRangeCalendar = ({
  state
}) => {
  const { years } = useYearsRangeCalendar({ state });
  const onChange = (e) => {
    const index = Number(e.target.value);
    const date = years[index].value;
    state.setFocusedDate(date);
  };
  return /* @__PURE__ */ React.createElement(YearSelect, { onChange, years });
};

const getWeekNumberAtStartOfMonth = (year, month, weekDay) => {
  if (month === 1) {
    return weekDay > 3 ? 52 : 1;
  }
  const isLeapYear = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  const daysInMonths = [
    0,
    31,
    isLeapYear ? 29 : 28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  const totalDaysUntilMonth = daysInMonths.slice(1, month).reduce(add, 0);
  const weekNumber = Math.ceil(totalDaysUntilMonth / 7);
  return weekNumber;
};

var __defProp$1u = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1u = Object.getOwnPropertySymbols;
var __hasOwnProp$1u = Object.prototype.hasOwnProperty;
var __propIsEnum$1u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1u = (obj, key, value) => key in obj ? __defProp$1u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1u = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1u.call(b, prop))
      __defNormalProp$1u(a, prop, b[prop]);
  if (__getOwnPropSymbols$1u)
    for (var prop of __getOwnPropSymbols$1u(b)) {
      if (__propIsEnum$1u.call(b, prop))
        __defNormalProp$1u(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$h = (a, b) => __defProps$h(a, __getOwnPropDescs$h(b));
const RangeCell = ({
  state,
  date,
  currentMonth,
  range
}) => {
  const isOutsideMonth = !isSameMonth(currentMonth, date);
  if (isOutsideMonth)
    return /* @__PURE__ */ React.createElement(chakra.td, null);
  const ref = useRef(null);
  const {
    cellProps,
    buttonProps,
    isSelected: baseIsSelected,
    formattedDate
  } = useCalendarCell({ date }, state, ref);
  const isToday = date.compare(today(state.timeZone)) === 0;
  const isHighlighted = range && date < range.end && date > range.start;
  const isSelected = range && !isHighlighted && (equals(date, range.start) || equals(date, range.end));
  return /* @__PURE__ */ React.createElement(chakra.td, __spreadValues$1u({}, cellProps), /* @__PURE__ */ React.createElement(
    chakra.button,
    __spreadProps$h(__spreadValues$1u({}, buttonProps), {
      type: "button",
      ref,
      borderRadius: "xs",
      bgColor: isHighlighted ? "brand-alt" : isSelected ? "blue.500" : "transparent",
      color: isSelected ? "text.inverted" : "text.default",
      fontSize: "sm",
      ring: isToday && !isSelected ? "1px" : "0px",
      ringColor: "blue.500",
      mx: "-1px",
      my: "0a",
      w: "8",
      h: "8",
      fontWeight: "medium",
      opacity: isSelected && !baseIsSelected ? "0.4" : "1",
      _focusVisible: {
        outline: "none",
        ring: "2px",
        ringColor: "border.wcag",
        ringOffset: "1px"
      },
      _hover: {
        bgColor: isSelected ? "blue.400" : "bg.filled",
        _disabled: {
          bgColor: "transparent"
        }
      },
      _disabled: {
        opacity: 0.3
      }
    }),
    formattedDate
  ));
};

var __defProp$1t = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1t = Object.getOwnPropertySymbols;
var __hasOwnProp$1t = Object.prototype.hasOwnProperty;
var __propIsEnum$1t = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1t = (obj, key, value) => key in obj ? __defProp$1t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1t = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1t.call(b, prop))
      __defNormalProp$1t(a, prop, b[prop]);
  if (__getOwnPropSymbols$1t)
    for (var prop of __getOwnPropSymbols$1t(b)) {
      if (__propIsEnum$1t.call(b, prop))
        __defNormalProp$1t(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
var __objRest$1b = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1t.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1t)
    for (var prop of __getOwnPropSymbols$1t(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1t.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StandaloneCalendarGrid = (_a) => {
  var _b = _a, {
    state,
    range
  } = _b, rest = __objRest$1b(_b, [
    "state",
    "range"
  ]);
  const { locale } = useLocale();
  const { calendarProps, prevButtonProps, nextButtonProps } = useCalendar(
    {},
    state
  );
  const startDate = state.visibleRange.start;
  const { gridProps, headerProps, weekDays } = useCalendarGrid(rest, state);
  const weeksInMonth = getWeeksInMonth(startDate, locale);
  const weekNumberStart = useMemo(
    () => getWeekNumberAtStartOfMonth(
      startDate.year,
      startDate.month,
      getDayOfWeek(startDate, locale)
    ),
    [startDate.year, startDate.month]
  );
  return /* @__PURE__ */ React.createElement(Box, __spreadProps$g(__spreadValues$1t({}, calendarProps), { h: "265px", p: "0" }), /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(Flex, { justify: "space-between", w: "full", p: "1", alignItems: "center" }, /* @__PURE__ */ React.createElement(MonthButton, __spreadValues$1t({}, prevButtonProps), /* @__PURE__ */ React.createElement(Icon$1, { as: ChevronLeftSolid, boxSize: 4 })), /* @__PURE__ */ React.createElement(HStack, { spacing: "0" }, /* @__PURE__ */ React.createElement(MonthSelect, { state }), /* @__PURE__ */ React.createElement(YearSelectRangeCalendar, { state })), /* @__PURE__ */ React.createElement(MonthButton, __spreadValues$1t({}, nextButtonProps), /* @__PURE__ */ React.createElement(Icon$1, { as: ChevronRightSolid, boxSize: 4 }))), /* @__PURE__ */ React.createElement(chakra.table, __spreadProps$g(__spreadValues$1t({}, gridProps), { sx: { borderSpacing: "0" } }), /* @__PURE__ */ React.createElement(chakra.thead, __spreadValues$1t({}, headerProps), /* @__PURE__ */ React.createElement(DayLabels, { weekDays })), /* @__PURE__ */ React.createElement(chakra.tbody, null, times(
    (weekIndex) => {
      const weekNumber = weekNumberStart + weekIndex;
      return /* @__PURE__ */ React.createElement(chakra.tr, { key: weekIndex }, /* @__PURE__ */ React.createElement(chakra.td, null, /* @__PURE__ */ React.createElement(Small$1, { sx: { color: "text.subdued" }, pr: "2" }, "w.", weekNumber > 52 ? weekNumber - 52 : weekNumber)), state.getDatesInWeek(weekIndex, startDate).map(
        (date) => date ? /* @__PURE__ */ React.createElement(
          RangeCell,
          {
            key: date.day,
            state,
            range,
            date,
            currentMonth: startDate
          }
        ) : /* @__PURE__ */ React.createElement(chakra.td, null)
      ));
    },
    weeksInMonth
  )))));
};

var __defProp$1s = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1s = Object.getOwnPropertySymbols;
var __hasOwnProp$1s = Object.prototype.hasOwnProperty;
var __propIsEnum$1s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1s = (obj, key, value) => key in obj ? __defProp$1s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1s.call(b, prop))
      __defNormalProp$1s(a, prop, b[prop]);
  if (__getOwnPropSymbols$1s)
    for (var prop of __getOwnPropSymbols$1s(b)) {
      if (__propIsEnum$1s.call(b, prop))
        __defNormalProp$1s(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
const Calendar = (props) => {
  const { locale } = useLocale();
  const { container } = useMultiStyleConfig("Calendar");
  const state = useCalendarState(__spreadProps$f(__spreadValues$1s({}, props), {
    locale,
    createCalendar: () => new GregorianCalendar()
  }));
  const { calendarProps, prevButtonProps, nextButtonProps } = useCalendar(
    props,
    state
  );
  return /* @__PURE__ */ React.createElement(Box, __spreadProps$f(__spreadValues$1s({}, calendarProps), { __css: container }), /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(Flex, { justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Box, { paddingInlineStart: "2" }, /* @__PURE__ */ React.createElement(YearSelectCalendar, { state })), /* @__PURE__ */ React.createElement(HStack, { spacing: 2 }, /* @__PURE__ */ React.createElement(MonthButton, __spreadValues$1s({}, prevButtonProps), /* @__PURE__ */ React.createElement(Icon$1, { as: ChevronLeftSolid, boxSize: 4 })), /* @__PURE__ */ React.createElement(MonthButton, __spreadValues$1s({}, nextButtonProps), /* @__PURE__ */ React.createElement(Icon$1, { as: ChevronRightSolid, boxSize: 4 })))), /* @__PURE__ */ React.createElement(CalendarGrid, { state, locale })));
};

var __defProp$1r = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1r = Object.getOwnPropertySymbols;
var __hasOwnProp$1r = Object.prototype.hasOwnProperty;
var __propIsEnum$1r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1r = (obj, key, value) => key in obj ? __defProp$1r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1r.call(b, prop))
      __defNormalProp$1r(a, prop, b[prop]);
  if (__getOwnPropSymbols$1r)
    for (var prop of __getOwnPropSymbols$1r(b)) {
      if (__propIsEnum$1r.call(b, prop))
        __defNormalProp$1r(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
const DatePicker = (props) => {
  const {
    isDisabled,
    isClearable = true,
    resetDate,
    isInvalid = false,
    dateFormat,
    minValue,
    variant = "outline"
  } = props;
  const ref = useRef();
  const { group } = useMultiStyleConfig("DatePicker");
  const state = useDatePickerState(__spreadProps$e(__spreadValues$1r({}, props), {
    shouldCloseOnSelect: false,
    hideTimeZone: true
  }));
  const { buttonProps, fieldProps, calendarProps, groupProps, dialogProps } = useDatePicker(
    __spreadProps$e(__spreadValues$1r({}, props), { minValue: minValue || parseDate("1994-03-08") }),
    state,
    ref
  );
  const togglePopup = () => state.setOpen(!state.isOpen);
  return /* @__PURE__ */ React.createElement(
    Popover$1,
    {
      isOpen: state.isOpen,
      onClose: () => state.setOpen(false),
      placement: "bottom-end"
    },
    /* @__PURE__ */ React.createElement(PopoverAnchor, null, /* @__PURE__ */ React.createElement(HStack, { minW: 56 }, /* @__PURE__ */ React.createElement(InputGroup, __spreadProps$e(__spreadValues$1r({}, groupProps), { ref, __css: group }), /* @__PURE__ */ React.createElement(StyledField, { isDisabled, isInvalid, variant }, /* @__PURE__ */ React.createElement(
      Box,
      {
        paddingInlineStart: "1a",
        paddingInlineEnd: 10
      },
      /* @__PURE__ */ React.createElement(
        DateField,
        __spreadProps$e(__spreadValues$1r({}, fieldProps), {
          dateFormat
        })
      )
    )), /* @__PURE__ */ React.createElement(
      InputRightElement,
      {
        sx: { height: "100%", paddingRight: "1" },
        zIndex: 0
      },
      /* @__PURE__ */ React.createElement(
        Trigger,
        __spreadProps$e(__spreadValues$1r({}, buttonProps), {
          isDisabled,
          handleClick: togglePopup
        })
      )
    )), /* @__PURE__ */ React.createElement(
      IconButton,
      {
        "aria-label": "reset-date",
        variant: "danger",
        size: "sm",
        fontSize: "xs",
        onClick: resetDate,
        hidden: !state.dateValue || !isClearable,
        isDisabled,
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: XCloseSolid })
      }
    ))),
    state.isOpen && /* @__PURE__ */ React.createElement(PopoverContent, __spreadProps$e(__spreadValues$1r({}, dialogProps), { ref, w: 64, border: "none" }), /* @__PURE__ */ React.createElement(FocusScope, { contain: true, restoreFocus: true }, /* @__PURE__ */ React.createElement(Calendar, __spreadValues$1r({}, calendarProps))))
  );
};

var __defProp$1q = Object.defineProperty;
var __getOwnPropSymbols$1q = Object.getOwnPropertySymbols;
var __hasOwnProp$1q = Object.prototype.hasOwnProperty;
var __propIsEnum$1q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1q = (obj, key, value) => key in obj ? __defProp$1q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1q.call(b, prop))
      __defNormalProp$1q(a, prop, b[prop]);
  if (__getOwnPropSymbols$1q)
    for (var prop of __getOwnPropSymbols$1q(b)) {
      if (__propIsEnum$1q.call(b, prop))
        __defNormalProp$1q(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1a = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1q)
    for (var prop of __getOwnPropSymbols$1q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Clickable = (_a) => {
  var _b = _a, { href, linkProps } = _b, rest = __objRest$1a(_b, ["href", "linkProps"]);
  const clickable = useClickable(rest);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, !isNil(href) && /* @__PURE__ */ React.createElement(
    Link$1,
    __spreadValues$1q(__spreadValues$1q({
      as: Link$2,
      _focusVisible: ring,
      to: href,
      _hover: { textDecoration: "none" }
    }, linkProps), clickable)
  ), isNil(href) && /* @__PURE__ */ React.createElement(chakra.button, __spreadValues$1q({ _focusVisible: ring }, clickable)));
};

const DateButton = ({
  isActive,
  onClick,
  children
}) => /* @__PURE__ */ React.createElement(Flex, { maxW: "120px" }, /* @__PURE__ */ React.createElement(Clickable, { onClick }, /* @__PURE__ */ React.createElement(
  Label$1,
  {
    _hover: {
      fontWeight: "semibold"
    },
    sx: {
      color: isActive ? "background.button.brand" : "text.default",
      cursor: "pointer",
      fontWeight: isActive ? "semibold" : "regular"
    },
    _active: {
      fontWeight: "semibold"
    },
    h: "8"
  },
  children
)));

const validRange = (date, state) => !date || (!state.minValue || date.start >= state.minValue) && (!state.maxValue || date.end <= state.maxValue) && date.end >= date.start;

const getQuickSelectOptions = (state, locale, fiscalStartMonth, fiscalStartDay) => {
  const thisDay = today(state.timeZone);
  const startOfMonthWithDays = (date, { months, days }) => {
    const start = date.add({ months }).set({ day: days });
    return start;
  };
  const endOfMonthWithDays = (date, { months, days }) => {
    const end = date.add({ months }).set({ day: days }).subtract({ days: 1 });
    return end;
  };
  const thisWeek = {
    value: {
      start: startOfWeek(thisDay, locale),
      end: endOfWeek(thisDay, locale)
    },
    label: "This Week"
  };
  const lastWeek = {
    value: {
      start: startOfWeek(thisDay.subtract({ weeks: 1 }), locale),
      end: endOfWeek(thisDay.subtract({ weeks: 1 }), locale)
    },
    label: "Last Week"
  };
  const thisMonth = {
    value: {
      start: startOfMonth(thisDay),
      end: endOfMonth(thisDay)
    },
    label: "This Month"
  };
  const lastMonth = {
    value: {
      start: startOfMonth(thisDay.subtract({ months: 1 })),
      end: endOfMonth(thisDay.subtract({ months: 1 }))
    },
    label: "Last Month"
  };
  const thisYear = {
    value: {
      start: startOfYear(thisDay),
      end: endOfYear(thisDay)
    },
    label: "This Year"
  };
  const lastYear = {
    value: {
      start: startOfYear(thisDay.subtract({ years: 1 })),
      end: endOfYear(thisDay.subtract({ years: 1 }))
    },
    label: "Last Year"
  };
  const nextMonth = {
    value: {
      start: startOfMonth(thisDay.add({ months: 1 })),
      end: endOfMonth(thisDay.add({ months: 1 }))
    },
    label: "Next Month"
  };
  const nextThreeMonths = {
    value: {
      start: startOfMonth(thisDay.add({ months: 1 })),
      end: endOfMonth(thisDay.add({ months: 3 }))
    },
    label: "Next 3 Months"
  };
  const nextSixMonths = {
    value: {
      start: startOfMonth(thisDay.add({ months: 1 })),
      end: endOfMonth(thisDay.add({ months: 6 }))
    },
    label: "Next 6 Months"
  };
  const nextYear = {
    value: {
      start: startOfYear(thisDay.add({ years: 1 })),
      end: endOfYear(thisDay.add({ years: 1 }))
    },
    label: "Next Year"
  };
  const offsetFiscalYear = thisDay.month < fiscalStartMonth || thisDay.month === fiscalStartMonth && thisDay.day < fiscalStartDay ? 1 : 0;
  const thisFiscalYear = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        { months: fiscalStartMonth, days: fiscalStartDay }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        { months: fiscalStartMonth + 12, days: fiscalStartDay }
      )
    },
    label: "This Fiscal Year"
  };
  const lastFiscalYear = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear + 1 }),
        {
          months: fiscalStartMonth,
          days: fiscalStartDay
        }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear + 1 }),
        {
          months: fiscalStartMonth + 12,
          days: fiscalStartDay
        }
      )
    },
    label: "Last Fiscal Year"
  };
  const yearToDate = {
    value: {
      start: startOfMonthWithDays(startOfYear(thisDay), {
        months: fiscalStartMonth,
        days: fiscalStartDay
      }),
      end: thisDay
    },
    label: "Year to Date"
  };
  const F1 = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth,
          days: fiscalStartDay
        }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 3,
          days: fiscalStartDay
        }
      )
    },
    label: fiscalStartMonth === 0 ? "Q1" : "FQ1"
  };
  const F2 = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 3,
          days: fiscalStartDay
        }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 6,
          days: fiscalStartDay
        }
      )
    },
    label: fiscalStartMonth === 0 ? "Q2" : "FQ2"
  };
  const F3 = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 6,
          days: fiscalStartDay
        }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 9,
          days: fiscalStartDay
        }
      )
    },
    label: fiscalStartMonth === 0 ? "Q3" : "FQ3"
  };
  const F4 = {
    value: {
      start: startOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 9,
          days: fiscalStartDay
        }
      ),
      end: endOfMonthWithDays(
        startOfYear(thisDay).subtract({ years: offsetFiscalYear }),
        {
          months: fiscalStartMonth + 12,
          days: fiscalStartDay
        }
      )
    },
    label: fiscalStartMonth === 0 ? "Q4" : "FQ4"
  };
  const fiscalQuarters = [F1, F2, F3, F4];
  const fiscalYears = fiscalStartMonth === 0 ? [] : [thisFiscalYear, lastFiscalYear];
  const quickDates = [
    thisWeek,
    lastWeek,
    thisMonth,
    lastMonth,
    thisYear,
    yearToDate,
    lastYear,
    nextMonth,
    nextThreeMonths,
    nextSixMonths,
    nextYear,
    ...fiscalYears
  ];
  return { quickDates, fiscalQuarters };
};

const seperator = `1px solid ${palette.gray["100"]}`;
const QuickSelect = ({
  state,
  fiscalStartMonth = 0,
  fiscalStartDay = 0,
  locale = "",
  height = "2xs"
}) => {
  const { quickDates, fiscalQuarters } = useMemo(
    () => getQuickSelectOptions(state, locale, fiscalStartMonth, fiscalStartDay),
    []
  );
  const updateDate = (newDate) => () => {
    if (newDate) {
      state.setValue(newDate);
      state.setFocusedDateRange(newDate);
    }
  };
  const getIsActive = (newDate) => equals(state.value, newDate.value);
  const shouldShow = (dates) => any((date) => validRange(date.value, state), dates);
  return /* @__PURE__ */ React.createElement(Stack, { alignItems: "start", borderRight: seperator, pt: "2" }, /* @__PURE__ */ React.createElement(
    Stack,
    {
      h: height,
      overflowY: "hidden",
      pr: "4",
      _hover: { overflowY: "scroll" },
      w: "36",
      display: shouldShow(quickDates) ? "initial" : "none",
      mb: "4"
    },
    map(
      (quickDate) => validRange(quickDate.value, state) && /* @__PURE__ */ React.createElement(Box, { minH: "20px", key: `quick-select-${quickDate.label}` }, /* @__PURE__ */ React.createElement(
        DateButton,
        {
          onClick: updateDate(quickDate.value),
          isActive: getIsActive(quickDate)
        },
        quickDate.label
      )),
      quickDates
    )
  ), /* @__PURE__ */ React.createElement(
    Box,
    {
      w: "50%",
      borderTop: seperator,
      display: shouldShow(fiscalQuarters) ? "initial" : "none"
    }
  ), /* @__PURE__ */ React.createElement(
    Flex,
    {
      justifyContent: "space-between",
      w: "full",
      pt: "2",
      pr: "4",
      display: shouldShow(fiscalQuarters) ? "flex" : "none"
    },
    map(
      (quarter) => validRange(quarter.value, state) && /* @__PURE__ */ React.createElement(
        DateButton,
        {
          onClick: updateDate(quarter.value),
          isActive: getIsActive(quarter),
          key: `quick-select-${quarter.label}`
        },
        quarter.label
      ),
      fiscalQuarters
    )
  ));
};

var __defProp$1p = Object.defineProperty;
var __getOwnPropSymbols$1p = Object.getOwnPropertySymbols;
var __hasOwnProp$1p = Object.prototype.hasOwnProperty;
var __propIsEnum$1p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1p = (obj, key, value) => key in obj ? __defProp$1p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1p.call(b, prop))
      __defNormalProp$1p(a, prop, b[prop]);
  if (__getOwnPropSymbols$1p)
    for (var prop of __getOwnPropSymbols$1p(b)) {
      if (__propIsEnum$1p.call(b, prop))
        __defNormalProp$1p(a, prop, b[prop]);
    }
  return a;
};
const focusRing = {
  borderWidth: "xs",
  borderRadius: "md",
  borderColor: "border.brand.hover",
  borderStyle: "solid"
};
const RangeCalendar = (props) => {
  const {
    onChange: setRange = identity,
    value,
    handleClose,
    resetDate,
    isClearable = true,
    fiscalStartMonth,
    fiscalStartDay,
    minValue,
    maxValue
  } = props;
  const { locale } = useLocale();
  const ref = useRef(null);
  const { rangeCalendarContainer } = useMultiStyleConfig("Calendar");
  const calendarOneState = useCalendarState({
    value: value && value.start ? value.start : null,
    minValue,
    maxValue,
    onChange: (newVal) => {
      setRange({
        end: value && value.end && newVal <= value.end ? value.end : newVal,
        start: newVal
      });
    },
    locale,
    createCalendar: () => new GregorianCalendar()
  });
  const calendarTwoState = useCalendarState({
    value: value && value.end ? value.end : null,
    minValue,
    maxValue,
    onChange: (newVal) => {
      setRange({
        start: value && value.end && value.start <= newVal ? value.start : newVal,
        end: newVal
      });
    },
    locale,
    createCalendar: () => new GregorianCalendar()
  });
  const focusDateRange = (dateRange) => {
    if (dateRange && dateRange.start && dateRange.end) {
      calendarOneState.setFocusedDate(dateRange.start);
      calendarTwoState.setFocusedDate(dateRange.end);
    }
  };
  const state = {
    setValue: setRange,
    setFocusedDateRange: focusDateRange,
    value,
    timeZone: calendarOneState.timeZone,
    minValue,
    maxValue
  };
  const focusedStartMonthProps = value && value.start ? {} : focusRing;
  return /* @__PURE__ */ React.createElement(Box, { ref, __css: rangeCalendarContainer }, /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(Flex, { gap: 4 }, /* @__PURE__ */ React.createElement(
    QuickSelect,
    {
      state,
      locale,
      fiscalStartMonth,
      fiscalStartDay
    }
  ), /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(HStack, { alignItems: "start", spacing: 8, h: "full", pt: "2" }, /* @__PURE__ */ React.createElement(Stack, __spreadValues$1p({ h: "full" }, focusedStartMonthProps), /* @__PURE__ */ React.createElement(Box, { p: "2" }, /* @__PURE__ */ React.createElement(Label$1, { size: "xs" }, "Start date:"), /* @__PURE__ */ React.createElement(
    StandaloneCalendarGrid,
    {
      state: calendarOneState,
      range: value
    }
  ))), /* @__PURE__ */ React.createElement(Stack, { h: "full", justify: "space-between" }, /* @__PURE__ */ React.createElement(Stack, { opacity: value && value.start ? "1" : "0.4" }, /* @__PURE__ */ React.createElement(Box, { p: "2" }, /* @__PURE__ */ React.createElement(Label$1, { size: "xs" }, "End date:"), /* @__PURE__ */ React.createElement(
    StandaloneCalendarGrid,
    {
      state: calendarTwoState,
      range: value
    }
  ))), /* @__PURE__ */ React.createElement(HStack, { pt: "2", alignSelf: "end" }, isClearable && /* @__PURE__ */ React.createElement(Button$1, { onClick: resetDate, variant: "ghost", size: "sm" }, "Clear"), /* @__PURE__ */ React.createElement(Button$1, { variant: "brand", onClick: handleClose, size: "sm" }, "Save"))))))));
};

const isValidDateRange = (value) => is(Object, value) && has("startDate", value) && has("endDate", value) && is(String, value.startDate) && is(String, value.endDate);

var __defProp$1o = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1o = Object.getOwnPropertySymbols;
var __hasOwnProp$1o = Object.prototype.hasOwnProperty;
var __propIsEnum$1o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1o = (obj, key, value) => key in obj ? __defProp$1o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1o.call(b, prop))
      __defNormalProp$1o(a, prop, b[prop]);
  if (__getOwnPropSymbols$1o)
    for (var prop of __getOwnPropSymbols$1o(b)) {
      if (__propIsEnum$1o.call(b, prop))
        __defNormalProp$1o(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
const parseValue = (value) => {
  if (!isValidDateRange(value))
    return null;
  return { start: parseDate(value.startDate), end: parseDate(value.endDate) };
};
const PortalWrapper = ({
  renderInPortal,
  children
}) => {
  if (renderInPortal) {
    return /* @__PURE__ */ React.createElement(Portal, null, children);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
const DateRangePicker = (props) => {
  const {
    isDisabled,
    isClearable = true,
    resetDate,
    isInvalid = false,
    dateFormat,
    fiscalStartMonth,
    fiscalStartDay,
    variant = "outline",
    onChange: onChangeCallback = identity,
    value,
    minValue = "1994-03-08",
    maxValue,
    renderInPortal = false
  } = props;
  const ref = useRef();
  const { group } = useMultiStyleConfig("DatePicker");
  const parsedProps = {
    onChange: (date) => {
      onChangeCallback({
        startDate: date == null ? void 0 : date.start.toString(),
        endDate: date == null ? void 0 : date.end.toString()
      });
    },
    value: parseValue(value),
    minValue: isNil(minValue) ? void 0 : parseDate(minValue),
    maxValue: isNil(maxValue) ? void 0 : parseDate(maxValue)
  };
  const state = useDateRangePickerState(__spreadProps$d(__spreadValues$1o(__spreadValues$1o({}, props), parsedProps), {
    shouldCloseOnSelect: false,
    hideTimeZone: true
  }));
  const {
    groupProps,
    startFieldProps,
    endFieldProps,
    buttonProps,
    dialogProps,
    calendarProps
  } = useDateRangePicker(
    __spreadProps$d(__spreadValues$1o(__spreadValues$1o({}, props), parsedProps), {
      minValue: parsedProps.minValue || parseDate("1994-03-08")
    }),
    state,
    ref
  );
  const togglePopup = () => state.setOpen(!state.isOpen);
  const handleClose = () => {
    state.setOpen(false);
  };
  return /* @__PURE__ */ React.createElement(
    Popover$1,
    {
      isOpen: state.isOpen,
      onClose: handleClose,
      placement: "bottom-start"
    },
    /* @__PURE__ */ React.createElement(PopoverAnchor, null, /* @__PURE__ */ React.createElement(HStack, null, /* @__PURE__ */ React.createElement(InputGroup, __spreadProps$d(__spreadValues$1o({}, groupProps), { ref, __css: group }), /* @__PURE__ */ React.createElement(
      StyledField,
      {
        isDisabled,
        isInvalid,
        variant
      },
      /* @__PURE__ */ React.createElement(HStack, { paddingInlineStart: "1a", paddingInlineEnd: 10 }, /* @__PURE__ */ React.createElement(DateField, __spreadProps$d(__spreadValues$1o({}, startFieldProps), { dateFormat })), /* @__PURE__ */ React.createElement(P$1, null, "-"), /* @__PURE__ */ React.createElement(DateField, __spreadProps$d(__spreadValues$1o({}, endFieldProps), { dateFormat })))
    ), /* @__PURE__ */ React.createElement(InputRightElement, { sx: { height: "100%", paddingRight: "1" } }, /* @__PURE__ */ React.createElement(
      Trigger,
      __spreadProps$d(__spreadValues$1o({}, buttonProps), {
        isDisabled,
        handleClick: togglePopup
      })
    ))), /* @__PURE__ */ React.createElement(
      IconButton,
      {
        "aria-label": "reset-date",
        variant: "danger",
        size: "sm",
        fontSize: "xs",
        onClick: resetDate,
        hidden: !isClearable,
        isDisabled,
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: XCloseSolid })
      }
    ))),
    /* @__PURE__ */ React.createElement(PortalWrapper, { renderInPortal }, state.isOpen && /* @__PURE__ */ React.createElement(PopoverContent, __spreadProps$d(__spreadValues$1o({}, dialogProps), { ref, w: "max-content" }), /* @__PURE__ */ React.createElement(FocusScope, { contain: true, restoreFocus: true }, /* @__PURE__ */ React.createElement(
      RangeCalendar,
      __spreadProps$d(__spreadValues$1o({}, calendarProps), {
        resetDate,
        handleClose,
        fiscalStartMonth: fiscalStartMonth || 0,
        fiscalStartDay: fiscalStartDay || 0,
        isClearable
      })
    ))))
  );
};

var __defProp$1n = Object.defineProperty;
var __getOwnPropSymbols$1n = Object.getOwnPropertySymbols;
var __hasOwnProp$1n = Object.prototype.hasOwnProperty;
var __propIsEnum$1n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1n = (obj, key, value) => key in obj ? __defProp$1n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1n.call(b, prop))
      __defNormalProp$1n(a, prop, b[prop]);
  if (__getOwnPropSymbols$1n)
    for (var prop of __getOwnPropSymbols$1n(b)) {
      if (__propIsEnum$1n.call(b, prop))
        __defNormalProp$1n(a, prop, b[prop]);
    }
  return a;
};
var __objRest$19 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1n.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1n)
    for (var prop of __getOwnPropSymbols$1n(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1n.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const InputGroupWrapper = (_a) => {
  var _b = _a, {
    inputLeftElement,
    inputRightElement,
    children
  } = _b, rest = __objRest$19(_b, [
    "inputLeftElement",
    "inputRightElement",
    "children"
  ]);
  const containsInputGroupElement = not(all(isNil, [inputLeftElement, inputRightElement]));
  return containsInputGroupElement ? /* @__PURE__ */ React.createElement(InputGroup, __spreadValues$1n({}, rest), inputLeftElement, children, inputRightElement) : /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};

var __defProp$1m = Object.defineProperty;
var __getOwnPropSymbols$1m = Object.getOwnPropertySymbols;
var __hasOwnProp$1m = Object.prototype.hasOwnProperty;
var __propIsEnum$1m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1m = (obj, key, value) => key in obj ? __defProp$1m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1m.call(b, prop))
      __defNormalProp$1m(a, prop, b[prop]);
  if (__getOwnPropSymbols$1m)
    for (var prop of __getOwnPropSymbols$1m(b)) {
      if (__propIsEnum$1m.call(b, prop))
        __defNormalProp$1m(a, prop, b[prop]);
    }
  return a;
};
var __objRest$18 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1m.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1m)
    for (var prop of __getOwnPropSymbols$1m(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1m.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DatePickerField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    minValue,
    maxValue,
    isRequired,
    direction = "column",
    label,
    validate,
    firstDayOfWeek = "monday",
    onChange: onChangeCallback = identity,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$18(_b, [
    "name",
    "minValue",
    "maxValue",
    "isRequired",
    "direction",
    "label",
    "validate",
    "firstDayOfWeek",
    "onChange",
    "inputLeftElement",
    "inputRightElement"
  ]);
  const { setValue, setError, trigger } = useFormContext();
  const handleChange = (date) => {
    setValue(name, date == null ? void 0 : date.toString());
    if (minValue && date < parseDate(minValue) || maxValue && date > parseDate(maxValue)) {
      setError(name, {
        type: "custom",
        message: minValue && maxValue ? `Date must be between ${minValue}-${maxValue}` : minValue ? `Select date earliest at ${minValue}` : `Select date latest at ${maxValue}`
      });
    } else {
      trigger(name);
    }
    onChangeCallback(date);
  };
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate,
      ref
    },
    ({ value, onChange }, { formState: { errors } }) => /* @__PURE__ */ React.createElement(
      InputGroupWrapper,
      {
        inputLeftElement,
        inputRightElement
      },
      /* @__PURE__ */ React.createElement(
        DatePicker,
        __spreadValues$1m({
          firstDayOfWeek,
          "aria-label": label,
          isInvalid: !!errors[name],
          onChange: handleChange,
          resetDate: () => onChange(null),
          value: value ? parseDate(value) : null,
          minValue: minValue ? parseDate(minValue) : void 0,
          maxValue: maxValue ? parseDate(maxValue) : void 0,
          validationState: errors.name ? "invalid" : "valid"
        }, rest)
      )
    )
  );
});

var __defProp$1l = Object.defineProperty;
var __getOwnPropSymbols$1l = Object.getOwnPropertySymbols;
var __hasOwnProp$1l = Object.prototype.hasOwnProperty;
var __propIsEnum$1l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1l = (obj, key, value) => key in obj ? __defProp$1l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1l.call(b, prop))
      __defNormalProp$1l(a, prop, b[prop]);
  if (__getOwnPropSymbols$1l)
    for (var prop of __getOwnPropSymbols$1l(b)) {
      if (__propIsEnum$1l.call(b, prop))
        __defNormalProp$1l(a, prop, b[prop]);
    }
  return a;
};
var __objRest$17 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1l.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1l)
    for (var prop of __getOwnPropSymbols$1l(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1l.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DateRangePickerField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    minValue,
    maxValue,
    isRequired,
    direction = "column",
    label,
    validate,
    firstDayOfWeek = "monday",
    onChange: onChangeCallback = identity,
    isClearable = true
  } = _b, rest = __objRest$17(_b, [
    "name",
    "minValue",
    "maxValue",
    "isRequired",
    "direction",
    "label",
    "validate",
    "firstDayOfWeek",
    "onChange",
    "isClearable"
  ]);
  const { setValue, setError, trigger } = useFormContext();
  const handleChange = (dateRange) => {
    setValue(name, dateRange);
    if (minValue && (dateRange == null ? void 0 : dateRange.startDate) < minValue || maxValue && (dateRange == null ? void 0 : dateRange.endDate) > maxValue) {
      setError(name, {
        type: "custom",
        message: minValue && maxValue ? `Date must be between ${minValue}-${maxValue}` : minValue ? `Select date earliest at ${minValue}` : `Select date latest at ${maxValue}`
      });
    } else {
      trigger(name);
    }
    onChangeCallback(dateRange);
  };
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate,
      ref
    },
    ({ value, onChange }, { formState: { errors } }) => /* @__PURE__ */ React.createElement(
      DateRangePicker,
      __spreadValues$1l({
        firstDayOfWeek,
        "aria-label": label,
        isInvalid: !!errors[name],
        onChange: handleChange,
        resetDate: () => onChange(null),
        value,
        minValue,
        maxValue,
        validationState: errors.name ? "invalid" : "valid",
        isClearable
      }, rest)
    )
  );
});

const toastIconMap = {
  success: CheckCircleSolid,
  warning: AlertTriangleSolid,
  error: AlertCircleSolid,
  danger: AlertCircleSolid,
  info: BellSolid,
  ai: BrightnessSolid,
  default: HelpCircleSolid,
  ghost: HelpCircleSolid
};

var __defProp$1k = Object.defineProperty;
var __getOwnPropSymbols$1k = Object.getOwnPropertySymbols;
var __hasOwnProp$1k = Object.prototype.hasOwnProperty;
var __propIsEnum$1k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1k = (obj, key, value) => key in obj ? __defProp$1k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1k.call(b, prop))
      __defNormalProp$1k(a, prop, b[prop]);
  if (__getOwnPropSymbols$1k)
    for (var prop of __getOwnPropSymbols$1k(b)) {
      if (__propIsEnum$1k.call(b, prop))
        __defNormalProp$1k(a, prop, b[prop]);
    }
  return a;
};
var __objRest$16 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1k.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1k)
    for (var prop of __getOwnPropSymbols$1k(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1k.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Tooltip = (_a) => {
  var _b = _a, {
    variant = "default",
    hasArrow = true,
    title = "",
    description = "",
    hasIcon = "true"
  } = _b, rest = __objRest$16(_b, [
    "variant",
    "hasArrow",
    "title",
    "description",
    "hasIcon"
  ]);
  const iconVariant = variant;
  const icon = toastIconMap[iconVariant];
  const TooltipContent = /* @__PURE__ */ React.createElement(HStack, { alignItems: "flex-start" }, hasIcon && /* @__PURE__ */ React.createElement(Icon$1, { as: icon, color: `icon.toast.${iconVariant}` }), /* @__PURE__ */ React.createElement(VStack, { spacing: 0, alignItems: "flex-start" }, /* @__PURE__ */ React.createElement(Label$1, { size: "sm" }, title), /* @__PURE__ */ React.createElement(
    P$1,
    {
      variant: "14",
      sx: {
        color: !variant || variant === "ai" || variant === "default" ? "text.inverted" : void 0
      }
    },
    description
  )));
  return /* @__PURE__ */ React.createElement(
    Tooltip$2,
    __spreadValues$1k({
      hasArrow,
      hasIcon,
      label: title || description ? TooltipContent : void 0,
      variant
    }, rest)
  );
};

var __defProp$1j = Object.defineProperty;
var __getOwnPropSymbols$1j = Object.getOwnPropertySymbols;
var __hasOwnProp$1j = Object.prototype.hasOwnProperty;
var __propIsEnum$1j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1j = (obj, key, value) => key in obj ? __defProp$1j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1j.call(b, prop))
      __defNormalProp$1j(a, prop, b[prop]);
  if (__getOwnPropSymbols$1j)
    for (var prop of __getOwnPropSymbols$1j(b)) {
      if (__propIsEnum$1j.call(b, prop))
        __defNormalProp$1j(a, prop, b[prop]);
    }
  return a;
};
var __objRest$15 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1j.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1j)
    for (var prop of __getOwnPropSymbols$1j(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1j.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TimeoutProgressCircle = (_a) => {
  var _b = _a, {
    progress,
    ringColor = "border.error"
  } = _b, rest = __objRest$15(_b, [
    "progress",
    "ringColor"
  ]);
  const RADIUS = 22;
  const STROKE_WIDTH = 3;
  const SVG_SIZE = 2 * (RADIUS + STROKE_WIDTH);
  const CIRCUMFERENCE = 2 * Math.PI * RADIUS;
  const strokeDashoffset = CIRCUMFERENCE - progress / 100 * CIRCUMFERENCE;
  return /* @__PURE__ */ React.createElement(
    Circle,
    __spreadValues$1j({
      as: "svg",
      size: `${SVG_SIZE}px`,
      viewBox: `0 0 ${SVG_SIZE} ${SVG_SIZE}`,
      sx: {
        transform: "rotate(-90deg)"
      }
    }, rest),
    /* @__PURE__ */ React.createElement(
      chakra$1.circle,
      {
        cx: SVG_SIZE / 2,
        cy: SVG_SIZE / 2,
        r: RADIUS,
        fill: "transparent",
        stroke: "border.hover",
        strokeWidth: STROKE_WIDTH
      }
    ),
    /* @__PURE__ */ React.createElement(
      chakra$1.circle,
      {
        cx: SVG_SIZE / 2,
        cy: SVG_SIZE / 2,
        r: RADIUS,
        fill: "transparent",
        stroke: ringColor,
        strokeWidth: STROKE_WIDTH,
        strokeDasharray: CIRCUMFERENCE,
        strokeDashoffset,
        strokeLinecap: "round"
      }
    )
  );
};

var __defProp$1i = Object.defineProperty;
var __getOwnPropSymbols$1i = Object.getOwnPropertySymbols;
var __hasOwnProp$1i = Object.prototype.hasOwnProperty;
var __propIsEnum$1i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1i = (obj, key, value) => key in obj ? __defProp$1i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1i.call(b, prop))
      __defNormalProp$1i(a, prop, b[prop]);
  if (__getOwnPropSymbols$1i)
    for (var prop of __getOwnPropSymbols$1i(b)) {
      if (__propIsEnum$1i.call(b, prop))
        __defNormalProp$1i(a, prop, b[prop]);
    }
  return a;
};
var __objRest$14 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1i)
    for (var prop of __getOwnPropSymbols$1i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const IntentButton = (_a) => {
  var _b = _a, {
    icon = TrashDuo,
    timeout = 1e3,
    ringColor = "border.error",
    onTimeout = () => {
    },
    tooltipText = "Hold to Delete",
    "aria-label": ariaLabel = "confirm delete"
  } = _b, rest = __objRest$14(_b, [
    "icon",
    "timeout",
    "ringColor",
    "onTimeout",
    "tooltipText",
    "aria-label"
  ]);
  const [progress, setProgress] = useState(0);
  const [isHovering, setIsHovering] = useState(false);
  const timerRef = useRef(void 0);
  const clearTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = void 0;
    }
    setProgress(0);
  };
  useEffect(() => clearTimer, []);
  const startTimer = () => {
    clearTimer();
    const startTime = Date.now();
    timerRef.current = setInterval(() => {
      const elapsedTime = Date.now() - startTime;
      const updatedProgress = elapsedTime / timeout * 100;
      if (updatedProgress >= 100) {
        clearInterval(timerRef.current);
        onTimeout();
      } else {
        setProgress(updatedProgress);
      }
    }, 10);
  };
  const handleMouseEnter = () => {
    setIsHovering(true);
  };
  const handleMouseLeave = () => {
    setIsHovering(false);
    clearTimer();
  };
  return /* @__PURE__ */ React.createElement(Tooltip, { label: tooltipText, placement: "top" }, /* @__PURE__ */ React.createElement(
    Center,
    __spreadValues$1i({
      position: "relative",
      cursor: "pointer",
      onMouseDown: startTimer,
      onMouseUp: clearTimer,
      onMouseLeave: handleMouseLeave,
      onMouseEnter: handleMouseEnter,
      boxSize: "50px",
      opacity: `${(100 - progress) / 100}`
    }, rest),
    /* @__PURE__ */ React.createElement(
      IconButton,
      {
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: icon }),
        size: "md",
        "aria-label": ariaLabel,
        variant: "ghost"
      }
    ),
    isHovering && /* @__PURE__ */ React.createElement(
      TimeoutProgressCircle,
      {
        ringColor,
        progress,
        position: "absolute",
        top: "0",
        left: "0"
      }
    )
  ));
};

const defaultFadeDelay = 250;
const defaultOffset = 20;

const unFocusStyles = { tabIndex: "-1" };
const getChildrenWithFocus = (children, disableFocus, show) => show ? children : disableFocus ? getChildrenWithProps(children, unFocusStyles) : children;
const getDuration = (enterDuration, exitDuration, duration) => {
  const inDuration = enterDuration || duration || defaultFadeDelay;
  const outDuration = exitDuration || duration || defaultFadeDelay;
  const transition = {
    enter: {
      duration: inDuration / 1e3
    },
    exit: {
      duration: outDuration / 1e3
    }
  };
  return transition;
};
const getOffsets = (direction, offset, offsetX, offsetY) => {
  if (offsetX || offsetY) {
    return { offsetX, offsetY };
  }
  if (direction) {
    const delta = offset || defaultOffset;
    switch (direction) {
      case "right":
        return { offsetX: delta, offsetY: 0 };
      case "left":
        return { offsetX: -delta, offsetY: 0 };
      case "top":
        return { offsetX: 0, offsetY: -delta };
      case "bottom":
        return { offsetX: 0, offsetY: delta };
    }
  }
  return { offsetX: defaultOffset, offsetY: defaultOffset };
};
const useDelay = (show, enterDelay, exitDelay) => {
  const [showWithDelay, setShowWithDelay] = useState(false);
  useEffect(() => {
    const ref = setTimeout(
      () => setShowWithDelay(show),
      show ? enterDelay : exitDelay
    );
    return () => clearTimeout(ref);
  }, [show]);
  return showWithDelay;
};
const useHiddenDisplay = (anchor = false, exitDelay = 0, exitDuration = 0, duration = 0, onTransitionComplete = identity) => {
  const [hidden, setHidden] = useState(anchor);
  useEffect(() => {
    const ref = setTimeout(() => {
      setHidden(anchor);
      onTransitionComplete(anchor);
    }, exitDelay + (exitDuration || duration || 0));
    return () => clearTimeout(ref);
  }, [anchor]);
  return hidden;
};

var __defProp$1h = Object.defineProperty;
var __getOwnPropSymbols$1h = Object.getOwnPropertySymbols;
var __hasOwnProp$1h = Object.prototype.hasOwnProperty;
var __propIsEnum$1h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1h = (obj, key, value) => key in obj ? __defProp$1h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1h.call(b, prop))
      __defNormalProp$1h(a, prop, b[prop]);
  if (__getOwnPropSymbols$1h)
    for (var prop of __getOwnPropSymbols$1h(b)) {
      if (__propIsEnum$1h.call(b, prop))
        __defNormalProp$1h(a, prop, b[prop]);
    }
  return a;
};
var __objRest$13 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1h)
    for (var prop of __getOwnPropSymbols$1h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Fade = (_a) => {
  var _b = _a, {
    children,
    enterDuration = null,
    exitDuration = null,
    duration = null,
    in: show = false,
    disableFocus = true,
    hideDisplay = false,
    enterDelay = 0,
    exitDelay = 0,
    onTransitionComplete = identity
  } = _b, rest = __objRest$13(_b, [
    "children",
    "enterDuration",
    "exitDuration",
    "duration",
    "in",
    "disableFocus",
    "hideDisplay",
    "enterDelay",
    "exitDelay",
    "onTransitionComplete"
  ]);
  const transition = getDuration(enterDuration, exitDuration, duration);
  const showWithDelay = useDelay(show, enterDelay, exitDelay);
  const isHidden = useHiddenDisplay(show, exitDelay, exitDuration, duration, onTransitionComplete);
  const childrenWithProps = getChildrenWithFocus(children, disableFocus, isHidden);
  return /* @__PURE__ */ React.createElement(
    Fade$1,
    __spreadValues$1h({
      in: showWithDelay,
      transition,
      unmountOnExit: hideDisplay
    }, rest),
    childrenWithProps
  );
};

var __defProp$1g = Object.defineProperty;
var __getOwnPropSymbols$1g = Object.getOwnPropertySymbols;
var __hasOwnProp$1g = Object.prototype.hasOwnProperty;
var __propIsEnum$1g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1g = (obj, key, value) => key in obj ? __defProp$1g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1g.call(b, prop))
      __defNormalProp$1g(a, prop, b[prop]);
  if (__getOwnPropSymbols$1g)
    for (var prop of __getOwnPropSymbols$1g(b)) {
      if (__propIsEnum$1g.call(b, prop))
        __defNormalProp$1g(a, prop, b[prop]);
    }
  return a;
};
var __objRest$12 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1g.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1g)
    for (var prop of __getOwnPropSymbols$1g(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1g.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ScaleFade = (_a) => {
  var _b = _a, {
    children,
    enterDuration = null,
    exitDuration = null,
    duration = null,
    in: show = false,
    disableFocus = true,
    hideDisplay = false,
    enterDelay = 0,
    exitDelay = 0,
    onTransitionComplete = identity
  } = _b, rest = __objRest$12(_b, [
    "children",
    "enterDuration",
    "exitDuration",
    "duration",
    "in",
    "disableFocus",
    "hideDisplay",
    "enterDelay",
    "exitDelay",
    "onTransitionComplete"
  ]);
  const transition = getDuration(enterDuration, exitDuration, duration);
  const showWithDelay = useDelay(show, enterDelay, exitDelay);
  const isHidden = useHiddenDisplay(show, exitDelay, exitDuration, duration, onTransitionComplete);
  const childrenWithProps = getChildrenWithFocus(children, disableFocus, isHidden);
  return /* @__PURE__ */ React.createElement(
    ScaleFade$1,
    __spreadValues$1g({
      in: showWithDelay,
      transition,
      unmountOnExit: hideDisplay
    }, rest),
    childrenWithProps
  );
};

var __defProp$1f = Object.defineProperty;
var __getOwnPropSymbols$1f = Object.getOwnPropertySymbols;
var __hasOwnProp$1f = Object.prototype.hasOwnProperty;
var __propIsEnum$1f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1f = (obj, key, value) => key in obj ? __defProp$1f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1f.call(b, prop))
      __defNormalProp$1f(a, prop, b[prop]);
  if (__getOwnPropSymbols$1f)
    for (var prop of __getOwnPropSymbols$1f(b)) {
      if (__propIsEnum$1f.call(b, prop))
        __defNormalProp$1f(a, prop, b[prop]);
    }
  return a;
};
var __objRest$11 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1f)
    for (var prop of __getOwnPropSymbols$1f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Slide = (_a) => {
  var _b = _a, {
    children,
    enterDuration = null,
    exitDuration = null,
    duration = null,
    in: show = false,
    disableFocus = true,
    hideDisplay = false,
    enterDelay = 0,
    exitDelay = 0,
    direction = "bottom",
    onTransitionComplete = identity
  } = _b, rest = __objRest$11(_b, [
    "children",
    "enterDuration",
    "exitDuration",
    "duration",
    "in",
    "disableFocus",
    "hideDisplay",
    "enterDelay",
    "exitDelay",
    "direction",
    "onTransitionComplete"
  ]);
  const transition = getDuration(enterDuration, exitDuration, duration);
  const showWithDelay = useDelay(show, enterDelay, exitDelay);
  const isHidden = useHiddenDisplay(show, exitDelay, exitDuration, duration, onTransitionComplete);
  const childrenWithProps = getChildrenWithFocus(children, disableFocus, isHidden);
  return /* @__PURE__ */ React.createElement(
    Slide$1,
    __spreadValues$1f({
      in: showWithDelay,
      transition,
      direction,
      unmountOnExit: hideDisplay
    }, rest),
    childrenWithProps
  );
};

var __defProp$1e = Object.defineProperty;
var __getOwnPropSymbols$1e = Object.getOwnPropertySymbols;
var __hasOwnProp$1e = Object.prototype.hasOwnProperty;
var __propIsEnum$1e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1e = (obj, key, value) => key in obj ? __defProp$1e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1e.call(b, prop))
      __defNormalProp$1e(a, prop, b[prop]);
  if (__getOwnPropSymbols$1e)
    for (var prop of __getOwnPropSymbols$1e(b)) {
      if (__propIsEnum$1e.call(b, prop))
        __defNormalProp$1e(a, prop, b[prop]);
    }
  return a;
};
var __objRest$10 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1e.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1e)
    for (var prop of __getOwnPropSymbols$1e(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1e.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SlideFade = (_a) => {
  var _b = _a, {
    children,
    enterDuration = null,
    exitDuration = null,
    duration = null,
    in: show = false,
    disableFocus = true,
    hideDisplay = false,
    direction = "bottom",
    offset: delta = defaultOffset,
    offsetX: deltaX = 0,
    offsetY: deltaY = 0,
    enterDelay = 0,
    exitDelay = 0,
    onTransitionComplete = identity
  } = _b, rest = __objRest$10(_b, [
    "children",
    "enterDuration",
    "exitDuration",
    "duration",
    "in",
    "disableFocus",
    "hideDisplay",
    "direction",
    "offset",
    "offsetX",
    "offsetY",
    "enterDelay",
    "exitDelay",
    "onTransitionComplete"
  ]);
  const transition = getDuration(enterDuration, exitDuration, duration);
  const { offsetX, offsetY } = getOffsets(direction, delta, deltaX, deltaY);
  const showWithDelay = useDelay(show, enterDelay, exitDelay);
  const isHidden = useHiddenDisplay(show, exitDelay, exitDuration, duration, onTransitionComplete);
  const childrenWithProps = getChildrenWithFocus(children, disableFocus, isHidden);
  return /* @__PURE__ */ React.createElement(
    SlideFade$1,
    __spreadValues$1e({
      in: showWithDelay,
      transition,
      offsetX,
      offsetY,
      unmountOnExit: hideDisplay
    }, rest),
    childrenWithProps
  );
};

var __defProp$1d = Object.defineProperty;
var __getOwnPropSymbols$1d = Object.getOwnPropertySymbols;
var __hasOwnProp$1d = Object.prototype.hasOwnProperty;
var __propIsEnum$1d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1d = (obj, key, value) => key in obj ? __defProp$1d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1d.call(b, prop))
      __defNormalProp$1d(a, prop, b[prop]);
  if (__getOwnPropSymbols$1d)
    for (var prop of __getOwnPropSymbols$1d(b)) {
      if (__propIsEnum$1d.call(b, prop))
        __defNormalProp$1d(a, prop, b[prop]);
    }
  return a;
};
var __objRest$$ = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1d)
    for (var prop of __getOwnPropSymbols$1d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Collapse = (_a) => {
  var _b = _a, {
    children,
    enterDuration = null,
    exitDuration = null,
    duration = null,
    in: show = false,
    disableFocus = true,
    hideDisplay = false,
    enterDelay = 0,
    exitDelay = 0,
    onTransitionComplete = identity
  } = _b, rest = __objRest$$(_b, [
    "children",
    "enterDuration",
    "exitDuration",
    "duration",
    "in",
    "disableFocus",
    "hideDisplay",
    "enterDelay",
    "exitDelay",
    "onTransitionComplete"
  ]);
  const transition = getDuration(enterDuration, exitDuration, duration);
  const showWithDelay = useDelay(show, enterDelay, exitDelay);
  const isHidden = useHiddenDisplay(show, exitDelay, exitDuration, duration, onTransitionComplete);
  const childrenWithProps = getChildrenWithFocus(children, disableFocus, isHidden);
  return /* @__PURE__ */ React.createElement(
    Collapse$1,
    __spreadValues$1d({
      in: showWithDelay,
      transition,
      unmountOnExit: hideDisplay
    }, rest),
    childrenWithProps
  );
};

var __defProp$1c = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1c = Object.getOwnPropertySymbols;
var __hasOwnProp$1c = Object.prototype.hasOwnProperty;
var __propIsEnum$1c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1c = (obj, key, value) => key in obj ? __defProp$1c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1c.call(b, prop))
      __defNormalProp$1c(a, prop, b[prop]);
  if (__getOwnPropSymbols$1c)
    for (var prop of __getOwnPropSymbols$1c(b)) {
      if (__propIsEnum$1c.call(b, prop))
        __defNormalProp$1c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
var __objRest$_ = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1c)
    for (var prop of __getOwnPropSymbols$1c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Toolbox = (_a) => {
  var _b = _a, {
    isResizable = false,
    isOpen = false,
    children,
    direction = "right",
    shouldPush = false,
    size = "sm",
    onClose,
    autoFocus = true,
    resizeLimit = "full"
  } = _b, rest = __objRest$_(_b, [
    "isResizable",
    "isOpen",
    "children",
    "direction",
    "shouldPush",
    "size",
    "onClose",
    "autoFocus",
    "resizeLimit"
  ]);
  const { container } = useMultiStyleConfig$1("Toolbox", { size });
  const newChildren = getChildrenWithProps(
    children,
    { onClose },
    (_child, i) => i === 0
  );
  const handleKeyDown = (e) => {
    if (e.key === "Escape") {
      e.stopPropagation();
      onClose == null ? void 0 : onClose();
    }
  };
  const getPixelSize = (sizeToken) => {
    const widthInRem = useToken("sizes", sizeToken);
    return parseFloat(widthInRem) * 16;
  };
  const defaultWidthPx = getPixelSize(size);
  const minWidthPx = getPixelSize("sm");
  const maxWidthPx = resizeLimit === "half" ? 0.5 * window.innerWidth : window.innerWidth;
  const { adjustableWidth, resizeProps } = useResizeWidth({
    minWidthPx,
    maxWidthPx,
    defaultWidthPx,
    stationaryEdge: direction
  });
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      w: adjustableWidth,
      display: isOpen && shouldPush ? "initial" : "none"
    },
    /* @__PURE__ */ React.createElement(Portal, null, /* @__PURE__ */ React.createElement(
      Slide,
      {
        direction,
        in: isOpen,
        style: {
          height: container.h,
          width: adjustableWidth,
          zIndex: coreZIndex.overlay
        }
      },
      /* @__PURE__ */ React.createElement(
        Flex,
        __spreadValues$1c({
          sx: __spreadProps$c(__spreadValues$1c({}, container), { w: adjustableWidth }),
          onKeyDown: handleKeyDown,
          position: "relative",
          overflow: "hidden",
          direction: direction === "left" ? "row-reverse" : "row"
        }, rest),
        isResizable && /* @__PURE__ */ React.createElement(ResizeHandle, __spreadValues$1c({}, resizeProps)),
        /* @__PURE__ */ React.createElement(FocusScope, { autoFocus }, /* @__PURE__ */ React.createElement(Box, { width: "full", height: "full" }, newChildren))
      )
    ))
  );
};

var __defProp$1b = Object.defineProperty;
var __getOwnPropSymbols$1b = Object.getOwnPropertySymbols;
var __hasOwnProp$1b = Object.prototype.hasOwnProperty;
var __propIsEnum$1b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1b = (obj, key, value) => key in obj ? __defProp$1b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1b.call(b, prop))
      __defNormalProp$1b(a, prop, b[prop]);
  if (__getOwnPropSymbols$1b)
    for (var prop of __getOwnPropSymbols$1b(b)) {
      if (__propIsEnum$1b.call(b, prop))
        __defNormalProp$1b(a, prop, b[prop]);
    }
  return a;
};
var __objRest$Z = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1b.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1b)
    for (var prop of __getOwnPropSymbols$1b(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1b.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ToolboxHeader = (_a) => {
  var _b = _a, {
    children,
    onClose
  } = _b, rest = __objRest$Z(_b, [
    "children",
    "onClose"
  ]);
  const { header } = useMultiStyleConfig$1("Toolbox", {});
  return /* @__PURE__ */ React.createElement(Flex, __spreadValues$1b({ sx: header }, rest), typeof children === "string" ? /* @__PURE__ */ React.createElement(H4$1, null, children) : children, /* @__PURE__ */ React.createElement(
    CloseButton$1,
    {
      "aria-label": "Close toolbox",
      position: "fixed",
      right: 4,
      onClick: onClose
    }
  ));
};

var __defProp$1a = Object.defineProperty;
var __getOwnPropSymbols$1a = Object.getOwnPropertySymbols;
var __hasOwnProp$1a = Object.prototype.hasOwnProperty;
var __propIsEnum$1a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1a = (obj, key, value) => key in obj ? __defProp$1a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1a.call(b, prop))
      __defNormalProp$1a(a, prop, b[prop]);
  if (__getOwnPropSymbols$1a)
    for (var prop of __getOwnPropSymbols$1a(b)) {
      if (__propIsEnum$1a.call(b, prop))
        __defNormalProp$1a(a, prop, b[prop]);
    }
  return a;
};
var __objRest$Y = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1a.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1a)
    for (var prop of __getOwnPropSymbols$1a(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1a.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ToolboxContent = (_a) => {
  var _b = _a, { children } = _b, rest = __objRest$Y(_b, ["children"]);
  const { body } = useMultiStyleConfig$1("Toolbox", {});
  return /* @__PURE__ */ React.createElement(
    Flex,
    __spreadValues$1a({
      sx: body
    }, rest),
    children
  );
};

var __defProp$19 = Object.defineProperty;
var __getOwnPropSymbols$19 = Object.getOwnPropertySymbols;
var __hasOwnProp$19 = Object.prototype.hasOwnProperty;
var __propIsEnum$19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$19 = (obj, key, value) => key in obj ? __defProp$19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$19 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$19.call(b, prop))
      __defNormalProp$19(a, prop, b[prop]);
  if (__getOwnPropSymbols$19)
    for (var prop of __getOwnPropSymbols$19(b)) {
      if (__propIsEnum$19.call(b, prop))
        __defNormalProp$19(a, prop, b[prop]);
    }
  return a;
};
var __objRest$X = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$19.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$19)
    for (var prop of __getOwnPropSymbols$19(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$19.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ToolboxFooter = (_a) => {
  var _b = _a, { children } = _b, rest = __objRest$X(_b, ["children"]);
  const { footer } = useMultiStyleConfig$1("Toolbox", {});
  return /* @__PURE__ */ React.createElement(Flex, __spreadValues$19({ sx: footer }, rest), children);
};

var __defProp$18 = Object.defineProperty;
var __getOwnPropSymbols$18 = Object.getOwnPropertySymbols;
var __hasOwnProp$18 = Object.prototype.hasOwnProperty;
var __propIsEnum$18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$18 = (obj, key, value) => key in obj ? __defProp$18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$18 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$18.call(b, prop))
      __defNormalProp$18(a, prop, b[prop]);
  if (__getOwnPropSymbols$18)
    for (var prop of __getOwnPropSymbols$18(b)) {
      if (__propIsEnum$18.call(b, prop))
        __defNormalProp$18(a, prop, b[prop]);
    }
  return a;
};
var __objRest$W = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$18.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$18)
    for (var prop of __getOwnPropSymbols$18(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$18.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Radio = (_a) => {
  var _b = _a, {
    size = "md",
    onChange,
    name,
    value
  } = _b, rest = __objRest$W(_b, [
    "size",
    "onChange",
    "name",
    "value"
  ]);
  return /* @__PURE__ */ React.createElement(
    Radio$2,
    __spreadValues$18({
      size,
      id: name,
      onChange,
      value
    }, rest)
  );
};

var __defProp$17 = Object.defineProperty;
var __getOwnPropSymbols$17 = Object.getOwnPropertySymbols;
var __hasOwnProp$17 = Object.prototype.hasOwnProperty;
var __propIsEnum$17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$17 = (obj, key, value) => key in obj ? __defProp$17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$17 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$17.call(b, prop))
      __defNormalProp$17(a, prop, b[prop]);
  if (__getOwnPropSymbols$17)
    for (var prop of __getOwnPropSymbols$17(b)) {
      if (__propIsEnum$17.call(b, prop))
        __defNormalProp$17(a, prop, b[prop]);
    }
  return a;
};
var __objRest$V = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$17.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$17)
    for (var prop of __getOwnPropSymbols$17(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$17.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RadioGroup = (_a) => {
  var _b = _a, {
    direction = "row",
    children,
    name
  } = _b, rest = __objRest$V(_b, [
    "direction",
    "children",
    "name"
  ]);
  return /* @__PURE__ */ React.createElement(RadioGroup$1, __spreadValues$17({ name, id: name }, rest), /* @__PURE__ */ React.createElement(Stack, { direction }, children));
};

var __defProp$16 = Object.defineProperty;
var __getOwnPropSymbols$16 = Object.getOwnPropertySymbols;
var __hasOwnProp$16 = Object.prototype.hasOwnProperty;
var __propIsEnum$16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$16 = (obj, key, value) => key in obj ? __defProp$16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$16 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$16.call(b, prop))
      __defNormalProp$16(a, prop, b[prop]);
  if (__getOwnPropSymbols$16)
    for (var prop of __getOwnPropSymbols$16(b)) {
      if (__propIsEnum$16.call(b, prop))
        __defNormalProp$16(a, prop, b[prop]);
    }
  return a;
};
var __objRest$U = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$16.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$16)
    for (var prop of __getOwnPropSymbols$16(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$16.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RadioGroupField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    children,
    direction,
    isRequired,
    validate,
    onChange: onChangeCallback = identity
  } = _b, rest = __objRest$U(_b, [
    "name",
    "label",
    "children",
    "direction",
    "isRequired",
    "validate",
    "onChange"
  ]);
  return /* @__PURE__ */ React.createElement(Box, { w: label ? "full" : "fit-content" }, /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      RadioGroup,
      __spreadValues$16({
        name,
        onChange: (e) => {
          onChange(e);
          onChangeCallback(e);
        },
        direction,
        value,
        "data-testid": "radio-group-field-test-id"
      }, rest),
      children
    )
  ));
});

const carouselItemWidth = 150;
const carouselItemSpacing = 60;

const variants = {
  active: { scale: 1.15, opacity: 1 },
  inActive: { scale: 0.95, opacity: 0.7 }
};
const CarouselItem = ({
  children,
  isActive = false,
  itemWidth = carouselItemWidth,
  itemHeight = carouselItemWidth
}) => /* @__PURE__ */ React.createElement(motion.div, { animate: isActive ? "active" : "inActive", variants }, /* @__PURE__ */ React.createElement(Center, { minW: `${itemWidth}px`, h: `${itemHeight}px ` }, children));

var __defProp$15 = Object.defineProperty;
var __getOwnPropSymbols$15 = Object.getOwnPropertySymbols;
var __hasOwnProp$15 = Object.prototype.hasOwnProperty;
var __propIsEnum$15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$15 = (obj, key, value) => key in obj ? __defProp$15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$15 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$15.call(b, prop))
      __defNormalProp$15(a, prop, b[prop]);
  if (__getOwnPropSymbols$15)
    for (var prop of __getOwnPropSymbols$15(b)) {
      if (__propIsEnum$15.call(b, prop))
        __defNormalProp$15(a, prop, b[prop]);
    }
  return a;
};
var __objRest$T = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$15.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$15)
    for (var prop of __getOwnPropSymbols$15(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$15.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const CarouselArrow = (_a) => {
  var _b = _a, {
    onClick,
    direction
  } = _b, rest = __objRest$T(_b, [
    "onClick",
    "direction"
  ]);
  const { arrow } = useMultiStyleConfig("Carousel", {});
  return /* @__PURE__ */ React.createElement(
    Center,
    __spreadValues$15({
      sx: arrow,
      onClick
    }, rest),
    /* @__PURE__ */ React.createElement(IconButton, { "aria-label": `move carousel to ${direction}`, variant: "ghost", size: "lg" }, /* @__PURE__ */ React.createElement(Icon$1, { as: direction === "right" ? ChevronRightSolid : ChevronLeftSolid }))
  );
};

var __defProp$14 = Object.defineProperty;
var __getOwnPropSymbols$14 = Object.getOwnPropertySymbols;
var __hasOwnProp$14 = Object.prototype.hasOwnProperty;
var __propIsEnum$14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$14 = (obj, key, value) => key in obj ? __defProp$14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$14 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$14.call(b, prop))
      __defNormalProp$14(a, prop, b[prop]);
  if (__getOwnPropSymbols$14)
    for (var prop of __getOwnPropSymbols$14(b)) {
      if (__propIsEnum$14.call(b, prop))
        __defNormalProp$14(a, prop, b[prop]);
    }
  return a;
};
var __objRest$S = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$14.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$14)
    for (var prop of __getOwnPropSymbols$14(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$14.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Carousel = (_a) => {
  var _b = _a, {
    children,
    showArrows = true,
    showRadio = true,
    value: controlledIndex = 0,
    onChange = identity,
    itemWidth = carouselItemWidth,
    itemHeight = carouselItemWidth,
    spacing = carouselItemSpacing,
    carouselStyles = {}
  } = _b, rest = __objRest$S(_b, [
    "children",
    "showArrows",
    "showRadio",
    "value",
    "onChange",
    "itemWidth",
    "itemHeight",
    "spacing",
    "carouselStyles"
  ]);
  const [dragging, setDragging] = useState(false);
  const [containerWidth, setContainerWidth] = useState(0);
  const [activeIndex, setActiveIndex] = useState(0);
  const x = useMotionValue(0);
  const { radio, container } = useMultiStyleConfig("Carousel", {});
  const childrenAsArray = Children.toArray(children);
  const numberOfChildren = Children.count(children);
  const carouselTotalWidth = itemWidth + spacing;
  const totalWidth = carouselTotalWidth * numberOfChildren;
  const containerRef = useRef(null);
  useEffect(() => {
    setContainerWidth(containerRef.current.clientWidth);
  }, []);
  const getNewX = () => -(activeIndex * carouselTotalWidth);
  const updateActiveIndex = () => {
    setActiveIndex(Math.abs(Math.round(x.get() / carouselTotalWidth)));
  };
  useEffect(() => {
    animate(x, getNewX());
    onChange(activeIndex);
  }, [activeIndex]);
  useEffect(() => {
    setActiveIndex(controlledIndex);
  }, [controlledIndex]);
  const handleRightArrowClick = () => {
    setActiveIndex(
      (prev) => activeIndex === numberOfChildren - 1 ? 0 : prev + 1
    );
  };
  const handleLeftArrowClick = () => {
    setActiveIndex(
      (prev) => activeIndex === 0 ? numberOfChildren - 1 : prev - 1
    );
  };
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadValues$14({
      cursor: dragging ? "grabbing" : "grab",
      onMouseDown: () => setDragging(true),
      onMouseUp: () => setDragging(false),
      ref: containerRef,
      pl: `${(containerWidth - itemWidth) / 2}px`,
      sx: container
    }, rest),
    /* @__PURE__ */ React.createElement(
      motion.div,
      {
        drag: "x",
        style: {
          width: `${totalWidth}px`,
          height: "100%",
          x
        },
        dragConstraints: { right: 0, left: -(totalWidth - itemWidth) },
        onDragEnd: updateActiveIndex
      },
      /* @__PURE__ */ React.createElement(
        HStack,
        __spreadValues$14({
          spacing: `${spacing}px`,
          width: `${totalWidth}px`,
          h: "full"
        }, carouselStyles),
        childrenAsArray.map((child, index) => /* @__PURE__ */ React.createElement(
          CarouselItem,
          {
            isActive: index === activeIndex,
            itemWidth,
            itemHeight,
            key: `carousel-item-${index}`
          },
          child
        ))
      )
    ),
    showRadio && /* @__PURE__ */ React.createElement(
      RadioGroup,
      {
        onChange: (val) => setActiveIndex(parseInt(val, 10)),
        value: `${activeIndex}`,
        sx: radio
      },
      /* @__PURE__ */ React.createElement(HStack, null, childrenAsArray.map((_child, i) => /* @__PURE__ */ React.createElement(
        Radio,
        {
          value: `${i}`,
          size: "lg",
          key: `carousel-radio-${i}`
        }
      )))
    ),
    showArrows && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      CarouselArrow,
      {
        direction: "left",
        onClick: handleLeftArrowClick,
        left: "2"
      }
    ), /* @__PURE__ */ React.createElement(
      CarouselArrow,
      {
        direction: "right",
        onClick: handleRightArrowClick,
        right: "2"
      }
    ))
  );
};

var __defProp$13 = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$13 = Object.getOwnPropertySymbols;
var __hasOwnProp$13 = Object.prototype.hasOwnProperty;
var __propIsEnum$13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$13 = (obj, key, value) => key in obj ? __defProp$13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$13 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$13.call(b, prop))
      __defNormalProp$13(a, prop, b[prop]);
  if (__getOwnPropSymbols$13)
    for (var prop of __getOwnPropSymbols$13(b)) {
      if (__propIsEnum$13.call(b, prop))
        __defNormalProp$13(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
const searchBarStyles = (sx) => merge({
  container: (provided) => __spreadProps$b(__spreadValues$13({}, provided), {
    width: "100%",
    color: "text.default",
    alignSelf: "center"
  }),
  option: (provided, state) => __spreadProps$b(__spreadValues$13({}, provided), {
    background: state.isFocused && "background.select.option-focus",
    _active: {
      background: "background.select.option-active"
    }
  }),
  valueContainer: (provided) => __spreadProps$b(__spreadValues$13({}, provided), {
    paddingInlineStart: "padding-inline.select.default"
  }),
  downChevron: (provided) => __spreadProps$b(__spreadValues$13({}, provided), {
    color: "icon.select.default"
  }),
  placeholder: (provided) => __spreadProps$b(__spreadValues$13({}, provided), {
    color: "text.select.placeholder"
  }),
  multiValue: (provided, state) => {
    var _a;
    const background = state.data.isFixed ? "background.select.option-disabled" : (_a = state.data.color) != null ? _a : provided.bgColor;
    return __spreadValues$13(__spreadProps$b(__spreadValues$13({}, provided), {
      bgColor: background,
      color: getContrastColor(background)
    }), sx.multiValue);
  },
  menuList: (provided) => __spreadProps$b(__spreadValues$13({}, provided), {
    bgColor: "background.default"
  })
}, sx);

var __defProp$12 = Object.defineProperty;
var __getOwnPropSymbols$12 = Object.getOwnPropertySymbols;
var __hasOwnProp$12 = Object.prototype.hasOwnProperty;
var __propIsEnum$12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$12 = (obj, key, value) => key in obj ? __defProp$12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$12 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$12.call(b, prop))
      __defNormalProp$12(a, prop, b[prop]);
  if (__getOwnPropSymbols$12)
    for (var prop of __getOwnPropSymbols$12(b)) {
      if (__propIsEnum$12.call(b, prop))
        __defNormalProp$12(a, prop, b[prop]);
    }
  return a;
};
var __objRest$R = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$12.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$12)
    for (var prop of __getOwnPropSymbols$12(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$12.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function getComponents() {
  return {
    Menu: (props) => /* @__PURE__ */ React.createElement(Box, { "data-testid": "select-menu-wrapper-test-id" }, /* @__PURE__ */ React.createElement(chakraComponents.Menu, __spreadValues$12({}, props), props.children)),
    DropdownIndicator: (props) => props.selectProps.icon ? /* @__PURE__ */ React.createElement(chakraComponents.DropdownIndicator, __spreadValues$12({}, props), /* @__PURE__ */ React.createElement(Icon$1, { as: props.selectProps.icon })) : /* @__PURE__ */ React.createElement(chakraComponents.DropdownIndicator, __spreadValues$12({}, props)),
    Option: (props) => props.selectProps.customOption ? /* @__PURE__ */ React.createElement(chakraComponents.Option, __spreadValues$12({}, props), props.selectProps.customOption(props.data)) : /* @__PURE__ */ React.createElement(chakraComponents.Option, __spreadValues$12({}, props)),
    MultiValueContainer: (props) => props.selectProps.customTag ? /* @__PURE__ */ React.createElement(chakraComponents.MultiValueContainer, __spreadValues$12({}, props), props.selectProps.customTag(props.data)) : /* @__PURE__ */ React.createElement(chakraComponents.MultiValueContainer, __spreadValues$12({}, props)),
    Control: (_a) => {
      var _b = _a, { children } = _b, props = __objRest$R(_b, ["children"]);
      return props.selectProps.leftComponent ? /* @__PURE__ */ React.createElement(chakraComponents.Control, __spreadValues$12({}, props), /* @__PURE__ */ React.createElement(HStack, { w: "full", pl: "2" }, props.selectProps.leftComponent, /* @__PURE__ */ React.createElement(HStack, { w: "full", justify: "space-between" }, children))) : /* @__PURE__ */ React.createElement(chakraComponents.Control, __spreadValues$12({}, props), children);
    }
  };
}

var __defProp$11 = Object.defineProperty;
var __getOwnPropSymbols$11 = Object.getOwnPropertySymbols;
var __hasOwnProp$11 = Object.prototype.hasOwnProperty;
var __propIsEnum$11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$11 = (obj, key, value) => key in obj ? __defProp$11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$11 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$11.call(b, prop))
      __defNormalProp$11(a, prop, b[prop]);
  if (__getOwnPropSymbols$11)
    for (var prop of __getOwnPropSymbols$11(b)) {
      if (__propIsEnum$11.call(b, prop))
        __defNormalProp$11(a, prop, b[prop]);
    }
  return a;
};
var __objRest$Q = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$11.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$11)
    for (var prop of __getOwnPropSymbols$11(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$11.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SearchBar = forwardRef$1(
  (_a, ref) => {
    var _b = _a, {
      defaultOptions = [],
      isMulti,
      customOption = null,
      customTag = null,
      sx = {},
      debouncedWaitTime = 200,
      loadOptions: getCustomOptions = null,
      clearInputOnSelect = true,
      closeMenuOnSelect = false,
      onChange = identity,
      onAdd = identity,
      onRemove = identity,
      "data-testid": testId,
      value,
      onSearchInputChange = identity,
      icon = SearchDuo
    } = _b, rest = __objRest$Q(_b, [
      "defaultOptions",
      "isMulti",
      "customOption",
      "customTag",
      "sx",
      "debouncedWaitTime",
      "loadOptions",
      "clearInputOnSelect",
      "closeMenuOnSelect",
      "onChange",
      "onAdd",
      "onRemove",
      "data-testid",
      "value",
      "onSearchInputChange",
      "icon"
    ]);
    const [filtered, setFiltered] = useState(defaultOptions);
    const [filterInput, setFilterInput] = useState("");
    const debounceFunction = useMemo(
      () => createDebounceFunctionInstance(debouncedWaitTime),
      [debouncedWaitTime]
    );
    const handleChange = useSelectCallbacks({
      onChange,
      onAdd,
      onRemove,
      isMulti,
      value: is(Array, value) ? value : []
    });
    const customComponents = useMemo(
      () => getComponents(),
      []
    );
    const simpleFilter = (query) => filter(
      (option) => test(new RegExp(toLower(query), "g"), toLower(option.label)),
      defaultOptions
    );
    const getOptions = async (query) => {
      const newOptions = getCustomOptions ? await getCustomOptions(query) : simpleFilter(query);
      setFiltered(newOptions);
      return newOptions;
    };
    const loadOptions = debounceFunction(async (query, callback) => {
      const newOptions = await getOptions(query);
      callback(newOptions);
      return [];
    });
    const resetFiltered = (v, { action }) => {
      if (clearInputOnSelect || action !== "set-value") {
        setFilterInput(v);
        onSearchInputChange(v);
        if (v === "") {
          setFiltered(defaultOptions);
        }
      }
    };
    return /* @__PURE__ */ React.createElement(Box, { w: "full", "data-testid": testId }, /* @__PURE__ */ React.createElement(
      AsyncSelect,
      __spreadValues$11({
        cacheOptions: true,
        defaultOptions: filtered,
        loadOptions,
        onChange: handleChange,
        placeholder: "Search...",
        chakraStyles: searchBarStyles(sx),
        isMulti,
        useBasicStyles: true,
        selectedOptionStyle: "check",
        hideSelectedOptions: false,
        closeMenuOnSelect,
        isClearable: false,
        onInputChange: resetFiltered,
        inputValue: filterInput,
        customOption,
        customTag,
        icon,
        components: customComponents,
        ref,
        value
      }, rest)
    ));
  }
);

var __defProp$10 = Object.defineProperty;
var __getOwnPropSymbols$10 = Object.getOwnPropertySymbols;
var __hasOwnProp$10 = Object.prototype.hasOwnProperty;
var __propIsEnum$10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$10 = (obj, key, value) => key in obj ? __defProp$10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$10 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$10.call(b, prop))
      __defNormalProp$10(a, prop, b[prop]);
  if (__getOwnPropSymbols$10)
    for (var prop of __getOwnPropSymbols$10(b)) {
      if (__propIsEnum$10.call(b, prop))
        __defNormalProp$10(a, prop, b[prop]);
    }
  return a;
};
var __objRest$P = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$10.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$10)
    for (var prop of __getOwnPropSymbols$10(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$10.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const BaseSearchBarField = (_a, ref) => {
  var _b = _a, {
    name,
    label,
    direction = "column",
    isMulti,
    isRequired,
    validate,
    isClearable = true,
    onChange: onChangeCallback = identity,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$P(_b, [
    "name",
    "label",
    "direction",
    "isMulti",
    "isRequired",
    "validate",
    "isClearable",
    "onChange",
    "inputLeftElement",
    "inputRightElement"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      noLabelConnection: true,
      validate,
      ref
    },
    ({ value, onChange }) => /* @__PURE__ */ React.createElement(HStack, { w: "full" }, /* @__PURE__ */ React.createElement(
      InputGroupWrapper,
      {
        inputLeftElement,
        inputRightElement
      },
      /* @__PURE__ */ React.createElement(
        SearchBar,
        __spreadValues$10({
          name,
          isMulti,
          onChange: (values, event) => {
            onChange(
              isMulti ? values : values.value
            );
            onChangeCallback(values, event);
          },
          value
        }, rest)
      )
    ), /* @__PURE__ */ React.createElement(
      IconButton,
      {
        "aria-label": `${name}-close-button`,
        variant: "danger",
        size: "lg",
        fontSize: "sm",
        hidden: isEmpty(value) || !isClearable,
        onClick: () => onChange([]),
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: XCloseSolid })
      }
    ))
  );
};
const SearchBarField = forwardRef$1(BaseSearchBarField);

var __defProp$$ = Object.defineProperty;
var __getOwnPropSymbols$$ = Object.getOwnPropertySymbols;
var __hasOwnProp$$ = Object.prototype.hasOwnProperty;
var __propIsEnum$$ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$$ = (obj, key, value) => key in obj ? __defProp$$(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$$ = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$$.call(b, prop))
      __defNormalProp$$(a, prop, b[prop]);
  if (__getOwnPropSymbols$$)
    for (var prop of __getOwnPropSymbols$$(b)) {
      if (__propIsEnum$$.call(b, prop))
        __defNormalProp$$(a, prop, b[prop]);
    }
  return a;
};
const DragAndDrop = (props) => /* @__PURE__ */ React.createElement(DndContext, __spreadValues$$({}, props));

var __defProp$_ = Object.defineProperty;
var __getOwnPropSymbols$_ = Object.getOwnPropertySymbols;
var __hasOwnProp$_ = Object.prototype.hasOwnProperty;
var __propIsEnum$_ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$_ = (obj, key, value) => key in obj ? __defProp$_(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$_ = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$_.call(b, prop))
      __defNormalProp$_(a, prop, b[prop]);
  if (__getOwnPropSymbols$_)
    for (var prop of __getOwnPropSymbols$_(b)) {
      if (__propIsEnum$_.call(b, prop))
        __defNormalProp$_(a, prop, b[prop]);
    }
  return a;
};
var __objRest$O = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$_.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$_)
    for (var prop of __getOwnPropSymbols$_(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$_.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Tag = forwardRef$1((_a, ref) => {
  var _b = _a, {
    children,
    variant = "solid",
    bgColor,
    colorScheme
  } = _b, rest = __objRest$O(_b, [
    "children",
    "variant",
    "bgColor",
    "colorScheme"
  ]);
  return /* @__PURE__ */ React.createElement(
    Tag$2,
    __spreadValues$_({
      bgColor,
      colorScheme,
      ref,
      variant
    }, rest),
    children
  );
});

const OverflowIndicator = ({
  nbrRemainingTags
}) => /* @__PURE__ */ React.createElement(Tag, { variant: "subtle", minW: "max-content" }, "+", nbrRemainingTags);

var __defProp$Z = Object.defineProperty;
var __getOwnPropSymbols$Z = Object.getOwnPropertySymbols;
var __hasOwnProp$Z = Object.prototype.hasOwnProperty;
var __propIsEnum$Z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Z = (obj, key, value) => key in obj ? __defProp$Z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$Z.call(b, prop))
      __defNormalProp$Z(a, prop, b[prop]);
  if (__getOwnPropSymbols$Z)
    for (var prop of __getOwnPropSymbols$Z(b)) {
      if (__propIsEnum$Z.call(b, prop))
        __defNormalProp$Z(a, prop, b[prop]);
    }
  return a;
};
var __objRest$N = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$Z.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$Z)
    for (var prop of __getOwnPropSymbols$Z(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$Z.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TagGroup = (_a) => {
  var _b = _a, {
    children,
    max = Infinity,
    spacing = "2",
    OverflowIndicator: OverflowIndicator$1 = OverflowIndicator
  } = _b, rest = __objRest$N(_b, [
    "children",
    "max",
    "spacing",
    "OverflowIndicator"
  ]);
  const [nbrRemainingTags, setNbrRemainingTags] = useState(0);
  const { rect, containerRef } = useOverflowGroup();
  return /* @__PURE__ */ React.createElement(
    HStack,
    __spreadValues$Z({
      bgColor: "background.default",
      ref: containerRef,
      overflow: "hidden"
    }, rest),
    /* @__PURE__ */ React.createElement(HStack, { spacing }, /* @__PURE__ */ React.createElement(OverflowGroup, { max, onChange: setNbrRemainingTags, rect }, children)),
    nbrRemainingTags > 0 && /* @__PURE__ */ React.createElement(OverflowIndicator$1, { nbrRemainingTags })
  );
};

var __defProp$Y = Object.defineProperty;
var __getOwnPropSymbols$Y = Object.getOwnPropertySymbols;
var __hasOwnProp$Y = Object.prototype.hasOwnProperty;
var __propIsEnum$Y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Y = (obj, key, value) => key in obj ? __defProp$Y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$Y.call(b, prop))
      __defNormalProp$Y(a, prop, b[prop]);
  if (__getOwnPropSymbols$Y)
    for (var prop of __getOwnPropSymbols$Y(b)) {
      if (__propIsEnum$Y.call(b, prop))
        __defNormalProp$Y(a, prop, b[prop]);
    }
  return a;
};
var __objRest$M = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$Y.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$Y)
    for (var prop of __getOwnPropSymbols$Y(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$Y.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DragItem = forwardRef$1(
  (_a, ref) => {
    var _b = _a, {
      size = "md",
      isDragging,
      itemLabel = "Drag Me",
      bgColor
    } = _b, rest = __objRest$M(_b, [
      "size",
      "isDragging",
      "itemLabel",
      "bgColor"
    ]);
    return /* @__PURE__ */ React.createElement(
      Tag,
      __spreadValues$Y({
        ref,
        cursor: isDragging ? "grabbing" : "grab",
        bgColor: bgColor || (isDragging ? "blue.200" : void 0),
        size,
        minW: "max-content"
      }, rest),
      /* @__PURE__ */ React.createElement(TagLabel, null, itemLabel),
      /* @__PURE__ */ React.createElement(TagRightIcon, null, /* @__PURE__ */ React.createElement(Icon$1, { as: DotsMatrixSolid }))
    );
  }
);

var __defProp$X = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$X = Object.getOwnPropertySymbols;
var __hasOwnProp$X = Object.prototype.hasOwnProperty;
var __propIsEnum$X = Object.prototype.propertyIsEnumerable;
var __defNormalProp$X = (obj, key, value) => key in obj ? __defProp$X(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$X = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$X.call(b, prop))
      __defNormalProp$X(a, prop, b[prop]);
  if (__getOwnPropSymbols$X)
    for (var prop of __getOwnPropSymbols$X(b)) {
      if (__propIsEnum$X.call(b, prop))
        __defNormalProp$X(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
var __objRest$L = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$X.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$X)
    for (var prop of __getOwnPropSymbols$X(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$X.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Draggable = (_a) => {
  var _b = _a, {
    itemLabel,
    children,
    disableDrag = false,
    "data-testid": dataTestId
  } = _b, rest = __objRest$L(_b, [
    "itemLabel",
    "children",
    "disableDrag",
    "data-testid"
  ]);
  const _a2 = useDraggable(__spreadValues$X({}, rest)), {
    attributes,
    listeners,
    setNodeRef,
    transform,
    isDragging
  } = _a2, props = __objRest$L(_a2, [
    "attributes",
    "listeners",
    "setNodeRef",
    "transform",
    "isDragging"
  ]);
  if (!listeners) {
    return /* @__PURE__ */ React.createElement(DragItem, { itemLabel });
  }
  const childrenWithDragCursor = isValidElement(children) ? cloneElement(children, {
    cursor: isDragging ? "grabbing" : "grab"
  }) : children;
  const dragEventListeners = !disableDrag && listeners;
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadValues$X(__spreadProps$a(__spreadValues$X({
      ref: setNodeRef
    }, attributes), {
      transform: CSS.Translate.toString(transform),
      _focusVisible: ring,
      tabIndex: disableDrag ? -1 : 0,
      w: "max-content",
      "data-testid": dataTestId
    }), dragEventListeners),
    typeof childrenWithDragCursor === "function" ? childrenWithDragCursor(listeners, props) : childrenWithDragCursor || /* @__PURE__ */ React.createElement(DragItem, { isDragging, itemLabel })
  );
};

var __defProp$W = Object.defineProperty;
var __getOwnPropSymbols$W = Object.getOwnPropertySymbols;
var __hasOwnProp$W = Object.prototype.hasOwnProperty;
var __propIsEnum$W = Object.prototype.propertyIsEnumerable;
var __defNormalProp$W = (obj, key, value) => key in obj ? __defProp$W(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$W = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$W.call(b, prop))
      __defNormalProp$W(a, prop, b[prop]);
  if (__getOwnPropSymbols$W)
    for (var prop of __getOwnPropSymbols$W(b)) {
      if (__propIsEnum$W.call(b, prop))
        __defNormalProp$W(a, prop, b[prop]);
    }
  return a;
};
var __objRest$K = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$W.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$W)
    for (var prop of __getOwnPropSymbols$W(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$W.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Droppable = (_a) => {
  var _b = _a, {
    children,
    "data-testid": testId
  } = _b, rest = __objRest$K(_b, [
    "children",
    "data-testid"
  ]);
  const _a2 = useDroppable(__spreadValues$W({}, rest)), { setNodeRef } = _a2, props = __objRest$K(_a2, ["setNodeRef"]);
  return /* @__PURE__ */ React.createElement(Box, { ref: setNodeRef, "data-testid": testId }, typeof children === "function" ? children(props) : children || /* @__PURE__ */ React.createElement(Center, null, "Drop here"));
};

var __defProp$V = Object.defineProperty;
var __getOwnPropSymbols$V = Object.getOwnPropertySymbols;
var __hasOwnProp$V = Object.prototype.hasOwnProperty;
var __propIsEnum$V = Object.prototype.propertyIsEnumerable;
var __defNormalProp$V = (obj, key, value) => key in obj ? __defProp$V(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$V = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$V.call(b, prop))
      __defNormalProp$V(a, prop, b[prop]);
  if (__getOwnPropSymbols$V)
    for (var prop of __getOwnPropSymbols$V(b)) {
      if (__propIsEnum$V.call(b, prop))
        __defNormalProp$V(a, prop, b[prop]);
    }
  return a;
};
const Sortable = (props) => /* @__PURE__ */ React.createElement(SortableContext, __spreadValues$V({}, props));

var __defProp$U = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$U = Object.getOwnPropertySymbols;
var __hasOwnProp$U = Object.prototype.hasOwnProperty;
var __propIsEnum$U = Object.prototype.propertyIsEnumerable;
var __defNormalProp$U = (obj, key, value) => key in obj ? __defProp$U(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$U = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$U.call(b, prop))
      __defNormalProp$U(a, prop, b[prop]);
  if (__getOwnPropSymbols$U)
    for (var prop of __getOwnPropSymbols$U(b)) {
      if (__propIsEnum$U.call(b, prop))
        __defNormalProp$U(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
var __objRest$J = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$U.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$U)
    for (var prop of __getOwnPropSymbols$U(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$U.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SortableItem = (_a) => {
  var _b = _a, {
    itemLabel = "Drag me",
    dblClickThreshold = 300,
    children,
    disableDrag = false,
    "data-testid": dataTestId
  } = _b, rest = __objRest$J(_b, [
    "itemLabel",
    "dblClickThreshold",
    "children",
    "disableDrag",
    "data-testid"
  ]);
  const _a2 = useSortable(__spreadValues$U({}, rest)), {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = _a2, props = __objRest$J(_a2, [
    "attributes",
    "listeners",
    "setNodeRef",
    "transform",
    "transition",
    "isDragging"
  ]);
  if (!listeners) {
    return /* @__PURE__ */ React.createElement(DragItem, { itemLabel });
  }
  const timeStampSnapchot = useRef(0);
  const inEditMode = useRef(false);
  const { onPointerDown, onKeyDown } = listeners;
  const handlePointerDown = (e) => {
    const elapsedTime = e.timeStamp - timeStampSnapchot.current;
    if (elapsedTime > dblClickThreshold) {
      inEditMode.current = true;
      onPointerDown(e);
    } else {
      inEditMode.current = false;
    }
    timeStampSnapchot.current = e.timeStamp;
  };
  const handleKeyDown = (e) => {
    if (inEditMode.current) {
      onKeyDown(e);
    }
  };
  const style = {
    transform: CSS.Translate.toString(transform),
    transition
  };
  const childrenWithDragCursor = isValidElement(children) ? cloneElement(children, {
    cursor: isDragging ? "grabbing" : "grab"
  }) : children;
  const dragEventListeners = !disableDrag && {
    onPointerDown: handlePointerDown,
    onKeyDown: handleKeyDown
  };
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadValues$U(__spreadProps$9(__spreadValues$U({
      ref: setNodeRef,
      sx: style
    }, attributes), {
      _focusVisible: ring,
      tabIndex: disableDrag ? -1 : 0,
      borderRadius: "tag.default",
      "data-testid": dataTestId
    }), dragEventListeners),
    (typeof childrenWithDragCursor === "function" ? childrenWithDragCursor(listeners, props) : childrenWithDragCursor) || /* @__PURE__ */ React.createElement(DragItem, { isDragging, itemLabel })
  );
};

var __defProp$T = Object.defineProperty;
var __getOwnPropSymbols$T = Object.getOwnPropertySymbols;
var __hasOwnProp$T = Object.prototype.hasOwnProperty;
var __propIsEnum$T = Object.prototype.propertyIsEnumerable;
var __defNormalProp$T = (obj, key, value) => key in obj ? __defProp$T(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$T = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$T.call(b, prop))
      __defNormalProp$T(a, prop, b[prop]);
  if (__getOwnPropSymbols$T)
    for (var prop of __getOwnPropSymbols$T(b)) {
      if (__propIsEnum$T.call(b, prop))
        __defNormalProp$T(a, prop, b[prop]);
    }
  return a;
};
var __objRest$I = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$T.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$T)
    for (var prop of __getOwnPropSymbols$T(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$T.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DragHandle = (_a) => {
  var _b = _a, { icon, isDragging } = _b, rest = __objRest$I(_b, ["icon", "isDragging"]);
  return /* @__PURE__ */ React.createElement(
    Icon$1,
    __spreadValues$T({
      as: icon || DragDuo,
      cursor: isDragging ? "grabbing" : "grab"
    }, rest)
  );
};

var __defProp$S = Object.defineProperty;
var __getOwnPropSymbols$S = Object.getOwnPropertySymbols;
var __hasOwnProp$S = Object.prototype.hasOwnProperty;
var __propIsEnum$S = Object.prototype.propertyIsEnumerable;
var __defNormalProp$S = (obj, key, value) => key in obj ? __defProp$S(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$S = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$S.call(b, prop))
      __defNormalProp$S(a, prop, b[prop]);
  if (__getOwnPropSymbols$S)
    for (var prop of __getOwnPropSymbols$S(b)) {
      if (__propIsEnum$S.call(b, prop))
        __defNormalProp$S(a, prop, b[prop]);
    }
  return a;
};
var __objRest$H = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$S.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$S)
    for (var prop of __getOwnPropSymbols$S(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$S.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DropZone = (_a) => {
  var _b = _a, { sx = {}, name, children } = _b, rest = __objRest$H(_b, ["sx", "name", "children"]);
  const { dropZone } = useMultiStyleConfig("DragAndDrop", { sx });
  return /* @__PURE__ */ React.createElement(Droppable, { id: name }, /* @__PURE__ */ React.createElement(Stack, __spreadValues$S({ sx: dropZone }, rest), children));
};

var __defProp$R = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$R = Object.getOwnPropertySymbols;
var __hasOwnProp$R = Object.prototype.hasOwnProperty;
var __propIsEnum$R = Object.prototype.propertyIsEnumerable;
var __defNormalProp$R = (obj, key, value) => key in obj ? __defProp$R(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$R = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$R.call(b, prop))
      __defNormalProp$R(a, prop, b[prop]);
  if (__getOwnPropSymbols$R)
    for (var prop of __getOwnPropSymbols$R(b)) {
      if (__propIsEnum$R.call(b, prop))
        __defNormalProp$R(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
function MultiSort({
  items,
  onChange = () => {
  },
  children,
  collisionDetection,
  sensors
}) {
  const [activeItem, setActiveItem] = useState(null);
  const moveBetweenContainers = (activeContainerName, activeIndex, overContainerName, overIndex, item) => __spreadProps$8(__spreadValues$R({}, items), {
    [activeContainerName]: remove(activeIndex, 1, items[activeContainerName]),
    [overContainerName]: insert(overIndex, item, items[overContainerName])
  });
  const customSensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    })
  );
  const findContainer = (id) => id in items ? id : keys(items).find((key) => items[key].includes(id));
  const getContainers = (e) => {
    const { active, over } = e;
    if (!over)
      return {};
    const { id } = active;
    const { id: overId } = over;
    const activeContainerName = findContainer(id);
    const overContainerName = findContainer(overId);
    return { activeContainerName, overContainerName, id, overId, active };
  };
  const handleDragStart = (e) => {
    const {
      active: { id }
    } = e;
    setActiveItem(id);
  };
  const handleDragOver = (e) => {
    const { activeContainerName, overContainerName, id, overId } = getContainers(e);
    if (!(!activeContainerName || !overContainerName || activeContainerName === overContainerName)) {
      const activeIndex = indexOf(id, items[activeContainerName]);
      const overIndex = indexOf(overId, items[overContainerName]);
      onChange(moveBetweenContainers(
        activeContainerName,
        activeIndex,
        overContainerName,
        overIndex,
        id
      ));
    }
  };
  const handleDragEnd = (e) => {
    const { activeContainerName, overContainerName, id, overId, active } = getContainers(e);
    if (!activeContainerName || !overContainerName)
      return;
    const activeIndex = indexOf(id, items[activeContainerName]);
    const overIndex = indexOf(overId, items[overContainerName]);
    if (activeContainerName === overContainerName) {
      onChange(__spreadProps$8(__spreadValues$R({}, items), {
        [overContainerName]: arrayMove(
          items[overContainerName],
          activeIndex,
          overIndex
        )
      }));
    } else {
      onChange(moveBetweenContainers(
        activeContainerName,
        activeIndex,
        overContainerName,
        overIndex,
        active == null ? void 0 : active.id
      ));
    }
  };
  return /* @__PURE__ */ React.createElement(
    DragAndDrop,
    {
      sensors: sensors || customSensors,
      onDragStart: handleDragStart,
      onDragOver: handleDragOver,
      onDragEnd: handleDragEnd,
      collisionDetection: collisionDetection || rectIntersection
    },
    typeof children === "function" ? children(items, activeItem) : children
  );
}

function SortableList({
  children,
  items,
  collisionDetection,
  createKey = identity,
  strategy,
  onChange = () => {
  },
  onMovedItem = identity,
  displayOverlay = false,
  sensors,
  dblClickThreshold = 300,
  disableDrag = false,
  modifiers
}) {
  const [activeItem, setActiveItem] = useState(null);
  const identifierItems = useMemo(() => map(createKey, items), [items]);
  const customSensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    })
  );
  const handleDragStart = (event) => {
    const {
      active: { id }
    } = event;
    setActiveItem(id);
  };
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (active && over && active.id !== over.id) {
      const prevIds = map(createKey, items);
      const oldIndex = indexOf(active.id, prevIds);
      const newIndex = indexOf(over.id, prevIds);
      onMovedItem({ item: items[oldIndex], oldIndex, newIndex });
      const newItems = arrayMove(items, oldIndex, newIndex);
      onChange(newItems);
    }
  };
  return /* @__PURE__ */ React.createElement(
    DragAndDrop,
    {
      sensors: sensors || customSensors,
      collisionDetection: collisionDetection || rectIntersection,
      onDragStart: handleDragStart,
      onDragEnd: handleDragEnd,
      modifiers
    },
    /* @__PURE__ */ React.createElement(
      Sortable,
      {
        items: identifierItems,
        strategy: strategy || rectSortingStrategy
      },
      items.map((item, index) => {
        const id = createKey(item);
        return /* @__PURE__ */ React.createElement(
          SortableItem,
          {
            key: id,
            id,
            itemLabel: id,
            dblClickThreshold,
            disableDrag
          },
          (listeners, props) => typeof children === "function" ? children(item, listeners, props, index) : children
        );
      })
    ),
    displayOverlay && /* @__PURE__ */ React.createElement(DragOverlay, null, activeItem ? /* @__PURE__ */ React.createElement(DragItem, { itemLabel: activeItem }) : null)
  );
}

const SortableContainer = ({ children, items, strategy }) => /* @__PURE__ */ React.createElement(Sortable, { items, strategy: strategy || rectSortingStrategy }, items.map((id) => /* @__PURE__ */ React.createElement(SortableItem, { key: id, id, itemLabel: id }, typeof children === "function" ? children(id) : children)));

var __defProp$Q = Object.defineProperty;
var __getOwnPropSymbols$Q = Object.getOwnPropertySymbols;
var __hasOwnProp$Q = Object.prototype.hasOwnProperty;
var __propIsEnum$Q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Q = (obj, key, value) => key in obj ? __defProp$Q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$Q.call(b, prop))
      __defNormalProp$Q(a, prop, b[prop]);
  if (__getOwnPropSymbols$Q)
    for (var prop of __getOwnPropSymbols$Q(b)) {
      if (__propIsEnum$Q.call(b, prop))
        __defNormalProp$Q(a, prop, b[prop]);
    }
  return a;
};
var __objRest$G = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$Q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$Q)
    for (var prop of __getOwnPropSymbols$Q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$Q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FastList = forwardRef$1((_a, ref) => {
  var _b = _a, {
    itemCount,
    itemSize,
    direction = "column",
    children,
    width,
    height,
    overscanCount = 0,
    initialScrollOffset
  } = _b, rest = __objRest$G(_b, [
    "itemCount",
    "itemSize",
    "direction",
    "children",
    "width",
    "height",
    "overscanCount",
    "initialScrollOffset"
  ]);
  return /* @__PURE__ */ React.createElement(AutoSizer, null, ({ width: autoWidth, height: autoHeight }) => /* @__PURE__ */ React.createElement(
    VariableSizeList,
    __spreadValues$Q({
      itemCount,
      itemSize: typeof itemSize === "number" ? (_index) => itemSize : itemSize,
      height: height != null ? height : autoHeight,
      width: width != null ? width : autoWidth,
      layout: direction === "column" ? "vertical" : "horizontal",
      initialScrollOffset,
      overscanCount,
      ref
    }, rest),
    ({ style, index }) => /* @__PURE__ */ React.createElement("div", { style }, typeof children === "function" ? children(index) : children)
  ));
});

var __defProp$P = Object.defineProperty;
var __getOwnPropSymbols$P = Object.getOwnPropertySymbols;
var __hasOwnProp$P = Object.prototype.hasOwnProperty;
var __propIsEnum$P = Object.prototype.propertyIsEnumerable;
var __defNormalProp$P = (obj, key, value) => key in obj ? __defProp$P(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$P = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$P.call(b, prop))
      __defNormalProp$P(a, prop, b[prop]);
  if (__getOwnPropSymbols$P)
    for (var prop of __getOwnPropSymbols$P(b)) {
      if (__propIsEnum$P.call(b, prop))
        __defNormalProp$P(a, prop, b[prop]);
    }
  return a;
};
var __objRest$F = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$P.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$P)
    for (var prop of __getOwnPropSymbols$P(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$P.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FastGrid = forwardRef$1((_a, ref) => {
  var _b = _a, {
    columns,
    rows,
    columnSize,
    rowSize,
    children,
    width,
    height,
    overscanRowCount = 0,
    overscanColumnCount = 0
  } = _b, rest = __objRest$F(_b, [
    "columns",
    "rows",
    "columnSize",
    "rowSize",
    "children",
    "width",
    "height",
    "overscanRowCount",
    "overscanColumnCount"
  ]);
  return /* @__PURE__ */ React.createElement(AutoSizer, null, ({ width: autoWidth, height: autoHeight }) => /* @__PURE__ */ React.createElement(
    VariableSizeGrid,
    __spreadValues$P({
      rowCount: rows,
      columnCount: columns,
      columnWidth: typeof columnSize === "number" ? (_index) => columnSize : columnSize,
      rowHeight: typeof rowSize === "number" ? (_index) => rowSize : rowSize,
      height: height != null ? height : autoHeight,
      width: width != null ? width : autoWidth,
      overscanRowCount,
      overscanColumnCount,
      ref
    }, rest),
    ({ style, rowIndex, columnIndex }) => /* @__PURE__ */ React.createElement("div", { style }, typeof children === "function" ? children(rowIndex, columnIndex) : children)
  ));
});

var __defProp$O = Object.defineProperty;
var __getOwnPropSymbols$O = Object.getOwnPropertySymbols;
var __hasOwnProp$O = Object.prototype.hasOwnProperty;
var __propIsEnum$O = Object.prototype.propertyIsEnumerable;
var __defNormalProp$O = (obj, key, value) => key in obj ? __defProp$O(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$O = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$O.call(b, prop))
      __defNormalProp$O(a, prop, b[prop]);
  if (__getOwnPropSymbols$O)
    for (var prop of __getOwnPropSymbols$O(b)) {
      if (__propIsEnum$O.call(b, prop))
        __defNormalProp$O(a, prop, b[prop]);
    }
  return a;
};
const EditableControls = ({ size }) => {
  const {
    getSubmitButtonProps,
    getCancelButtonProps
  } = useEditableControls();
  const { onEdit, isEditing } = useEditableState();
  const { button, icon, controls } = useMultiStyleConfig("EditableText", { size, isEditing });
  return /* @__PURE__ */ React.createElement(HStack, { spacing: 1, sx: controls }, isEditing ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    IconButton,
    __spreadValues$O({
      "aria-label": "Cancel",
      sx: button,
      variant: "danger"
    }, getCancelButtonProps()),
    /* @__PURE__ */ React.createElement(Icon$1, { sx: icon, as: XCloseSolid })
  ), /* @__PURE__ */ React.createElement(
    IconButton,
    __spreadValues$O({
      "aria-label": "Save",
      sx: button,
      variant: "success"
    }, getSubmitButtonProps()),
    /* @__PURE__ */ React.createElement(Icon$1, { sx: icon, as: CheckDuo })
  )) : /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "Edit",
      variant: "ghost",
      sx: button,
      onClick: onEdit
    },
    /* @__PURE__ */ React.createElement(Icon$1, { sx: icon, as: EditDuo })
  ));
};

var __defProp$N = Object.defineProperty;
var __getOwnPropSymbols$N = Object.getOwnPropertySymbols;
var __hasOwnProp$N = Object.prototype.hasOwnProperty;
var __propIsEnum$N = Object.prototype.propertyIsEnumerable;
var __defNormalProp$N = (obj, key, value) => key in obj ? __defProp$N(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$N = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$N.call(b, prop))
      __defNormalProp$N(a, prop, b[prop]);
  if (__getOwnPropSymbols$N)
    for (var prop of __getOwnPropSymbols$N(b)) {
      if (__propIsEnum$N.call(b, prop))
        __defNormalProp$N(a, prop, b[prop]);
    }
  return a;
};
var __objRest$E = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$N.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$N)
    for (var prop of __getOwnPropSymbols$N(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$N.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const EditableText = (_a) => {
  var _b = _a, {
    size = "md",
    value: inputValue,
    onSubmit,
    leftItem
  } = _b, rest = __objRest$E(_b, [
    "size",
    "value",
    "onSubmit",
    "leftItem"
  ]);
  const [value, setValue] = useState(inputValue);
  const { input, preview } = useMultiStyleConfig("EditableText", { size, value });
  useEffect(() => {
    setValue(inputValue);
  }, [inputValue]);
  return /* @__PURE__ */ React.createElement(
    Editable,
    __spreadValues$N({
      isPreviewFocusable: true,
      selectAllOnFocus: false,
      value,
      onChange: (newValue) => setValue(newValue),
      onSubmit
    }, rest),
    /* @__PURE__ */ React.createElement(InputGroup, { size }, leftItem && /* @__PURE__ */ React.createElement(InputLeftElement, null, leftItem), /* @__PURE__ */ React.createElement(
      Input$1,
      {
        as: EditablePreview,
        sx: preview
      }
    ), /* @__PURE__ */ React.createElement(
      Input$1,
      {
        as: EditableInput,
        size,
        sx: input
      }
    ), /* @__PURE__ */ React.createElement(InputRightElement, { sx: { width: "min-content" } }, /* @__PURE__ */ React.createElement(EditableControls, { size })))
  );
};

var __defProp$M = Object.defineProperty;
var __getOwnPropSymbols$M = Object.getOwnPropertySymbols;
var __hasOwnProp$M = Object.prototype.hasOwnProperty;
var __propIsEnum$M = Object.prototype.propertyIsEnumerable;
var __defNormalProp$M = (obj, key, value) => key in obj ? __defProp$M(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$M = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$M.call(b, prop))
      __defNormalProp$M(a, prop, b[prop]);
  if (__getOwnPropSymbols$M)
    for (var prop of __getOwnPropSymbols$M(b)) {
      if (__propIsEnum$M.call(b, prop))
        __defNormalProp$M(a, prop, b[prop]);
    }
  return a;
};
var __objRest$D = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$M.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$M)
    for (var prop of __getOwnPropSymbols$M(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$M.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ModalBase = (_a) => {
  var _b = _a, {
    isCentered = true,
    children
  } = _b, rest = __objRest$D(_b, [
    "isCentered",
    "children"
  ]);
  return /* @__PURE__ */ React.createElement(
    Modal$2,
    __spreadValues$M({
      isCentered,
      scrollBehavior: "inside",
      motionPreset: "slideInBottom"
    }, rest),
    /* @__PURE__ */ React.createElement(ModalOverlay, null),
    /* @__PURE__ */ React.createElement(ModalContent, { "data-testid": "modal-test-id" }, /* @__PURE__ */ React.createElement(ModalCloseButton, { "data-testid": "modal-test-button-id" }), children)
  );
};

var __defProp$L = Object.defineProperty;
var __getOwnPropSymbols$L = Object.getOwnPropertySymbols;
var __hasOwnProp$L = Object.prototype.hasOwnProperty;
var __propIsEnum$L = Object.prototype.propertyIsEnumerable;
var __defNormalProp$L = (obj, key, value) => key in obj ? __defProp$L(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$L = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$L.call(b, prop))
      __defNormalProp$L(a, prop, b[prop]);
  if (__getOwnPropSymbols$L)
    for (var prop of __getOwnPropSymbols$L(b)) {
      if (__propIsEnum$L.call(b, prop))
        __defNormalProp$L(a, prop, b[prop]);
    }
  return a;
};
var __objRest$C = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$L.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$L)
    for (var prop of __getOwnPropSymbols$L(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$L.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Modal = (_a) => {
  var _b = _a, {
    stayMountedOnClose = false,
    isOpen
  } = _b, rest = __objRest$C(_b, [
    "stayMountedOnClose",
    "isOpen"
  ]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, (stayMountedOnClose || isOpen) && /* @__PURE__ */ React.createElement(ModalBase, __spreadValues$L({ isOpen }, rest)));
};

var __defProp$K = Object.defineProperty;
var __getOwnPropSymbols$K = Object.getOwnPropertySymbols;
var __hasOwnProp$K = Object.prototype.hasOwnProperty;
var __propIsEnum$K = Object.prototype.propertyIsEnumerable;
var __defNormalProp$K = (obj, key, value) => key in obj ? __defProp$K(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$K = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$K.call(b, prop))
      __defNormalProp$K(a, prop, b[prop]);
  if (__getOwnPropSymbols$K)
    for (var prop of __getOwnPropSymbols$K(b)) {
      if (__propIsEnum$K.call(b, prop))
        __defNormalProp$K(a, prop, b[prop]);
    }
  return a;
};
const ModalBody = (props) => /* @__PURE__ */ React.createElement(ModalBody$1, __spreadValues$K({ minH: props.h, maxH: props.h }, props));

var __defProp$J = Object.defineProperty;
var __getOwnPropSymbols$J = Object.getOwnPropertySymbols;
var __hasOwnProp$J = Object.prototype.hasOwnProperty;
var __propIsEnum$J = Object.prototype.propertyIsEnumerable;
var __defNormalProp$J = (obj, key, value) => key in obj ? __defProp$J(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$J = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$J.call(b, prop))
      __defNormalProp$J(a, prop, b[prop]);
  if (__getOwnPropSymbols$J)
    for (var prop of __getOwnPropSymbols$J(b)) {
      if (__propIsEnum$J.call(b, prop))
        __defNormalProp$J(a, prop, b[prop]);
    }
  return a;
};
var __objRest$B = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$J.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$J)
    for (var prop of __getOwnPropSymbols$J(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$J.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FileEditorModal = forwardRef$1((_a, ref) => {
  var _b = _a, {
    fileName,
    setFileName,
    isOpen,
    onClose,
    image = "",
    handleCrop,
    isImage,
    canEditFileName = true,
    canCropImage = false
  } = _b, rest = __objRest$B(_b, [
    "fileName",
    "setFileName",
    "isOpen",
    "onClose",
    "image",
    "handleCrop",
    "isImage",
    "canEditFileName",
    "canCropImage"
  ]);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [position, setPosition] = useState({ x: 0.5, y: 0.5 });
  const handleClose = () => {
    setZoomLevel(1);
    onClose();
  };
  return /* @__PURE__ */ React.createElement(
    Modal,
    __spreadValues$J({
      isOpen,
      onClose,
      closeOnOverlayClick: false
    }, rest),
    /* @__PURE__ */ React.createElement(ModalHeader, null, "Edit ", isImage ? "image" : "file"),
    /* @__PURE__ */ React.createElement(
      ModalBody,
      {
        display: "flex",
        justifyContent: "start",
        flexDirection: "column",
        alignItems: "center",
        gap: 4,
        minH: "300px"
      },
      /* @__PURE__ */ React.createElement(Stack, { display: isImage && canCropImage ? "inherit" : "none" }, /* @__PURE__ */ React.createElement(
        AvatarEditor,
        {
          ref,
          image: image || "",
          onPositionChange: (pos) => setPosition(pos),
          position,
          width: 250,
          height: 250,
          border: 50,
          color: [255, 255, 255, 0.7],
          scale: zoomLevel,
          rotate: 0
        }
      ), /* @__PURE__ */ React.createElement(HStack, { w: "90%" }, /* @__PURE__ */ React.createElement(FormLabel, null, "Zoom"), /* @__PURE__ */ React.createElement(
        Slider,
        {
          "aria-label": "zoom",
          defaultValue: zoomLevel,
          maxW: "50%",
          min: 0.1,
          step: 0.05,
          max: 10,
          onChange: (value) => setZoomLevel(value)
        },
        /* @__PURE__ */ React.createElement(SliderTrack, null, /* @__PURE__ */ React.createElement(SliderFilledTrack, null)),
        /* @__PURE__ */ React.createElement(SliderThumb, { boxSize: 6 }, /* @__PURE__ */ React.createElement(Icon$1, { as: ZoomInDuo }))
      ))),
      canEditFileName && /* @__PURE__ */ React.createElement(Stack, { w: "90%", direction: isImage ? "row" : "column", pt: 2 }, /* @__PURE__ */ React.createElement(FormLabel, null, "Name the file:"), /* @__PURE__ */ React.createElement(Box, { maxW: "50%" }, /* @__PURE__ */ React.createElement(EditableText, { onSubmit: (v) => setFileName(v), value: fileName, size: "sm" })))
    ),
    /* @__PURE__ */ React.createElement(ModalFooter, null, /* @__PURE__ */ React.createElement(HStack, null, /* @__PURE__ */ React.createElement(Button$1, { variant: "danger", onClick: handleClose }, "Cancel"), /* @__PURE__ */ React.createElement(Button$1, { variant: "success", onClick: handleCrop }, "Save")))
  );
});

var __defProp$I = Object.defineProperty;
var __getOwnPropSymbols$I = Object.getOwnPropertySymbols;
var __hasOwnProp$I = Object.prototype.hasOwnProperty;
var __propIsEnum$I = Object.prototype.propertyIsEnumerable;
var __defNormalProp$I = (obj, key, value) => key in obj ? __defProp$I(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$I = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$I.call(b, prop))
      __defNormalProp$I(a, prop, b[prop]);
  if (__getOwnPropSymbols$I)
    for (var prop of __getOwnPropSymbols$I(b)) {
      if (__propIsEnum$I.call(b, prop))
        __defNormalProp$I(a, prop, b[prop]);
    }
  return a;
};
var __objRest$A = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$I.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$I)
    for (var prop of __getOwnPropSymbols$I(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$I.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ConfirmDeleteModal = (_a) => {
  var _b = _a, {
    isOpen,
    onClose,
    confirmDelete,
    fileName
  } = _b, rest = __objRest$A(_b, [
    "isOpen",
    "onClose",
    "confirmDelete",
    "fileName"
  ]);
  const handleDelete = () => {
    confirmDelete();
    onClose();
  };
  return /* @__PURE__ */ React.createElement(Modal, __spreadValues$I({ isOpen, onClose }, rest), /* @__PURE__ */ React.createElement(
    ModalHeader,
    {
      sx: { fontSize: "lg" },
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      pr: 16
    },
    "Delete ",
    fileName
  ), /* @__PURE__ */ React.createElement(ModalBody, null, "Deleting this file is a permanent action. You will not be able to recover this file at a later time."), /* @__PURE__ */ React.createElement(ModalFooter, null, /* @__PURE__ */ React.createElement(Button$1, { variant: "danger", onClick: handleDelete }, "Delete")));
};

const updateTimeThreshold = 0.5;
const animationSlideTime = 250;

var __defProp$H = Object.defineProperty;
var __getOwnPropSymbols$H = Object.getOwnPropertySymbols;
var __hasOwnProp$H = Object.prototype.hasOwnProperty;
var __propIsEnum$H = Object.prototype.propertyIsEnumerable;
var __defNormalProp$H = (obj, key, value) => key in obj ? __defProp$H(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$H = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$H.call(b, prop))
      __defNormalProp$H(a, prop, b[prop]);
  if (__getOwnPropSymbols$H)
    for (var prop of __getOwnPropSymbols$H(b)) {
      if (__propIsEnum$H.call(b, prop))
        __defNormalProp$H(a, prop, b[prop]);
    }
  return a;
};
var __objRest$z = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$H.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$H)
    for (var prop of __getOwnPropSymbols$H(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$H.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ProgressBar = forwardRef$1(
  (_a, ref) => {
    var _b = _a, { animationSlideTimeMs = animationSlideTime, sx } = _b, props = __objRest$z(_b, ["animationSlideTimeMs", "sx"]);
    return /* @__PURE__ */ React.createElement(
      Progress,
      __spreadValues$H({
        ref,
        width: "full",
        height: "1a",
        borderRadius: "full",
        sx: __spreadValues$H({
          '>[role="progressbar"]': {
            transition: `width ${animationSlideTimeMs}ms ease-out`
          }
        }, sx)
      }, props)
    );
  }
);

const formattedTime = (seconds) => {
  let baseString = "";
  const hours = Math.floor(seconds / 3600);
  if (hours > 0) {
    baseString += ` ${hours}h`;
  }
  const minutes = Math.floor((seconds - hours * 3600) / 60);
  if (minutes > 0) {
    baseString += ` ${minutes}min`;
  }
  const newSeconds = Math.floor(seconds - hours * 3600 - minutes * 60);
  if (newSeconds > 0) {
    baseString += ` ${newSeconds}s`;
  }
  return baseString;
};

var __defProp$G = Object.defineProperty;
var __getOwnPropSymbols$G = Object.getOwnPropertySymbols;
var __hasOwnProp$G = Object.prototype.hasOwnProperty;
var __propIsEnum$G = Object.prototype.propertyIsEnumerable;
var __defNormalProp$G = (obj, key, value) => key in obj ? __defProp$G(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$G = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$G.call(b, prop))
      __defNormalProp$G(a, prop, b[prop]);
  if (__getOwnPropSymbols$G)
    for (var prop of __getOwnPropSymbols$G(b)) {
      if (__propIsEnum$G.call(b, prop))
        __defNormalProp$G(a, prop, b[prop]);
    }
  return a;
};
var __objRest$y = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$G.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$G)
    for (var prop of __getOwnPropSymbols$G(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$G.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const LoadingBar = (_a) => {
  var _b = _a, {
    loaded,
    onLoadEnd = () => {
    },
    hideDisplay = true
  } = _b, rest = __objRest$y(_b, [
    "loaded",
    "onLoadEnd",
    "hideDisplay"
  ]);
  const ref = useRef(null);
  const timeRef = useRef(0);
  const progress = Math.max(0, Math.min(loaded, 1));
  const [timeLeft, setTimeLeft] = useState(0);
  useEffect(() => {
    if (ref.current) {
      ref.current.children[0].style.width = `${progress * 100}%`;
    }
    if (timeRef.current) {
      const deltaTime = timeRef.current ? (Date.now() - timeRef.current) / 1e3 : 0;
      if (deltaTime > updateTimeThreshold) {
        const newEstimate = progress !== 0 ? deltaTime / progress : 0;
        setTimeLeft(Math.round(newEstimate - deltaTime));
      }
    } else if (progress > 0) {
      timeRef.current = Date.now();
    }
  }, [progress]);
  return /* @__PURE__ */ React.createElement(
    Fade,
    {
      in: progress < 1,
      enterDuration: 1,
      exitDelay: 250,
      exitDuration: 1e3,
      hideDisplay,
      onTransitionComplete: () => {
        if (progress >= 1) {
          onLoadEnd();
        }
      }
    },
    /* @__PURE__ */ React.createElement(VStack, __spreadValues$G({}, rest), /* @__PURE__ */ React.createElement(Small$1, null, Math.round(progress * 100), "%", " ", !!timeLeft && `\xB7 ${formattedTime(timeLeft)} left`), /* @__PURE__ */ React.createElement(
      ProgressBar,
      {
        ref,
        animationSlideTimeMs: animationSlideTime
      }
    ))
  );
};

const fiveHundredMB = 524288e3;
const imageLazyThreshold = 15728540;
const defaultEditOptions = {
  canEdit: true,
  canEditImage: true,
  canEditName: true
};

var __defProp$F = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$F = Object.getOwnPropertySymbols;
var __hasOwnProp$F = Object.prototype.hasOwnProperty;
var __propIsEnum$F = Object.prototype.propertyIsEnumerable;
var __defNormalProp$F = (obj, key, value) => key in obj ? __defProp$F(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$F = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$F.call(b, prop))
      __defNormalProp$F(a, prop, b[prop]);
  if (__getOwnPropSymbols$F)
    for (var prop of __getOwnPropSymbols$F(b)) {
      if (__propIsEnum$F.call(b, prop))
        __defNormalProp$F(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
const getResizingFactor = (imgWidth, imgHeight, maxWidth, maxHeight) => Math.min(1, Math.min(maxWidth / imgWidth, maxHeight / imgHeight));
const convertBlobToFile = (blob, name, type) => new File([blob], name, { type });
const compressImage = (file, maxWidth = 3e3, maxHeight = 3e3, quality = 0.75) => {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  if (!context)
    return file;
  const imageBuffer = new Image();
  imageBuffer.src = URL.createObjectURL(file);
  return new Promise((resolve) => {
    imageBuffer.onload = () => {
      const resizingFactor = getResizingFactor(
        imageBuffer.width,
        imageBuffer.height,
        maxWidth,
        maxHeight
      );
      const scaledWidth = imageBuffer.width * resizingFactor;
      const scaledHeight = imageBuffer.height * resizingFactor;
      canvas.width = scaledWidth;
      canvas.height = scaledHeight;
      context.drawImage(imageBuffer, 0, 0, scaledWidth, scaledHeight);
      canvas.toBlob(
        (blob) => {
          if (file && blob) {
            const newImage = convertBlobToFile(blob, file.name, file.type);
            resolve(newImage);
          } else {
            resolve(file);
          }
        },
        "image/jpeg",
        quality
      );
    };
  });
};
const readableFileSize = (size) => {
  if (size <= 0)
    return 0;
  const i = Math.floor(Math.log(size) / Math.log(1024));
  return `${(size / 1024 ** i).toFixed(1)} ${["B", "kB", "MB", "GB", "TB"][i]}`;
};
const getImageAsFile = async (image, name) => fetch(image.src).then((res) => res.blob()).then(
  (blob) => new Promise((resolve) => {
    const newImage = convertBlobToFile(blob, name || image.name, image.type);
    resolve(newImage);
  })
);
const getFormatsAsArray = (acceptFormat) => split(",", acceptFormat).map((format) => trim(format));
const getAcceptedExtensions = (acceptFormat) => getFormatsAsArray(acceptFormat).filter((format) => test(/^\./, format)).map((format) => format.substring(1));
const getAcceptedFormats = (acceptFormat) => getFormatsAsArray(acceptFormat).filter((format) => test(/\//, format)).map((format) => split("/", format)[0]);
const getFileExtension = (file) => last(split("/", file.type));
const getFileFormat = (file) => split("/", file.type)[0];
const validFileFormat = (file, acceptFormat) => acceptFormat === "*" || getAcceptedFormats(acceptFormat).includes(getFileFormat(file)) || getAcceptedExtensions(acceptFormat).includes(getFileExtension(file));
const isValidFile = (file, acceptFormat, maxFileSize) => {
  const isValid = file.size < maxFileSize && validFileFormat(file, acceptFormat);
  return {
    isValid,
    errorMessage: file.size > maxFileSize ? "File size is too big" : isValid ? "" : "File format not supported"
  };
};
function getNewUploadingFiles(prev, curr, files) {
  let buffer = prev;
  const prevIDs = prev ? prev.map((file) => file.name) : null;
  const currentIDs = curr ? curr.map((file) => file.name) : null;
  const removedItemsIDs = prevIDs && currentIDs && difference(prevIDs, currentIDs);
  const filesIDs = files.map((file) => file.name);
  if (removedItemsIDs) {
    if (removedItemsIDs.length === 0 || intersection(removedItemsIDs, filesIDs).length > 0) {
      buffer = curr;
    } else {
      buffer.forEach(
        (value, index) => {
          if (removedItemsIDs.includes(value.name)) {
            const updatedData = __spreadProps$7(__spreadValues$F({}, value), {
              uploaded: has("size", value) ? value.size : 0
            });
            buffer[index] = updatedData;
          }
        }
      );
    }
  } else {
    buffer = curr;
  }
  return buffer;
}
const generateId = () => Math.random().toString().substring(3);
const isFile = (file) => "File" in window && file instanceof File;
const isFileImage = (file) => {
  if (isFile(file)) {
    return getFileFormat(file) === "image";
  }
  switch (getFileFormat(file)) {
    case "image":
    case "jpeg":
    case "jpg":
    case "png":
    case "gif":
    case "tiff":
    case "jfif":
      return true;
    default:
      return false;
  }
};
const onlyAcceptsImages = (acceptFormat) => {
  if (acceptFormat === "*" || acceptFormat === "") {
    return false;
  }
  const formats = getAcceptedFormats(acceptFormat);
  const extensions = getAcceptedExtensions(acceptFormat);
  const premiseOne = isEmpty(formats) || all((type) => type === "image", formats);
  const premiseTwo = isEmpty(extensions) || all((type) => isFileImage({ type }), extensions);
  return premiseOne && premiseTwo;
};
const createFileObject = (file) => {
  const fileId = generateId();
  const fileObject = {
    _id: fileId,
    size: null,
    src: null,
    type: file.type,
    name: file.name,
    isUploading: true,
    isLazy: file.size > imageLazyThreshold && isFileImage(file)
  };
  return fileObject;
};
const createPreviewFileObject = (file) => {
  const fileId = generateId();
  const fileObject = {
    _id: fileId,
    size: file.size,
    src: URL.createObjectURL(file),
    type: file.type,
    name: file.name,
    isUploading: false,
    isLazy: false
  };
  return fileObject;
};
const createFileObjectFromSrc = (file) => {
  const fileId = generateId();
  const fileObject = {
    _id: fileId,
    size: null,
    src: file.src,
    type: file.type,
    name: file.name,
    isUploading: false,
    isLazy: false
  };
  return fileObject;
};
const isOverflowing = (element) => element ? element.scrollHeight > element.clientHeight : false;
const toBase64 = (file) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.readAsDataURL(file);
  reader.onload = () => resolve(reader.result);
  reader.onerror = (error) => reject(error);
});
const correctFileExtension = (str) => test(/./g, str);
const getFileFormattedName = (file) => correctFileExtension(file.name) ? file.name : `${file.name}.${getFileExtension(file)}`;
const handleDownload = (file) => () => {
  if (!file)
    return;
  const anchor = document.createElement("a");
  anchor.href = isFile(file) ? URL.createObjectURL(file) : file.src || "";
  anchor.download = isFile(file) ? "downloaded-file.jpg" : getFileFormattedName(file);
  anchor.click();
};

var __defProp$E = Object.defineProperty;
var __getOwnPropSymbols$E = Object.getOwnPropertySymbols;
var __hasOwnProp$E = Object.prototype.hasOwnProperty;
var __propIsEnum$E = Object.prototype.propertyIsEnumerable;
var __defNormalProp$E = (obj, key, value) => key in obj ? __defProp$E(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$E = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$E.call(b, prop))
      __defNormalProp$E(a, prop, b[prop]);
  if (__getOwnPropSymbols$E)
    for (var prop of __getOwnPropSymbols$E(b)) {
      if (__propIsEnum$E.call(b, prop))
        __defNormalProp$E(a, prop, b[prop]);
    }
  return a;
};
var __objRest$x = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$E.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$E)
    for (var prop of __getOwnPropSymbols$E(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$E.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FileIconButton = (_a) => {
  var _b = _a, {
    icon,
    color = "unset"
  } = _b, rest = __objRest$x(_b, [
    "icon",
    "color"
  ]);
  return /* @__PURE__ */ React.createElement(IconButton, __spreadValues$E({ variant: "ghost", size: "sm" }, rest), /* @__PURE__ */ React.createElement(Icon$1, { as: icon, boxSize: "24px", color }));
};

var __defProp$D = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$D = Object.getOwnPropertySymbols;
var __hasOwnProp$D = Object.prototype.hasOwnProperty;
var __propIsEnum$D = Object.prototype.propertyIsEnumerable;
var __defNormalProp$D = (obj, key, value) => key in obj ? __defProp$D(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$D = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$D.call(b, prop))
      __defNormalProp$D(a, prop, b[prop]);
  if (__getOwnPropSymbols$D)
    for (var prop of __getOwnPropSymbols$D(b)) {
      if (__propIsEnum$D.call(b, prop))
        __defNormalProp$D(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
var __objRest$w = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$D.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$D)
    for (var prop of __getOwnPropSymbols$D(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$D.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FilePicker = (_a) => {
  var _b = _a, {
    acceptFormat = "*",
    onChange = identity,
    compression,
    uploaded: uploadedInitial = 0,
    maxFileSize = fiveHundredMB,
    showProgress = false,
    value = "",
    loadWithSpinner = false,
    confirmDelete = false,
    editFileOptions = defaultEditOptions
  } = _b, rest = __objRest$w(_b, [
    "acceptFormat",
    "onChange",
    "compression",
    "uploaded",
    "maxFileSize",
    "showProgress",
    "value",
    "loadWithSpinner",
    "confirmDelete",
    "editFileOptions"
  ]);
  const fileInputRef = useRef(null);
  const imageEditorRef = useRef(null);
  const [file, setFile] = useState(value);
  const [isInvalid, setIsInvalid] = useState(false);
  const [name, setName] = useState("");
  const editModal = useDisclosure();
  const deleteModal = useDisclosure();
  const [editable, setEditable] = useState(false);
  const [hasLoaded, setHasLoaded] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isImage, setIsImage] = useState(true);
  const [uploaded, setUploaded] = useState(uploadedInitial);
  const onlyImageAccepted = onlyAcceptsImages(acceptFormat);
  const isUploading = uploaded < 1;
  useEffect(() => {
    setUploaded(uploadedInitial);
  }, [uploadedInitial]);
  useEffect(() => {
    if (!isUploading) {
      setIsLoading(false);
      setHasLoaded(true);
    }
  }, [isUploading]);
  const currentTheme = useCurrentTheme();
  const { filePicker } = useMultiStyleConfig("FilePicker", __spreadValues$D({
    isImage,
    hasLoaded,
    isInvalid,
    currentTheme
  }, rest));
  useEffect(() => {
    if (isInvalid) {
      setTimeout(() => {
        setIsInvalid(false);
      }, 1500);
    }
  }, [isInvalid]);
  const handleOnClick = () => {
    if (fileInputRef.current && !file) {
      fileInputRef.current.click();
    }
  };
  const handleCrop = () => {
    if (imageEditorRef.current) {
      const canvas = imageEditorRef.current.getImageScaledToCanvas();
      canvas.toBlob((blob) => {
        if (file && blob) {
          const fileName = name || isFile(file) ? file.name : "downloaded-file";
          const fileType = isFile(file) ? file.type : ".jpg";
          const newFile = convertBlobToFile(blob, fileName, fileType);
          setFile(newFile);
          setHasLoaded(true);
          onChange(newFile);
        }
      });
      editModal.onClose();
    }
  };
  const clearImage = () => {
    if (fileInputRef.current) {
      setIsInvalid(false);
      setName("");
      setFile(null);
      setIsImage(true);
      setHasLoaded(false);
      if (!showProgress) {
        setUploaded(0);
      }
      onChange(null);
      fileInputRef.current.value = "";
    }
  };
  const handleImageUpload = async (newImage) => {
    if (newImage) {
      setIsInvalid(false);
      const isFileTypeImage = isFileImage(newImage);
      setIsImage(isFileTypeImage);
      const compressedImage = isFileTypeImage ? await compressImage(
        newImage,
        compression == null ? void 0 : compression.width,
        compression == null ? void 0 : compression.height,
        compression == null ? void 0 : compression.quality
      ) : newImage;
      setFile(compressedImage);
      if (!showProgress) {
        setUploaded(1);
      }
      onChange(compressedImage);
      setIsLoading(isUploading);
    }
  };
  const handleChange = async (e) => {
    if (e.target.files) {
      setIsInvalid(false);
      const newImage = e.target.files[0];
      handleImageUpload(newImage);
    }
  };
  const handleDrop = (e) => {
    e.preventDefault();
    if (e.dataTransfer.files) {
      const newFile = e.dataTransfer.files[0];
      if (isValidFile(newFile, acceptFormat, maxFileSize).isValid) {
        handleImageUpload(newFile);
      } else {
        setIsInvalid(true);
      }
    }
  };
  return /* @__PURE__ */ React.createElement(Stack, __spreadValues$D({ maxW: filePicker.width }, rest), /* @__PURE__ */ React.createElement(
    Clickable,
    {
      onClick: handleOnClick,
      onDrop: handleDrop,
      onDragOver: (e) => e.preventDefault(),
      onMouseEnter: () => setEditable(true),
      onMouseLeave: () => setEditable(false)
    },
    /* @__PURE__ */ React.createElement(Box, { sx: filePicker }, /* @__PURE__ */ React.createElement(
      SlideFade$1,
      {
        in: hasLoaded,
        style: {
          width: "100%",
          height: "100%",
          display: hasLoaded && isImage ? "initial" : "none"
        }
      },
      /* @__PURE__ */ React.createElement(
        Image$1,
        {
          src: file ? isFile(file) ? URL.createObjectURL(file) : file : "",
          alt: "preview-image",
          objectFit: "cover",
          borderRadius: 8,
          display: hasLoaded && isImage ? "inherit" : "none",
          h: "full",
          w: "full"
        }
      )
    ), /* @__PURE__ */ React.createElement(
      Input$1,
      {
        type: "file",
        display: "none",
        accept: acceptFormat,
        ref: fileInputRef,
        onChange: handleChange
      }
    ), /* @__PURE__ */ React.createElement(
      Stack,
      {
        display: hasLoaded && isImage ? "none" : "default",
        alignItems: "center",
        w: "85%",
        spacing: "0a"
      },
      /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: onlyImageAccepted ? Image03Solid : UploadCloudSolid,
          boxSize: "32px",
          color: isInvalid ? "red.500" : editable ? "blue.500" : "gray.300",
          display: isImage && !hasLoaded ? "inline-block" : "none",
          "aria-label": "file-icon-upload"
        }
      ),
      /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: FileBlankDuo,
          boxSize: "32px",
          color: "gray.300",
          display: hasLoaded && !isImage ? "inline-block" : "none"
        }
      ),
      /* @__PURE__ */ React.createElement(
        P$1,
        {
          variant: isInvalid ? "16" : "14",
          whiteSpace: "nowrap",
          textOverflow: "ellipsis",
          overflow: "hidden",
          maxWidth: filePicker.width,
          textAlign: "center",
          alignSelf: "center"
        },
        isInvalid ? "File not supported" : file && isFile(file) ? file.name : `Drag & drop ${onlyImageAccepted ? "image" : "file"} or`
      ),
      /* @__PURE__ */ React.createElement(
        Lead$1,
        {
          sx: {
            textDecoration: "underline",
            color: isInvalid ? "red.500" : "blue.500"
          },
          display: isLoading || hasLoaded ? "none" : "default"
        },
        "Click to upload"
      ),
      /* @__PURE__ */ React.createElement(Box, { display: isLoading ? "block" : "none", pt: 1 }, loadWithSpinner ? /* @__PURE__ */ React.createElement(Spinner$1, null) : /* @__PURE__ */ React.createElement(LoadingBar, { loaded: uploaded }))
    ), /* @__PURE__ */ React.createElement(
      Fade$1,
      {
        in: hasLoaded && editable,
        style: {
          display: hasLoaded && editable ? "flex" : "none",
          justifyContent: "center"
        }
      },
      /* @__PURE__ */ React.createElement(
        HStack,
        {
          spacing: 2,
          position: "absolute",
          bottom: "3",
          justifyContent: "center",
          bgColor: "bg.layer",
          borderRadius: 6,
          width: "44",
          py: 2
        },
        editFileOptions.canEdit && /* @__PURE__ */ React.createElement(
          FileIconButton,
          {
            "aria-label": "edit-file",
            onClick: editModal.onOpen,
            icon: EditBoxDuo
          }
        ),
        /* @__PURE__ */ React.createElement(
          FileIconButton,
          {
            "aria-label": "download-file",
            onClick: handleDownload(file),
            icon: DownloadDuo
          }
        ),
        /* @__PURE__ */ React.createElement(
          FileIconButton,
          {
            "aria-label": "delete-file",
            onClick: confirmDelete ? deleteModal.onOpen : clearImage,
            icon: TrashFullDuo,
            color: "red.500"
          }
        )
      )
    ), /* @__PURE__ */ React.createElement(
      P$1,
      {
        variant: "14",
        sx: { color: "gray.400" },
        display: hasLoaded && !isImage && !isLoading ? "inline-block" : "none"
      },
      isFile(file) && readableFileSize(file == null ? void 0 : file.size)
    ))
  ), /* @__PURE__ */ React.createElement(
    FileEditorModal,
    __spreadProps$6(__spreadValues$D({}, editModal), {
      fileName: name,
      setFileName: setName,
      image: file,
      handleCrop,
      isImage,
      ref: imageEditorRef,
      canEditFileName: editFileOptions.canEditName,
      canCropImage: editFileOptions.canEditImage
    })
  ), /* @__PURE__ */ React.createElement(
    ConfirmDeleteModal,
    __spreadProps$6(__spreadValues$D({}, deleteModal), {
      confirmDelete: clearImage,
      fileName: name || "file"
    })
  ));
};

var __defProp$C = Object.defineProperty;
var __getOwnPropSymbols$C = Object.getOwnPropertySymbols;
var __hasOwnProp$C = Object.prototype.hasOwnProperty;
var __propIsEnum$C = Object.prototype.propertyIsEnumerable;
var __defNormalProp$C = (obj, key, value) => key in obj ? __defProp$C(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$C = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$C.call(b, prop))
      __defNormalProp$C(a, prop, b[prop]);
  if (__getOwnPropSymbols$C)
    for (var prop of __getOwnPropSymbols$C(b)) {
      if (__propIsEnum$C.call(b, prop))
        __defNormalProp$C(a, prop, b[prop]);
    }
  return a;
};
var __objRest$v = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$C.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$C)
    for (var prop of __getOwnPropSymbols$C(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$C.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FilePickerField = (_a) => {
  var _b = _a, {
    name,
    label,
    direction,
    isRequired,
    validate,
    onChange: onChangeCallback = identity
  } = _b, rest = __objRest$v(_b, [
    "name",
    "label",
    "direction",
    "isRequired",
    "validate",
    "onChange"
  ]);
  const [uploaded, setUploaded] = useState(0);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      FilePicker,
      __spreadValues$C({
        onChange: async (file) => {
          if (file) {
            const formattedFile = await toBase64(file);
            setUploaded(1);
            onChange(formattedFile);
            onChangeCallback(formattedFile);
          } else {
            setUploaded(0);
            onChange(null);
            onChangeCallback(null);
          }
        },
        value,
        uploaded: value ? 1 : uploaded,
        loadWithSpinner: true,
        acceptFormat: "image/*"
      }, rest)
    )
  );
};

var __defProp$B = Object.defineProperty;
var __getOwnPropSymbols$B = Object.getOwnPropertySymbols;
var __hasOwnProp$B = Object.prototype.hasOwnProperty;
var __propIsEnum$B = Object.prototype.propertyIsEnumerable;
var __defNormalProp$B = (obj, key, value) => key in obj ? __defProp$B(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$B = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$B.call(b, prop))
      __defNormalProp$B(a, prop, b[prop]);
  if (__getOwnPropSymbols$B)
    for (var prop of __getOwnPropSymbols$B(b)) {
      if (__propIsEnum$B.call(b, prop))
        __defNormalProp$B(a, prop, b[prop]);
    }
  return a;
};
var __objRest$u = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$B.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$B)
    for (var prop of __getOwnPropSymbols$B(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$B.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function MultiFileUploader(_a) {
  var _b = _a, {
    acceptFormat = "*",
    compression,
    onChange = identity,
    addFilesToQueue = identity,
    updatePreviewFiles = identity,
    maxFileSize = fiveHundredMB
  } = _b, rest = __objRest$u(_b, [
    "acceptFormat",
    "compression",
    "onChange",
    "addFilesToQueue",
    "updatePreviewFiles",
    "maxFileSize"
  ]);
  const inputRef = useRef(null);
  const [isInvalid, setIsInvalid] = useState(false);
  const currentTheme = useCurrentTheme();
  const { multiFilePicker } = useMultiStyleConfig("FilePicker", __spreadValues$B({ isInvalid, currentTheme }, rest));
  const [active, setActive] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const onlyImageAccepted = onlyAcceptsImages(acceptFormat);
  useEffect(() => {
    if (isInvalid) {
      setTimeout(() => {
        setIsInvalid(false);
      }, 1500);
    }
  }, [isInvalid]);
  const toggleHover = () => {
    setActive((prev) => !prev);
  };
  const handleClick = () => {
    if (inputRef.current) {
      inputRef.current.click();
    }
  };
  const updateMultipleFiles = async (newFiles) => {
    const filesArr = Array.prototype.slice.call(newFiles);
    const validFiles = filter((file) => {
      const fileCheck = isValidFile(file, acceptFormat, maxFileSize);
      if (!fileCheck.isValid) {
        setErrorMessage(fileCheck.errorMessage || "");
      }
      return fileCheck.isValid;
    }, filesArr);
    if (filesArr.length > 0 && validFiles.length === 0) {
      setIsInvalid(true);
    }
    addFilesToQueue(validFiles.map((file) => createFileObject(file)));
    updatePreviewFiles(validFiles.map((file) => createPreviewFileObject(file)));
    const compressedFiles = validFiles.map(
      async (file) => isFileImage(file) ? compressImage(
        file,
        compression == null ? void 0 : compression.width,
        compression == null ? void 0 : compression.height,
        compression == null ? void 0 : compression.quality
      ) : file
    );
    Promise.all(compressedFiles).then((values) => {
      onChange(values);
      if (inputRef.current) {
        inputRef.current.value = "";
      }
    });
  };
  const handleDrop = (e) => {
    e.preventDefault();
    updateMultipleFiles(e.dataTransfer.files);
  };
  const handleChange = (e) => {
    if (e.target.files) {
      updateMultipleFiles(e.target.files);
    }
  };
  return /* @__PURE__ */ React.createElement(
    Clickable,
    {
      onClick: handleClick,
      onDragOver: (e) => e.preventDefault(),
      onDrop: handleDrop,
      onMouseEnter: toggleHover,
      onMouseLeave: toggleHover
    },
    /* @__PURE__ */ React.createElement(Box, __spreadValues$B({ sx: multiFilePicker }, rest), /* @__PURE__ */ React.createElement(
      Stack,
      {
        alignItems: "center",
        justifyContent: "center",
        h: "full",
        w: "full",
        spacing: 0
      },
      /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: onlyImageAccepted ? Image03Solid : UploadCloudSolid,
          boxSize: "32px",
          color: isInvalid ? "red.500 " : active ? "blue.500 " : "gray.300",
          "aria-label": "image-icon-upload",
          mb: onlyImageAccepted ? "0a" : 0
        }
      ),
      /* @__PURE__ */ React.createElement(HStack, { spacing: 1, display: isInvalid ? "none" : "flex" }, /* @__PURE__ */ React.createElement(P$1, { variant: "14", textAlign: "center", alignSelf: "center" }, "Drag & drop ", onlyImageAccepted ? "images" : "files", " here or"), /* @__PURE__ */ React.createElement(Lead$1, { sx: { textDecoration: "underline", color: "blue.500" } }, "choose ", onlyImageAccepted ? "image" : "file")),
      /* @__PURE__ */ React.createElement(P$1, { variant: "14", textAlign: "center", alignSelf: "center", display: isInvalid ? "initial" : "none" }, errorMessage),
      /* @__PURE__ */ React.createElement(P$1, { variant: "14", sx: { color: "gray.400" } }, "Max file size is ", readableFileSize(maxFileSize))
    ), /* @__PURE__ */ React.createElement(
      Input$1,
      {
        type: "file",
        display: "none",
        accept: acceptFormat,
        onChange: handleChange,
        multiple: true,
        ref: inputRef
      }
    ))
  );
}

var __defProp$A = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$A = Object.getOwnPropertySymbols;
var __hasOwnProp$A = Object.prototype.hasOwnProperty;
var __propIsEnum$A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$A = (obj, key, value) => key in obj ? __defProp$A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$A = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$A.call(b, prop))
      __defNormalProp$A(a, prop, b[prop]);
  if (__getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(b)) {
      if (__propIsEnum$A.call(b, prop))
        __defNormalProp$A(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
function FileItem({
  onChangeCallback,
  addFile = identity,
  deleteFile,
  file,
  confirmDelete = true,
  isLazy = false,
  editFileOptions = defaultEditOptions
}) {
  const { canEdit, canEditImage, canEditName } = editFileOptions;
  const { fileItem } = useMultiStyleConfig("FilePicker");
  const editModalDisclosure = useDisclosure();
  const deleteModalDisclosure = useDisclosure();
  const imageEditorRef = useRef(null);
  const [fileName, setFileName] = useState("");
  const [show, setShow] = useState(true);
  const [hasLoaded, setHasLoaded] = useState(false);
  const [loadingImage, setLoadingImage] = useState(true);
  useEffect(() => {
    if (file.src) {
      const buffer = new Image();
      buffer.src = file.src;
      buffer.onload = () => {
        setLoadingImage(false);
      };
    }
  }, [file.isUploading]);
  const handleCrop = async () => {
    if (imageEditorRef.current && isFileImage(file)) {
      const canvas = imageEditorRef.current.getImageScaledToCanvas();
      canvas.toBlob(async (blob) => {
        if (file && blob) {
          const newFile = convertBlobToFile(blob, fileName || file.name, file.type);
          deleteFile(file);
          addFile(newFile, file._id);
          onChangeCallback([newFile]);
        }
      });
      editModalDisclosure.onClose();
    } else if (file.src) {
      const newFile = await getImageAsFile(file, fileName);
      deleteFile(file);
      addFile(newFile, file._id);
      onChangeCallback([newFile]);
    }
  };
  const clearImage = () => {
    setShow(false);
    setTimeout(() => {
      deleteFile(file);
    }, 500);
  };
  return /* @__PURE__ */ React.createElement(
    SlideFade,
    {
      in: show,
      direction: "left",
      offset: 30,
      enterDuration: !isLazy ? 300 : 1,
      exitDuration: 300
    },
    /* @__PURE__ */ React.createElement(Box, { sx: fileItem }, /* @__PURE__ */ React.createElement(
      HStack,
      {
        w: "full",
        h: "full",
        borderRadius: 6,
        alignItems: "center",
        justifyContent: "space-between",
        px: 2,
        pt: file.isUploading && !hasLoaded ? 2 : 0
      },
      /* @__PURE__ */ React.createElement(HStack, { spacing: 4, alignItems: "start", maxW: "50%" }, isFileImage(file) ? file.isUploading || loadingImage ? /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: Image03Duo,
          bgColor: "gray.100",
          color: "gray.400",
          boxSize: "10",
          borderRadius: "8",
          p: "2"
        }
      ) : /* @__PURE__ */ React.createElement(
        Image$1,
        {
          src: file.src || "",
          alt: "preview-image",
          objectFit: "cover",
          display: file.src ? "inherit" : "none",
          borderRadius: "8",
          boxSize: "10"
        }
      ) : /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: FileBlankDuo,
          boxSize: "10",
          p: "1",
          color: "gray.300"
        }
      ), /* @__PURE__ */ React.createElement(
        Stack,
        {
          alignItems: "start",
          justifyContent: "start",
          spacing: "0",
          maxW: "100%"
        },
        /* @__PURE__ */ React.createElement(
          P$1,
          {
            variant: "14",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            overflow: "hidden",
            maxW: "100%"
          },
          file == null ? void 0 : file.name
        ),
        /* @__PURE__ */ React.createElement(P$1, { variant: "14", sx: { color: "gray.400" } }, (file == null ? void 0 : file.size) && readableFileSize(file.size))
      )),
      /* @__PURE__ */ React.createElement(
        HStack,
        {
          spacing: "3",
          justifyContent: "center",
          borderRadius: "6",
          bgColor: "bg.filled",
          display: file.isUploading ? "none" : "flex",
          p: "1"
        },
        canEdit && /* @__PURE__ */ React.createElement(
          FileIconButton,
          {
            "aria-label": "Edit-image",
            onClick: editModalDisclosure.onOpen,
            icon: EditBoxDuo
          }
        ),
        /* @__PURE__ */ React.createElement(
          FileIconButton,
          {
            "aria-label": "download-image",
            onClick: handleDownload(file),
            icon: DownloadDuo
          }
        ),
        /* @__PURE__ */ React.createElement(
          CloseButton$1,
          {
            onClick: confirmDelete ? deleteModalDisclosure.onOpen : clearImage
          }
        )
      )
    ), /* @__PURE__ */ React.createElement(
      Box,
      {
        w: "full",
        pl: "16",
        pr: "4",
        pb: "2",
        mt: "-2",
        display: file.isUploading ? "block" : "none"
      },
      /* @__PURE__ */ React.createElement(
        LoadingBar,
        {
          loaded: file.size ? ((file == null ? void 0 : file.uploaded) || 0) / file.size : 0,
          onLoadEnd: () => setHasLoaded(true)
        }
      )
    ), canEdit && /* @__PURE__ */ React.createElement(
      FileEditorModal,
      __spreadProps$5(__spreadValues$A({}, editModalDisclosure), {
        fileName: fileName || file.name,
        setFileName,
        image: file.src,
        canCropImage: canEditImage,
        canEditFileName: canEditName,
        handleCrop,
        isImage: isFileImage(file),
        ref: imageEditorRef
      })
    ), /* @__PURE__ */ React.createElement(
      ConfirmDeleteModal,
      __spreadProps$5(__spreadValues$A({}, deleteModalDisclosure), {
        confirmDelete: clearImage,
        fileName: fileName || file.name
      })
    ))
  );
}

var __defProp$z = Object.defineProperty;
var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
var __hasOwnProp$z = Object.prototype.hasOwnProperty;
var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$z = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$z.call(b, prop))
      __defNormalProp$z(a, prop, b[prop]);
  if (__getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(b)) {
      if (__propIsEnum$z.call(b, prop))
        __defNormalProp$z(a, prop, b[prop]);
    }
  return a;
};
var __objRest$t = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$z.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$z.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function MultiFileList(_a) {
  var _b = _a, {
    files,
    uploadingFiles,
    onChange = identity,
    deleteFile = identity,
    addFile = identity,
    confirmDelete,
    editFileOptions = defaultEditOptions,
    enableSmartLoad = true
  } = _b, rest = __objRest$t(_b, [
    "files",
    "uploadingFiles",
    "onChange",
    "deleteFile",
    "addFile",
    "confirmDelete",
    "editFileOptions",
    "enableSmartLoad"
  ]);
  const [uploadingFilesReference, setUploadingFilesReference] = useState(uploadingFiles);
  const [overflowing, setOverflowing] = useState(false);
  const formattedFiles = files == null ? void 0 : files.map((file) => isFile(file) ? createPreviewFileObject(file) : file);
  const listRef = useRef(null);
  useEffect(() => {
    if (uploadingFiles && uploadingFilesReference && files) {
      if (enableSmartLoad) {
        const newVal = getNewUploadingFiles(uploadingFilesReference, uploadingFiles, files);
        setUploadingFilesReference(newVal);
      } else {
        setUploadingFilesReference(uploadingFiles);
      }
    }
    if (listRef.current) {
      setOverflowing(isOverflowing(listRef.current));
    }
  }, [uploadingFiles, files]);
  const isLazy = uploadingFilesReference ? any((file) => file.isLazy || false, uploadingFilesReference) : false;
  return /* @__PURE__ */ React.createElement(
    Stack,
    __spreadValues$z({
      ref: listRef,
      spacing: 2,
      maxH: "sm",
      pr: overflowing ? 2 : 0,
      overflowY: "auto"
    }, rest),
    uploadingFilesReference && map((file) => /* @__PURE__ */ React.createElement(
      FileItem,
      {
        onChangeCallback: onChange,
        file,
        key: file._id,
        deleteFile,
        confirmDelete,
        isLazy,
        editFileOptions
      }
    ), uploadingFilesReference),
    formattedFiles && map((file) => /* @__PURE__ */ React.createElement(
      FileItem,
      {
        onChangeCallback: onChange,
        addFile,
        file,
        key: file._id,
        deleteFile,
        confirmDelete,
        editFileOptions
      }
    ), formattedFiles)
  );
}

var __defProp$y = Object.defineProperty;
var __getOwnPropSymbols$y = Object.getOwnPropertySymbols;
var __hasOwnProp$y = Object.prototype.hasOwnProperty;
var __propIsEnum$y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$y = (obj, key, value) => key in obj ? __defProp$y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$y.call(b, prop))
      __defNormalProp$y(a, prop, b[prop]);
  if (__getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(b)) {
      if (__propIsEnum$y.call(b, prop))
        __defNormalProp$y(a, prop, b[prop]);
    }
  return a;
};
var __objRest$s = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$y.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$y.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function MultiFilePicker(_a) {
  var _b = _a, {
    acceptFormat = "*",
    compression,
    onChange = identity,
    files = null,
    uploadingFiles,
    deleteFile = null,
    confirmDelete = true,
    maxFileSize = fiveHundredMB,
    enablePreLoad = true,
    enableSmartLoad = true,
    editFileOptions = defaultEditOptions,
    variant
  } = _b, rest = __objRest$s(_b, [
    "acceptFormat",
    "compression",
    "onChange",
    "files",
    "uploadingFiles",
    "deleteFile",
    "confirmDelete",
    "maxFileSize",
    "enablePreLoad",
    "enableSmartLoad",
    "editFileOptions",
    "variant"
  ]);
  const [bufferFiles, setBufferFiles] = useState([]);
  const [previewFiles, setPreviewFiles] = useState([]);
  const getIndexById = (id) => findIndex((file) => file._id === id, previewFiles);
  const addFile = (file, id) => {
    const addedFile = createPreviewFileObject(file);
    const indexOfChanged = getIndexById(id);
    const newPreviewFiles = remove(indexOfChanged, 1, previewFiles);
    const newFiles = insert(indexOfChanged, addedFile, newPreviewFiles);
    setPreviewFiles(newFiles);
  };
  const handleDelete = (file) => {
    const indexOfRemoved = getIndexById(file._id);
    const newPreviewFiles = remove(indexOfRemoved, 1, previewFiles);
    setPreviewFiles(newPreviewFiles);
  };
  const updateQueuedFiles = (queuedFiles) => {
    if (enablePreLoad) {
      setBufferFiles(queuedFiles);
    }
  };
  return /* @__PURE__ */ React.createElement(
    Stack,
    __spreadValues$y({
      spacing: 4,
      maxW: "inherit",
      maxH: "inherit"
    }, rest),
    /* @__PURE__ */ React.createElement(
      MultiFileUploader,
      {
        acceptFormat,
        compression,
        onChange,
        addFilesToQueue: updateQueuedFiles,
        updatePreviewFiles: setPreviewFiles,
        maxFileSize,
        variant
      }
    ),
    /* @__PURE__ */ React.createElement(
      MultiFileList,
      {
        files: files || previewFiles,
        onChange,
        uploadingFiles: isEmpty(files) && ((uploadingFiles == null ? void 0 : uploadingFiles.length) === 0 || isNil(uploadingFiles)) ? bufferFiles : uploadingFiles,
        deleteFile: deleteFile || handleDelete,
        confirmDelete,
        enableSmartLoad,
        editFileOptions,
        addFile
      }
    )
  );
}

var __defProp$x = Object.defineProperty;
var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
var __hasOwnProp$x = Object.prototype.hasOwnProperty;
var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
var __defNormalProp$x = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$x = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$x.call(b, prop))
      __defNormalProp$x(a, prop, b[prop]);
  if (__getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(b)) {
      if (__propIsEnum$x.call(b, prop))
        __defNormalProp$x(a, prop, b[prop]);
    }
  return a;
};
var __objRest$r = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$x.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$x.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const MultiFilePickerField = (_a) => {
  var _b = _a, {
    name,
    label,
    direction,
    isRequired,
    validate,
    onChange: onChangeCallback = identity
  } = _b, rest = __objRest$r(_b, [
    "name",
    "label",
    "direction",
    "isRequired",
    "validate",
    "onChange"
  ]);
  const getFiles = (sources) => {
    const buffer = map((source) => ({
      type: "jpg",
      src: source,
      name: ""
    }), sources);
    const formattedFiles = map((file) => isFile(file) ? file : createFileObjectFromSrc(file), buffer);
    return formattedFiles;
  };
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate
    },
    ({ onChange, value }) => {
      const handleDelete = (file) => {
        const removedIndex = findIndex((src) => src === file.src, value);
        const newValues = remove(removedIndex, 1, value);
        onChange(newValues);
      };
      return /* @__PURE__ */ React.createElement(
        MultiFilePicker,
        __spreadValues$x({
          onChange: async (files) => {
            if (!isEmpty(files)) {
              const newFiles = files == null ? void 0 : files.map(async (file) => toBase64(file));
              if (newFiles) {
                Promise.all(newFiles).then((values) => {
                  onChange(concat(value, values));
                  onChangeCallback(values);
                });
              }
            } else {
              onChange([]);
              onChangeCallback([]);
            }
          },
          enablePreLoad: false,
          enableSmartLoad: false,
          deleteFile: handleDelete,
          acceptFormat: "image/*",
          editFileOptions: { canEdit: true, canEditImage: true, canEditName: false },
          confirmDelete: false,
          files: getFiles(value)
        }, rest)
      );
    }
  );
};

const MediatoolThemeProvider = ({
  children,
  theme: theme$1 = theme,
  themeName = "webappTheme"
}) => /* @__PURE__ */ React.createElement(ChakraProvider, { resetCSS: true, theme: theme$1 }, /* @__PURE__ */ React.createElement(CustomTheme.Provider, { value: themeName }, children));

var __defProp$w = Object.defineProperty;
var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
var __hasOwnProp$w = Object.prototype.hasOwnProperty;
var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$w = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$w = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$w.call(b, prop))
      __defNormalProp$w(a, prop, b[prop]);
  if (__getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(b)) {
      if (__propIsEnum$w.call(b, prop))
        __defNormalProp$w(a, prop, b[prop]);
    }
  return a;
};
var __objRest$q = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$w.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$w.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Menu = (_a) => {
  var _b = _a, { variant = "relaxed" } = _b, props = __objRest$q(_b, ["variant"]);
  return /* @__PURE__ */ React.createElement(Menu$2, __spreadValues$w({ variant }, props));
};

const NumberInputStepper = ({
  includePercentage = false,
  enableStepperArrows = false
}) => /* @__PURE__ */ React.createElement(NumberInputStepper$1, null, /* @__PURE__ */ React.createElement(HStack, { alignItems: "center", h: "full" }, includePercentage && /* @__PURE__ */ React.createElement(Center, { bgColor: "gray.50", borderRadius: "md", boxSize: "6" }, /* @__PURE__ */ React.createElement(P$1, null, "%")), enableStepperArrows && /* @__PURE__ */ React.createElement(HStack, { alignItems: "center", h: "full" }, /* @__PURE__ */ React.createElement(Divider, { orientation: "vertical", h: "50%" }), /* @__PURE__ */ React.createElement(NumberIncrementStepper, { border: "none" }, /* @__PURE__ */ React.createElement(
  Icon$1,
  {
    as: ChevronUpSolid,
    color: "icon.input-stepper.default",
    boxSize: 4
  }
)), /* @__PURE__ */ React.createElement(NumberDecrementStepper, null, /* @__PURE__ */ React.createElement(
  Icon$1,
  {
    as: ChevronDownSolid,
    color: "icon.input-stepper.default",
    boxSize: 4
  }
)))));

const regex = /(9{13,}|0{13,})(\d)*$/gm;
const advancedParseFloat = (value) => {
  if (isNil(value) || Number.isNaN(parseFloat(value))) {
    return value;
  }
  const splitValue = split(".", `${value}`);
  const intPart = head(splitValue);
  const decimalPart = last(splitValue);
  if (isNil(decimalPart)) {
    return value;
  }
  const roundingError = match(regex, decimalPart);
  if (isNil(roundingError)) {
    return value;
  }
  const decimalsErrorLength = length(head(roundingError));
  const correctDecimalsLength = decimalPart.length - decimalsErrorLength;
  return parseFloat(
    parseFloat(`${intPart}.${decimalPart}`).toFixed(correctDecimalsLength)
  );
};

var __defProp$v = Object.defineProperty;
var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
var __hasOwnProp$v = Object.prototype.hasOwnProperty;
var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$v = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$v = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$v.call(b, prop))
      __defNormalProp$v(a, prop, b[prop]);
  if (__getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(b)) {
      if (__propIsEnum$v.call(b, prop))
        __defNormalProp$v(a, prop, b[prop]);
    }
  return a;
};
var __objRest$p = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$v.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$v.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const NumberInput = (_a) => {
  var _b = _a, {
    variant = "default",
    size = "md",
    onChange = identity,
    onInputChange = identity,
    enableStepperArrows = false,
    name,
    onlyAcceptPercentage = false
  } = _b, rest = __objRest$p(_b, [
    "variant",
    "size",
    "onChange",
    "onInputChange",
    "enableStepperArrows",
    "name",
    "onlyAcceptPercentage"
  ]);
  const percentageProps = onlyAcceptPercentage && {
    step: 0.1
  };
  const percentageFactor = onlyAcceptPercentage ? 0.01 : 1;
  const handleChange = (e) => {
    const input = defaultTo(e, path(["target", "value"], e));
    onInputChange(input);
    const value = advancedParseFloat(parseFloat(input) * percentageFactor);
    const filteredNaN = Number.isNaN(value) ? "" : value;
    onChange(`${filteredNaN}`);
  };
  return /* @__PURE__ */ React.createElement(
    NumberInput$2,
    __spreadValues$v(__spreadValues$v({
      variant,
      size,
      onChange: handleChange,
      id: name
    }, percentageProps), rest),
    /* @__PURE__ */ React.createElement(NumberInputField$1, { onChange: handleChange }),
    /* @__PURE__ */ React.createElement(
      NumberInputStepper,
      {
        includePercentage: onlyAcceptPercentage,
        enableStepperArrows
      }
    )
  );
};

var __defProp$u = Object.defineProperty;
var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
var __hasOwnProp$u = Object.prototype.hasOwnProperty;
var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$u = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$u.call(b, prop))
      __defNormalProp$u(a, prop, b[prop]);
  if (__getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(b)) {
      if (__propIsEnum$u.call(b, prop))
        __defNormalProp$u(a, prop, b[prop]);
    }
  return a;
};
var __objRest$o = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$u.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$u.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const NumberInputField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    direction,
    isRequired,
    validate,
    onChange: onChangeCallback = identity,
    onlyAcceptPercentage = false,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$o(_b, [
    "name",
    "label",
    "direction",
    "isRequired",
    "validate",
    "onChange",
    "onlyAcceptPercentage",
    "inputLeftElement",
    "inputRightElement"
  ]);
  const formatNumber = (value, factor) => onlyAcceptPercentage ? advancedParseFloat(value * factor) : value;
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      validate,
      ref
    },
    ({ onChange, value }) => {
      const initialValue = isNil(value) || Number.isNaN(parseFloat(value)) ? "" : formatNumber(value, 100);
      const [displayValue, setDisplayValue] = useState(initialValue);
      return /* @__PURE__ */ React.createElement(
        InputGroupWrapper,
        {
          inputLeftElement,
          inputRightElement
        },
        /* @__PURE__ */ React.createElement(
          NumberInput,
          __spreadValues$u({
            name,
            "data-testid": "number-input-field-test-id",
            onInputChange: (v) => {
              setDisplayValue(v);
              const parsed = formatNumber(parseFloat(v), 0.01);
              onChange(parsed);
              onChangeCallback(parsed);
            },
            value: displayValue,
            onlyAcceptPercentage
          }, rest)
        )
      );
    }
  );
});

var __defProp$t = Object.defineProperty;
var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
var __hasOwnProp$t = Object.prototype.hasOwnProperty;
var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$t = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$t.call(b, prop))
      __defNormalProp$t(a, prop, b[prop]);
  if (__getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(b)) {
      if (__propIsEnum$t.call(b, prop))
        __defNormalProp$t(a, prop, b[prop]);
    }
  return a;
};
var __objRest$n = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$t.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$t.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const NotificationIconButton = forwardRef$1((_a, ref) => {
  var _b = _a, {
    variant = "ghost",
    icon,
    "aria-label": ariaLabel,
    hasNotification = false,
    blinkerColor = "green.500",
    size
  } = _b, rest = __objRest$n(_b, [
    "variant",
    "icon",
    "aria-label",
    "hasNotification",
    "blinkerColor",
    "size"
  ]);
  const [isBlinking, setIsBlinking] = useState(false);
  const { container, notifier } = useMultiStyleConfig("NotificationIconButton", { size, variant });
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      onMouseEnter: () => setIsBlinking(true),
      onMouseLeave: () => setIsBlinking(false),
      sx: container
    },
    hasNotification && /* @__PURE__ */ React.createElement(Box, { sx: notifier }, /* @__PURE__ */ React.createElement(Blinker$1, { isBlinking, color: blinkerColor, size: "2xs" })),
    /* @__PURE__ */ React.createElement(
      IconButton,
      __spreadValues$t({
        variant,
        icon,
        "aria-label": ariaLabel,
        ref,
        size
      }, rest)
    )
  );
});

var __defProp$s = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$s(a, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
var __objRest$m = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$s.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$s.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const PinInput = (_a) => {
  var _b = _a, {
    variant = "outline",
    hidden,
    children
  } = _b, rest = __objRest$m(_b, [
    "variant",
    "hidden",
    "children"
  ]);
  return /* @__PURE__ */ React.createElement(PinInput$2, __spreadProps$4(__spreadValues$s({}, rest), { variant, placeholder: "\u25CF", mask: hidden }), children);
};

const isStringArray = (value) => is(Array, value) && length(value) > 0 && typeof value[0] === "string";
const getMatchingValue = (value, options) => {
  if (typeof value === "string") {
    return find(propEq("value", value), options);
  }
  if (isStringArray(value)) {
    return filter(
      (option) => value.includes(option.value),
      options
    );
  }
  return value;
};

var __defProp$r = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __objRest$l = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$r.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$r.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Select = forwardRef$1((_a, ref) => {
  var _b = _a, {
    options,
    isMulti,
    onChange = identity,
    onAdd = identity,
    onRemove = identity,
    isLoading,
    loadingList = () => null,
    "data-testid": testId,
    customOption = null,
    customTag = null,
    isClearable = false,
    value,
    icon
  } = _b, rest = __objRest$l(_b, [
    "options",
    "isMulti",
    "onChange",
    "onAdd",
    "onRemove",
    "isLoading",
    "loadingList",
    "data-testid",
    "customOption",
    "customTag",
    "isClearable",
    "value",
    "icon"
  ]);
  const handleChange = useSelectCallbacks({
    onChange,
    onAdd,
    onRemove,
    isMulti,
    value: is(Array, value) ? value : []
  });
  const customComponents = useMemo(
    () => getComponents(),
    []
  );
  const prevOptions = useRef(
    options
  );
  const renderedOptions = useMemo(() => {
    if (!equals(prevOptions.current, options)) {
      prevOptions.current = options;
    }
    return prevOptions.current;
  }, [options]);
  return /* @__PURE__ */ React.createElement(Box, { w: "full", "data-testid": testId }, /* @__PURE__ */ React.createElement(
    Select$3,
    __spreadValues$r(__spreadProps$3(__spreadValues$r({
      isMulti,
      options: renderedOptions,
      useBasicStyles: true,
      closeMenuOnSelect: !isMulti,
      hideSelectedOptions: false,
      isClearable,
      onChange: handleChange,
      selectedOptionStyle: "check",
      chakraStyles: customSelectStyles,
      isLoading
    }, isLoading && { components: { MenuList: loadingList } }), {
      value: getMatchingValue(value, options),
      customOption,
      customTag,
      icon,
      components: customComponents,
      ref,
      menuPortalTarget: document.body,
      styles: { menuPortal: (base) => __spreadProps$3(__spreadValues$r({}, base), { zIndex: theme.zIndices.popover }) }
    }), rest)
  ));
});

var __defProp$q = Object.defineProperty;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
var __objRest$k = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$q.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$q.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const BaseSelectField = (_a, ref) => {
  var _b = _a, {
    name,
    label,
    options,
    direction = "column",
    isMulti,
    isRequired,
    validate,
    isClearable = true,
    onChange: onChangeCallback = identity,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$k(_b, [
    "name",
    "label",
    "options",
    "direction",
    "isMulti",
    "isRequired",
    "validate",
    "isClearable",
    "onChange",
    "inputLeftElement",
    "inputRightElement"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      direction,
      isRequired,
      noLabelConnection: true,
      validate,
      ref
    },
    ({ value, onChange }) => /* @__PURE__ */ React.createElement(HStack, { w: "full" }, /* @__PURE__ */ React.createElement(
      InputGroupWrapper,
      {
        inputLeftElement,
        inputRightElement
      },
      /* @__PURE__ */ React.createElement(
        Select,
        __spreadValues$q({
          name,
          options,
          isMulti,
          onChange: (values, event) => {
            onChange(
              isMulti ? values.map((item) => item.value) : values.value
            );
            onChangeCallback(values, event);
          },
          value: value ? options == null ? void 0 : options.flatMap((inner) => inner.options ? inner.options : inner).filter((option) => value.includes(option.value)) : null
        }, rest)
      )
    ), /* @__PURE__ */ React.createElement(
      IconButton,
      {
        "aria-label": `${name}-close-button`,
        variant: "danger",
        size: "sm",
        fontSize: "xs",
        hidden: value === void 0 || !isClearable,
        onClick: () => {
          onChange(void 0);
        },
        icon: /* @__PURE__ */ React.createElement(Icon$1, { as: XCloseSolid })
      }
    ))
  );
};
const SelectField = forwardRef$1(BaseSelectField);

var __defProp$p = Object.defineProperty;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
var __objRest$j = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$p.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$p.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Switch = (_a) => {
  var _b = _a, {
    value,
    onChange,
    name,
    size = "md"
  } = _b, rest = __objRest$j(_b, [
    "value",
    "onChange",
    "name",
    "size"
  ]);
  return /* @__PURE__ */ React.createElement(
    Switch$2,
    __spreadValues$p({
      size,
      id: name,
      isChecked: value,
      onChange
    }, rest)
  );
};

var __defProp$o = Object.defineProperty;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var __objRest$i = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$o.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$o.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SwitchField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    isRequired,
    validate,
    onChange: onChangeCallback = identity,
    direction = "row",
    labelPlacement = "right",
    labelSize = "md"
  } = _b, rest = __objRest$i(_b, [
    "name",
    "label",
    "isRequired",
    "validate",
    "onChange",
    "direction",
    "labelPlacement",
    "labelSize"
  ]);
  return /* @__PURE__ */ React.createElement(Box, { w: label ? "full" : "fit-content", display: "inline-flex" }, /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label: "",
      isRequired,
      direction,
      validate,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      Flex,
      {
        display: "inline-flex",
        alignItems: "center",
        gap: 2,
        direction: labelPlacement === "left" ? "row-reverse" : "row"
      },
      /* @__PURE__ */ React.createElement(
        Switch,
        __spreadValues$o({
          name,
          onChange: (e) => {
            onChange(e);
            onChangeCallback(e);
          },
          value,
          "data-testid": "switch-field-test-id"
        }, rest)
      ),
      /* @__PURE__ */ React.createElement(Label$1, { htmlFor: name, sx: { fontWeight: "normal" }, size: labelSize }, label)
    )
  ));
});

var __defProp$n = Object.defineProperty;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
const TabPanel = (props) => /* @__PURE__ */ React.createElement(TabPanel$1, __spreadValues$n({ padding: 0 }, props));

var __defProp$m = Object.defineProperty;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __objRest$h = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$m.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$m.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Tabs = (_a) => {
  var _b = _a, {
    children,
    variant = "soft-rounded",
    isManual = true
  } = _b, rest = __objRest$h(_b, [
    "children",
    "variant",
    "isManual"
  ]);
  return /* @__PURE__ */ React.createElement(
    Tabs$2,
    __spreadValues$m({
      isManual,
      variant
    }, rest),
    children
  );
};

var __defProp$l = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
var __objRest$g = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$l.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$l.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Textarea = (_a) => {
  var _b = _a, {
    size = "md",
    onChange,
    name,
    value
  } = _b, rest = __objRest$g(_b, [
    "size",
    "onChange",
    "name",
    "value"
  ]);
  return /* @__PURE__ */ React.createElement(
    Textarea$2,
    __spreadValues$l({
      size,
      id: name,
      onChange,
      value
    }, rest)
  );
};

var __defProp$k = Object.defineProperty;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
var __objRest$f = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$k.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$k.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TextareaField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    isRequired,
    validate,
    direction,
    onChange: onChangeCallback = identity
  } = _b, rest = __objRest$f(_b, [
    "name",
    "label",
    "isRequired",
    "validate",
    "direction",
    "onChange"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      isRequired,
      validate,
      direction,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      Textarea,
      __spreadValues$k({
        name,
        "data-testid": "textarea-field-test-id",
        onChange: (e) => {
          onChange(e);
          onChangeCallback(e);
        },
        value
      }, rest)
    )
  );
});

const roundToPrecision = (value, numberOfDecimals) => parseFloat(value.toFixed(numberOfDecimals));

var __defProp$j = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __objRest$e = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$j.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$j.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const presetMap = {
  eu: {
    thousandSeparator: " ",
    decimalSeparator: ","
  },
  us: {
    thousandSeparator: ",",
    decimalSeparator: "."
  },
  nor: {
    thousandSeparator: ".",
    decimalSeparator: ","
  }
};
const FormattedNumberInput = (_a) => {
  var _b = _a, {
    preset = "eu",
    isPercentage = false,
    onChange = identity,
    value,
    numberOfDecimals = 2,
    max = Infinity,
    min = -Infinity,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$e(_b, [
    "preset",
    "isPercentage",
    "onChange",
    "value",
    "numberOfDecimals",
    "max",
    "min",
    "inputLeftElement",
    "inputRightElement"
  ]);
  const props = presetMap[preset];
  const [v, setV] = useState(value);
  const validateRange = () => {
    if (isNil(v))
      return;
    const vNum = typeof v === "string" ? parseFloat(v) : v;
    const factor = isPercentage ? 100 : 1;
    if (vNum * factor > max) {
      const newValue = roundToPrecision(max / factor, numberOfDecimals);
      setV(newValue);
    }
    if (vNum * factor < min) {
      const newValue = roundToPrecision(min / factor, numberOfDecimals);
      setV(newValue);
    }
  };
  const onValueChangeHandler = (values, sourceInfo) => {
    const newFloatValue = values.floatValue && isPercentage ? roundToPrecision(values.floatValue / 100, numberOfDecimals) : values.floatValue;
    setV(newFloatValue);
    onChange(
      __spreadProps$2(__spreadValues$j({}, values), {
        floatValue: newFloatValue
      }),
      sourceInfo
    );
  };
  return /* @__PURE__ */ React.createElement(
    InputGroupWrapper,
    {
      inputLeftElement,
      inputRightElement
    },
    /* @__PURE__ */ React.createElement(
      NumericFormat,
      __spreadValues$j(__spreadValues$j({
        allowLeadingZeros: true,
        customInput: Input$1,
        onBlur: validateRange,
        onValueChange: onValueChangeHandler,
        decimalScale: numberOfDecimals,
        value: isPercentage ? roundToPrecision(parseFloat(`${v != null ? v : 0}`) * 100, numberOfDecimals) : v,
        suffix: isPercentage ? "%" : ""
      }, props), rest)
    )
  );
};

var __defProp$i = Object.defineProperty;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
var __objRest$d = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FormattedNumberInputField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    isRequired,
    validate,
    onChange: onChangeCallback = identity,
    direction = "row"
  } = _b, rest = __objRest$d(_b, [
    "name",
    "label",
    "isRequired",
    "validate",
    "onChange",
    "direction"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      isRequired,
      direction,
      validate,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      FormattedNumberInput,
      __spreadValues$i({
        name,
        onChange: (values, sourceInfo) => {
          onChange(values.floatValue);
          onChangeCallback(values, sourceInfo);
        },
        value
      }, rest)
    )
  );
});

var __defProp$h = Object.defineProperty;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
var __objRest$c = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
//! Overload error in @types/react-input-mask, overwriting faulty types as unknown as any
const CustomInput = InputMask;
const MaskedTextInput = (_a) => {
  var _b = _a, {
    mask,
    maskPlaceholder,
    alwaysShowMask,
    name,
    value,
    placeholder,
    onChange,
    onBlur
  } = _b, rest = __objRest$c(_b, [
    "mask",
    "maskPlaceholder",
    "alwaysShowMask",
    "name",
    "value",
    "placeholder",
    "onChange",
    "onBlur"
  ]);
  return /* @__PURE__ */ React.createElement(
    CustomInput,
    {
      mask,
      maskPlaceholder,
      alwaysShowMask,
      name,
      value,
      onChange,
      onBlur
    },
    ({ name: nameProp }) => /* @__PURE__ */ React.createElement(
      Input$1,
      __spreadValues$h({
        placeholder: maskPlaceholder != null ? maskPlaceholder : placeholder,
        name: nameProp
      }, rest)
    )
  );
};

var __defProp$g = Object.defineProperty;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
var __objRest$b = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const TextField = forwardRef$1((_a, ref) => {
  var _b = _a, {
    name,
    label,
    as: As = Input$1,
    isRequired,
    validate,
    direction = "column",
    onChange: onChangeCallback = identity,
    inputLeftElement,
    inputRightElement
  } = _b, rest = __objRest$b(_b, [
    "name",
    "label",
    "as",
    "isRequired",
    "validate",
    "direction",
    "onChange",
    "inputLeftElement",
    "inputRightElement"
  ]);
  return /* @__PURE__ */ React.createElement(
    Field,
    {
      name,
      label,
      isRequired,
      validate: isNil(validate) && isRequired ? { validate: (value) => !!value.trim() } : validate,
      direction,
      ref
    },
    ({ onChange, value }) => /* @__PURE__ */ React.createElement(
      InputGroupWrapper,
      {
        inputLeftElement,
        inputRightElement
      },
      /* @__PURE__ */ React.createElement(
        As,
        __spreadValues$g({
          id: name,
          name,
          onChange: (e) => {
            onChange(e);
            onChangeCallback(e);
          },
          value,
          "data-testid": "text-field-test-id"
        }, rest)
      )
    )
  );
});

var __defProp$f = Object.defineProperty;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
var __objRest$a = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Toast = (_a) => {
  var _b = _a, {
    variant = "success",
    title = "",
    description = "",
    onClose
  } = _b, rest = __objRest$a(_b, [
    "variant",
    "title",
    "description",
    "onClose"
  ]);
  const icon = toastIconMap[variant];
  return /* @__PURE__ */ React.createElement(
    Alert$2,
    __spreadValues$f({
      variant,
      "data-testid": "toast-test"
    }, rest),
    /* @__PURE__ */ React.createElement(HStack, { alignItems: "flex-start" }, icon && /* @__PURE__ */ React.createElement(
      Icon$1,
      {
        as: icon,
        color: `icon.toast.${variant}`,
        boxSize: 6
      }
    ), /* @__PURE__ */ React.createElement(Stack, { spacing: 0, alignItems: "flex-start" }, title && /* @__PURE__ */ React.createElement(Label$1, { size: "md" }, title), description && /* @__PURE__ */ React.createElement(P$1, null, description)), /* @__PURE__ */ React.createElement(
      CloseButton$1,
      {
        size: "sm",
        onClick: onClose,
        position: "absolute",
        insetEnd: 1,
        top: 1
      }
    ))
  );
};

var __defProp$e = Object.defineProperty;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
const useToast = (defaultOpts = {}) => {
  const toast = useToast$1(defaultOpts);
  const toastIdRef = useRef(null);
  return (opts = {}) => {
    const toastProps = __spreadValues$e({
      render: ({ onClose }) => {
        const {
          variant = "success",
          title = "Success",
          description = ""
        } = opts;
        return /* @__PURE__ */ React.createElement(
          Toast,
          {
            variant,
            title,
            description,
            onClose
          }
        );
      },
      position: "top"
    }, opts);
    const { replacePreviousToast = false } = opts;
    if (replacePreviousToast && toastIdRef && toastIdRef.current) {
      toast.update(toastIdRef.current, toastProps);
    } else {
      toastIdRef.current = toast(toastProps);
    }
  };
};

const pinVariantMap = {
  green: "green.500",
  running: "green.500",
  yellow: "yellow.600",
  inProgress: "yellow.600",
  gray: "gray.300",
  notExecuted: "gray.300",
  red: "red.500",
  rejected: "red.500"
};

const pinSizeMap = {
  sm: [4, 2],
  md: [5, 3],
  lg: [6, 3.5]
};

var __defProp$d = Object.defineProperty;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __objRest$9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StatusPin = (_a) => {
  var _b = _a, { size = "md", variant } = _b, rest = __objRest$9(_b, ["size", "variant"]);
  const pinColor = pinVariantMap[variant];
  const pinSizeTuple = pinSizeMap[size];
  const [outerSize, innerSize] = pinSizeTuple;
  return /* @__PURE__ */ React.createElement(
    Circle,
    __spreadValues$d({
      size: outerSize,
      bg: "white",
      borderWidth: "1px",
      borderColor: pinColor
    }, rest),
    /* @__PURE__ */ React.createElement(
      Circle,
      {
        size: innerSize,
        bg: pinColor
      }
    )
  );
};

const blockVariantMap = {
  approved: ["green.100", "green.500"],
  pending: ["yellow.300", "yellow.700"],
  working: ["gray.50", "gray.400"],
  rejected: ["red.100", "red.400"]
};

const statusIconMap = {
  working: StatusWorkingSolid,
  pending: HourglassSolid,
  approved: CheckCircleSolid,
  rejected: CDeleteSolid
};

var __defProp$c = Object.defineProperty;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __objRest$8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StatusBlock = (_a) => {
  var _b = _a, { variant } = _b, rest = __objRest$8(_b, ["variant"]);
  const [bgColor, contentColor] = blockVariantMap[variant];
  return /* @__PURE__ */ React.createElement(
    Tag,
    __spreadValues$c({
      w: 28,
      h: 8,
      justifyContent: "center",
      bgColor,
      color: contentColor,
      borderRadius: 4
    }, rest),
    /* @__PURE__ */ React.createElement(TagLeftIcon, null, /* @__PURE__ */ React.createElement(Icon$2, { as: statusIconMap[variant] })),
    /* @__PURE__ */ React.createElement(
      TagLabel,
      {
        lineHeight: 5,
        fontWeight: "semibold",
        textTransform: "capitalize"
      },
      variant
    )
  );
};

var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
var __objRest$7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$b.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$b.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const AsyncError = (_a) => {
  var _b = _a, {
    message = ""
  } = _b, rest = __objRest$7(_b, [
    "message"
  ]);
  return /* @__PURE__ */ React.createElement(Alert$2, __spreadValues$b({ backgroundColor: "background.default", color: "text.default", width: "100%" }, rest), /* @__PURE__ */ React.createElement(VStack, { w: "full" }, /* @__PURE__ */ React.createElement(Icon$1, { as: toastIconMap.error, color: "icon.toast.error", boxSize: 6 }), /* @__PURE__ */ React.createElement(AlertTitle, null, " Error "), message && /* @__PURE__ */ React.createElement(AlertDescription, null, message)));
};

var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
const StepPanel = (props) => /* @__PURE__ */ React.createElement(TabPanel, __spreadValues$a({ padding: 0 }, props));

var __defProp$9 = Object.defineProperty;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
const Steps = (props) => /* @__PURE__ */ React.createElement(Tabs$2, __spreadValues$9({ isManual: true }, props));

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __objRest$6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const Step = (_a) => {
  var _b = _a, { label, description } = _b, rest = __objRest$6(_b, ["label", "description"]);
  const {
    step,
    label: labelStyle,
    description: descriptionStyle
  } = useMultiStyleConfig("Step");
  return /* @__PURE__ */ React.createElement(
    Tab,
    __spreadValues$8({
      sx: step
    }, rest),
    /* @__PURE__ */ React.createElement(
      Flex,
      {
        flexDirection: "column",
        alignItems: "flex-start",
        _groupFocusVisible: ring
      },
      /* @__PURE__ */ React.createElement(Capitalized$1, { sx: labelStyle }, label),
      /* @__PURE__ */ React.createElement(Lead$1, { sx: descriptionStyle }, description)
    )
  );
};

var __defProp$7 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StepList = (_a) => {
  var _b = _a, { children } = _b, rest = __objRest$5(_b, ["children"]);
  const tabs = Children.count(children);
  const styles = useStyleConfig("StepList", { tabs });
  return /* @__PURE__ */ React.createElement(TabList, __spreadProps$1(__spreadValues$7({}, rest), { sx: styles }), children);
};

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const ClipboardInput = forwardRef$1((_a, ref) => {
  var _b = _a, {
    size = "md",
    value,
    "aria-label": ariaLabel
  } = _b, rest = __objRest$4(_b, [
    "size",
    "value",
    "aria-label"
  ]);
  const { hasCopied, onCopy, setValue } = useClipboard(value);
  const { button, icon, tooltip } = useMultiStyleConfig("ClipboardInput", { size });
  useEffect(() => {
    setValue(value);
  }, [value]);
  return /* @__PURE__ */ React.createElement(InputGroup, { size, "data-testid": "clipboard-input-test-id", ref }, /* @__PURE__ */ React.createElement(
    Input$1,
    __spreadValues$6({
      textOverflow: "ellipsis",
      "aria-label": `Value to copy: ${value}`,
      isReadOnly: true,
      value
    }, rest)
  ), /* @__PURE__ */ React.createElement(InputRightElement, null, /* @__PURE__ */ React.createElement(
    Tooltip,
    {
      label: hasCopied ? "Copied!" : "Copy",
      placement: "left",
      closeOnClick: false,
      sx: tooltip
    },
    /* @__PURE__ */ React.createElement(
      IconButton,
      {
        "aria-label": ariaLabel || "Click to copy",
        onClick: onCopy,
        variant: hasCopied ? "success" : "default",
        sx: button
      },
      /* @__PURE__ */ React.createElement(
        Icon$1,
        {
          as: hasCopied ? CheckDuo : CopyDuo,
          sx: icon
        }
      )
    )
  )));
});

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const SplitPane = (_a) => {
  var _b = _a, {
    children,
    initialSplit = 50,
    isOpen,
    minLeftWidth = 25,
    minRightWidth = 50
  } = _b, rest = __objRest$3(_b, [
    "children",
    "initialSplit",
    "isOpen",
    "minLeftWidth",
    "minRightWidth"
  ]);
  const dividerRef = useRef(null);
  const mouseDownHandler = useCallback(
    (e) => {
      if (e.target !== dividerRef.current) {
        return;
      }
      let requestedFrame = null;
      e.stopPropagation();
      e.preventDefault();
      const target = e.currentTarget;
      target.setPointerCapture(e.pointerId);
      target.onpointermove = (moveEvent) => {
        if (!(moveEvent.buttons && 1)) {
          target.onpointermove = null;
          target.releasePointerCapture(moveEvent.pointerId);
          return;
        }
        moveEvent.stopPropagation();
        moveEvent.preventDefault();
        if (!requestedFrame) {
          const { offsetX } = moveEvent;
          requestedFrame = requestAnimationFrame(() => {
            target.style.setProperty(
              "--split-pos",
              `${Math.max(offsetX, 0)}px`
            );
            requestedFrame = null;
          });
        }
      };
    },
    []
  );
  const containerStyle = useStyleConfig("SplitPane", { minLeftWidth, minRightWidth, initialSplit, isOpen });
  return /* @__PURE__ */ React.createElement(
    Grid,
    __spreadValues$5({
      sx: containerStyle,
      onPointerDown: mouseDownHandler
    }, rest),
    children[0],
    isOpen && cloneElement(children[1], { ref: dividerRef }),
    isOpen && children[2]
  );
};

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const PaneItem = (_a) => {
  var _b = _a, { children } = _b, rest = __objRest$2(_b, ["children"]);
  return /* @__PURE__ */ React.createElement(GridItem, __spreadValues$4({ overflow: "hidden" }, rest), children);
};

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const PaneDivider = forwardRef((props, ref) => {
  const style = useStyleConfig("PaneDivider");
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadValues$3({
      ref,
      sx: style
    }, props)
  );
});

var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const StepStack = (_a) => {
  var _b = _a, {
    children,
    spacing = "4",
    rowHeight = "10",
    stepCircleAlignment = "center",
    stepCircleMarginTopPx = 0
  } = _b, rest = __objRest$1(_b, [
    "children",
    "spacing",
    "rowHeight",
    "stepCircleAlignment",
    "stepCircleMarginTopPx"
  ]);
  const rows = getChildrenWithProps(children, {});
  const parsedRowHeight = useToken("sizes", rowHeight);
  return /* @__PURE__ */ React.createElement(Stack, __spreadValues$2({ spacing, position: "relative" }, rest), rows.map(
    (row, i) => /* @__PURE__ */ React.createElement(HStack, { key: `row-${i}`, alignItems: stepCircleAlignment }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Box,
      {
        borderRadius: "full",
        bgColor: "blue.500",
        boxSize: "6",
        minW: "6",
        minH: "6",
        zIndex: "docked",
        marginTop: `${stepCircleMarginTopPx}px`
      },
      /* @__PURE__ */ React.createElement(
        Label$1,
        {
          size: "sm",
          sx: { color: "text.inverted" },
          w: "max-content",
          textAlign: "center"
        },
        i + 1
      )
    ), row))
  ), /* @__PURE__ */ React.createElement(
    Divider,
    {
      orientation: "vertical",
      left: "3",
      top: `calc(${parsedRowHeight} / 2 + ${stepCircleMarginTopPx}px)`,
      h: `calc(100% - ${parsedRowHeight} - ${stepCircleMarginTopPx}px)`,
      position: "absolute"
    }
  ));
};

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const customComponents = {
  Option: (_a) => {
    var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
    return /* @__PURE__ */ React.createElement(chakraComponents.Option, __spreadValues$1({}, props), /* @__PURE__ */ React.createElement(React.Fragment, null, props.data.isCreation ? /* @__PURE__ */ React.createElement(Flex, { mr: 3, width: 1.5, mb: 0.5, justifyContent: "center", alignItems: "center" }, /* @__PURE__ */ React.createElement(Icon$1, { mb: "4px", as: PlusSolid, color: "brand" })) : /* @__PURE__ */ React.createElement(Box, { mr: 3, width: 1.5 }), children));
  }
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const CreatableSelectDropdown = ({
  standardOptions,
  initialPlaceholder = "Select or create...",
  addOptionPlaceholder = "Enter text...",
  creationOption = {
    label: "Add option...",
    value: "Add option...",
    isCreation: true
  },
  onOptionChange,
  width = "100%",
  variant = "outline",
  initialValue
}) => {
  const initialSelectedOption = useMemo(
    () => {
      var _a;
      if (isNil(initialValue)) {
        return null;
      }
      return (_a = standardOptions.find((option) => option.value === initialValue)) != null ? _a : null;
    },
    []
  );
  const [selectedOption, setSelectedOption] = useState(initialSelectedOption);
  const [newOptionText, setNewOptionText] = useState("");
  const [newOptionPlaceholder, setNewOptionPlaceholder] = useState(initialPlaceholder);
  const [createdOptions, setCreatedOptions] = useState([]);
  function isCreationOption(option) {
    return option && typeof option.isCreation === "boolean";
  }
  const ref = useRef(null);
  useOutsideClick({
    ref,
    handler: () => {
      if (isCreationOption(selectedOption)) {
        setSelectedOption(initialSelectedOption);
        setNewOptionPlaceholder(initialPlaceholder);
      }
    }
  });
  const handleInputChange = (newValue) => {
    setNewOptionText(newValue);
  };
  const handleCreateOption = () => {
    const newOptionTextLower = newOptionText.toLowerCase();
    const newOptionExists = standardOptions.some((option) => option.value.toLowerCase() === newOptionTextLower);
    if (!newOptionExists) {
      const newOption = { label: newOptionText, value: newOptionText };
      setCreatedOptions((currentCreatedOptions) => [...currentCreatedOptions, newOption]);
      setSelectedOption(newOption);
      onOptionChange(newOption);
    }
    setNewOptionText("");
    setNewOptionPlaceholder(initialPlaceholder);
  };
  const handleChange = (newValue, _actionMeta) => {
    const option = newValue;
    if (option === null) {
      return;
    }
    if (isCreationOption(option)) {
      setNewOptionPlaceholder(addOptionPlaceholder);
    } else {
      setNewOptionPlaceholder(initialPlaceholder);
    }
    setSelectedOption(option);
    onOptionChange(option);
  };
  const handleKeyDown = (event) => {
    if (event.key === "Enter" && newOptionText) {
      handleCreateOption();
      event.preventDefault();
    }
  };
  const combinedOptions = [...standardOptions, ...createdOptions];
  const customOptions = [
    __spreadProps(__spreadValues({}, creationOption), {
      icon: /* @__PURE__ */ React.createElement(Icon$2, { as: PlusSolid, color: "brand" })
    }),
    ...combinedOptions
  ];
  return /* @__PURE__ */ React.createElement(Box, { ref }, /* @__PURE__ */ React.createElement(
    CreatableSelect,
    {
      chakraStyles: __spreadProps(__spreadValues({}, customSelectStyles), {
        container: (provided) => __spreadProps(__spreadValues({}, provided), {
          width
        }),
        option: (provided, { isSelected }) => __spreadValues(__spreadValues({}, provided), isSelected && {
          color: "black"
        })
      }),
      components: customComponents,
      options: customOptions,
      value: selectedOption,
      onChange: handleChange,
      isMulti: false,
      onInputChange: handleInputChange,
      onKeyDown: handleKeyDown,
      onCreateOption: handleCreateOption,
      placeholder: newOptionPlaceholder,
      inputValue: newOptionText,
      useBasicStyles: true,
      variant
    }
  ));
};

export { Accordion, AccordionButton, AccordionItem, AccordionPanel, Alert$1 as Alert, AspectRatio, AsyncError, Avatar$1 as Avatar, AvatarGroup, Badge$1 as Badge, Blinker$1 as Blinker, Blockquote$1 as Blockquote, Button$1 as Button, Capitalized$1 as Capitalized, Carousel, Checkbox$1 as Checkbox, CheckboxField, Clickable, ClipboardInput, Collapse, ColorPicker$1 as ColorPicker, ColorPickerField, CreatableSelectDropdown, CustomTheme, DatePicker, DatePickerField, DateRangePicker, DateRangePickerField, DragAndDrop, DragHandle, DragItem, Draggable, DropZone, Droppable, EditableText, Fade, FastGrid, FastList, Field, FilePicker, FilePickerField, FlipButton$1 as FlipButton, FlipButtonGroup, FlipButtonGroupField, Form, FormLabel, FormattedNumberInput, FormattedNumberInputField, H1$1 as H1, H2$1 as H2, H3$1 as H3, H4$1 as H4, H5$1 as H5, H6$1 as H6, Icon$1 as Icon, IconButton, IntentButton, Label$1 as Label, Lead$1 as Lead, LoadingBar, MaskedTextInput, MediatoolThemeProvider, Menu, Modal, ModalBase, ModalBody, MultiFileList, MultiFilePicker, MultiFilePickerField, MultiFileUploader, MultiSort, NotificationIconButton, NumVal$1 as NumVal, NumberInput, NumberInputField, OrganizationLogo, OverflowGroup, P$1 as P, PaneDivider, PaneItem, PinInput, Popover$1 as Popover, ProgressBar, Radio, RadioGroup, RadioGroupField, ResizeHandle, ScaleFade, SearchBar, SearchBarField, Select, SelectField, Slide, SlideFade, Small$1 as Small, Sortable, SortableContainer, SortableItem, SortableList, Spinner$1 as Spinner, SplitPane, StatusBlock, StatusPin, Step, StepList, StepPanel, StepStack, Steps, Switch, SwitchField, TabPanel, Table, Tabs, Tag, TagGroup, TagsInput, TextField, Textarea, TextareaField, Tiny$1 as Tiny, Toast, Toolbox, ToolboxContent, ToolboxFooter, ToolboxHeader, Tooltip, addAlpha, advancedParseFloat, clamp, createDebounceFunctionInstance, getChildrenWithProps, getContrastColor, getFieldError, getInitials, getMatchingValue, getShades, highlight, luminosity, ring, statusIconMap, theme, tottTheme, trimFormValues, useArrowFocus, useCurrentTheme, useDebounce, useDidUpdateEffect, useLoadingMessage, useOutsideRectClick, useOverflowGroup, useResizeWidth, useScreenSize, useScrollToBottom, useSelectCallbacks, useSetValueRefreshed, useToast };
//# sourceMappingURL=northlight.js.map
